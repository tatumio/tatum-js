{
  "openapi": "3.1.0",
  "security": [{ "X-API-Key": [] }],
  "info": {
    "title": "Tatum API Reference",
    "version": "3.17.0",
    "description": "# Welcome to the Tatum API Reference!\n\n## What is Tatum?\n\nTatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the\nTatum blockchain development framework, visit [our website](https://tatum.io/framework).\n\nThe Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all\nsupported blockchains using unified API calls.\n\n## Need help?\n\nTo chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join \nour [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum,\nreview the [online documentation](https://docs.tatum.io/).\n\n## About this API Reference\n\nThe Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few\n[vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.\n\n# Authentication\n\nWhen using the Tatum API, you authenticate yourself with an **API key**.\n<SecurityDefinitions />\n",
    "x-logo": { "url": "https://tatum.io/images/Light.svg", "altText": "Tatum" }
  },
  "servers": [{ "url": "https://api-eu1.tatum.io" }, { "url": "https://api-us-west1.tatum.io" }],
  "tags": [
    {
      "description": "<p>Interact with the blockchain directly by connecting to the blockchain node and communicating with it through JSON-RPC.</p>\n<p>Each node-related API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Node RPC"
    },
    {
      "description": "<p>A Tatum Account is the primary building block of Tatum-powered applications. It is an envelope that holds essential information about balances, the state of the account or customer, and to whom the account belongs.<br/><br/>\nAccounts in Tatum are stored within Tatum Private Ledger. Tatum Private Ledger contains information about accounts, the customers that own the accounts, transactions that affect the accounts or virtual currencies present in the ledger.<br/><br/>\nBy default, the private ledger is not connected to any blockchain. It is possible to create an application on it without any blockchain at all. Using Tatum Private Ledger and the building blocks included within it, it is possible to quickly swap the whole application from the ledger to any blockchain supported by Tatum. All of the API calls will remain the same, the only thing that changes is the blockchain the application lives on.<br/><br/>\nMost blockchains do not have any compliance layer at all. It is not possible to freeze funds at a blockchain address or deactivate an address. The Tatum Account has built-in compliance, and it is possible to block funds in the account, freeze outgoing transactions from the account or even completely deactivate the account.\n</p>\n",
      "name": "Account"
    },
    {
      "description": "<p>An endpoint used to create and list transactions within Tatum Private Ledger. A transaction is performed between 2 accounts with the same currency. To perform an exchange operation between accounts with different currencies, API calls from <a href=\"#tag/Order-BookLedger-Order-Book\">Order Book</a> sections are available. Transactions in the ledger are instant, with a settlement time of below 200ms.<br/>\nTatum Private Ledger supports microtransactions - a transaction of an amount as little as 1e-30 (30 decimal places). Transactions are atomic.<br/>\nWhen there is an insufficient balance in the sender account, or recipient account cannot receive funds, the transaction is not settled.</p>\n",
      "name": "Transaction"
    },
    {
      "description": "<p>An endpoint used to handle customer operations, like updating customer information, enabling/disabling etc.\nWithin Tatum API, a customer represents a client of the entity that communicates with Tatum.<br/>\nCustomers cannot be created via any other operation than Create Ledger Account.<br/>\nDue to compliance restrictions, it is recommended to enter the country of residence of the customer and the country of the provider. The Tatum compliance engine operates based on this information.\n</p>\n",
      "name": "Customer"
    },
    {
      "description": "<p>Register and use Tatum Private Ledger's virtual currencies. You can create your own virtual currency and distribute it amongst your customers.<br/>\nVirtual currencies are used to support FIAT currencies. When a virtual currency is created with basePair of the FIAT currency, it is possible to perform transactions in the private ledger in FIAT.\n</p>\n",
      "name": "Virtual Currency"
    },
    {
      "description": "<p>The gas pump is Tatum's feature that helps you manage gas fees in a custodial application. When you use the gas pump, gas fees for any transaction made by your customers (users of your custodial application) are automatically deducted from the master address instead of the customer's address. This eliminates the need to send crypto to each customer's address to pay for gas fees.</p>\n<p>For more information about the gas pump, see <a href=\"https://docs.tatum.io/gas-pump/pay-gas-fees-with-tatum-gas-pump\" target=\"_blank\">our user documentation</a>.</p>\n<p>Each API related to the gas pump supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Gas pump"
    },
    {
      "description": "<p>Endpoints to handle subscriptions to the Tatum Platform. Subscriptions allow users to enable some additional features or reports that are not enabled by default,\nlike outgoing off-chain transaction scanning, accounts with balances above the limit, etc.</p>\n",
      "name": "Notification subscriptions"
    },
    {
      "description": "<p>Endpoint to handle Order book operations like creating BID / ASK trades between Tatum Private Virtual accounts, obtaining trade histories, creating futures etc. It is possible to build an exchange based on the Ledger Accounts.</p>",
      "name": "Order Book"
    },
    {
      "description": "<p><a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System</a> (KMS) is a comprehensive solution for building custodial applications. KMS runs locally on your server and provides security for generating wallets, addresses, and private keys, and for signing transactions.</p>\n<p>KMS builds a list of pending transaction to sign and provides the options to complete a transaction after it has been signed and to obtain transaction details with the result of the blockchain operation via the transaction ID.</p>\n<p>In KMS, each managed wallet or private key is assigned a unique signature ID (<code>signatureId</code>) that represents that wallet or private key. This signature ID is then used in an API request to identify the wallet.</p>\n<p>Depending on the API, you can use the signature ID in an API call request in the following ways:</p>\n<ul>\n<li>\nTo represent the <b>mnemonic</b> type of the wallet; for example, in the <a href=\"https://apidoc.tatum.io/tag/Blockchain-operations#operation/BtcTransfer\" target=\"_blank\">API for sending BTC from a virtual account to the blockchain</a> (see the <code>transferBtcKMS</code> request schema).</li>\n<li>To represent the <b>privateKey</b> type of the wallet; for example, in the <a href=\"https://apidoc.tatum.io/tag/Bitcoin#operation/BtcTransferBlockchain\" target=\"_blank\">API for sending BTC to a blockchain address</a> (see the <code>BtcTransactionFromUTXOKMS</code> request schema).</li>\n<li>To represent the <b>mnemonic</b> and <b>index</b> type of the wallet; for example, in the <a href=\"https://apidoc.tatum.io/tag/Blockchain-operations#operation/EthTransfer\" target=\"_blank\">API for sending ETH from a virtual account to the blockchain</a> (see the <code>transferEthKMS</code> request schema).<br />In this case, the index of the specific private key generated from the mnemonic must be used in addition to the signature ID.</li>\n</ul>\n<p>You can run KMS on the following operating systems:</p>\n<ul>\n<li><b>macOS:</b> Natively or via <a href=\"https://hub.docker.com/repository/docker/tatumio/tatum-kms\" target=\"_blank\">Docker</a></li>\n<li><b>Unix:</b> Natively or via <a href=\"https://hub.docker.com/repository/docker/tatumio/tatum-kms\" target=\"_blank\">Docker</a></li>\n<li><b>MS Windows:</b> Only via <a href=\"https://hub.docker.com/repository/docker/tatumio/tatum-kms\" target=\"_blank\">Docker</a></li>\n</ul>\n<p>For more information about KMS, see the <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">KMS GitHub repository</a> and the <a href=\"https://docs.tatum.io/private-key-management/private-key-management\" target=\"_blank\">user documentation</a>.</p>\n</ul></p>\n",
      "name": "Key Management System"
    },
    {
      "description": "<p>An endpoint to check if the blockchain address is safe to work with or not.</p>\n",
      "name": "Malicious address"
    },
    {
      "description": "<p>Manage deposit addresses associated with your virtual account.</p>\n<p>Depending on how virtual accounts are connected to the blockchain, the virtual accounts can be:</p>\n<ul>\n<li><b>Virtual accounts with associated deposit addresses</b>\n<br/>Customers can send funds to and receive funds from other blockchain addresses.</li>\n<li><b>Virtual accounts with no deposit addresses</b>\n<br/>These accounts have a cryptocurrency assigned but do not have any associated deposit addresses. The customers can send funds to and receive funds from another virtual accounts and can send funds to blockchain addresses. However, the customers cannot receive funds from blockchain addresses.</li>\n</ul>\n",
      "name": "Blockchain addresses"
    },
    {
      "description": "<p>An endpoint to handle operations between Tatum Private Ledger and the blockchain, e.g. to create blockchain transactions from ledger accounts,\ncreate custom Ethereum ERC20 tokens, Stellar XLM, or Ripple XRP custom assets and register them as regular currency into the Tatum Private Ledger.</p>\n",
      "name": "Blockchain operations"
    },
    {
      "description": "<p>An endpoint used to create, cancel, or complete withdrawals by customers from Tatum to supported blockchains.\nWithdrawals are always multi-step operations that consist of the following steps:\n<ul>\n<li><b>create withdrawal</b></li>\n<li><b>perform blockchain transaction</b></li>\n<li><b>complete withdrawal</b></li>\n<li><b>cancel withdrawal</b>, when any of the previous operations fail</li>\n</ul>\n</p>\n",
      "name": "Withdrawals"
    },
    {
      "description": "<p>Bitcoin Blockchain enables access to the most commonly used Bitcoin methods. These methods bring a small level of abstraction\nand are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\nto connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain</li>\n<li>Testnet3 - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://testnet-faucet.mempool.co/\">https://testnet-faucet.mempool.co/</a></li></ul><br/>\n",
      "name": "Bitcoin"
    },
    {
      "description": "<p><a href=\"https://ethereum.org/\" target=\"_blank\">Ethereum</a> is a decentralized, open-source blockchain. With Tatum, you can access the most commonly used Ethereum methods. These methods bring a certain level of abstraction and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside virtual accounts to connect the blockchain and a virtual account, like generating a wallet or getting information about transactions.</p>\n<p>Tatum supports the following Ethereum networks:</p>\n<ul>\n<li><b>Mainnet</b>, the primary public production blockchain</li>\n<li><b>Sepolia</b>, a proof-of-work testnet and the default testnet for Ethereum. The testnet cryptocurrency has no value, and you can obtain it from a faucet (for example, <a target=\"_blank\" href=\"https://fauceth.komputing.org/\">FaucETH</a>).</li>\n</ul>\n",
      "name": "Ethereum"
    },
    {
      "description": "<p>IPFS is a distributed file storage. You can store data to IPFS and read from them.</p>\n",
      "name": "IPFS"
    },
    {
      "description": "<p>Bitcoin Cash Blockchain enables access to the most commonly used Bitcoin Cash methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://faucet.fullstack.cash/\">https://faucet.fullstack.cash/</a></li></ul>\n  </ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Bitcoin Cash"
    },
    {
      "description": "<p>Build a peer-to-peer NFT marketplace and allow your customers to sell and buy assets. When an asset is sold, the creator is automatically paid, the asset is instantly transferred to the buyer, and you as the owner of the marketplace automatically receive a percentage of the transaction.</p>\n<p>Each marketplace-related API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Marketplace"
    },
    {
      "description": "<p>The utility APIs help you use some native blockchain features such as getting the address of a smart contract or estimating the block number.</p>\n<p>Each utility API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Blockchain utils"
    },
    {
      "description": "<p>Litecoin Blockchain enables access to the most commonly used Litecoin methods. These methods bring a small level of abstraction and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"http://testnet.litecointools.com/\">http://testnet.litecointools.com/</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Litecoin"
    },
    {
      "description": "<p>Dogecoin Blockchain enables access to the most commonly used Dogecoin methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://testnet-faucet.com/doge-testnet/\">https://testnet-faucet.com/doge-testnet/</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Dogecoin"
    },
    {
      "description": "<p>Flow Blockchain enables access to the most commonly used Flow methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports FLOW and FUSD stable coin.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://testnet-faucet.onflow.org/\">https://testnet-faucet.onflow.org/</a>\n<br/>To obtain FUSD on testnet, you can swap them using <a target=\"_blank\" href=\"https://swap-testnet.blocto.app/#/swap\">https://swap-testnet.blocto.app/#/swap</a></li></ul>\nTo create accounts or mint NFTs on <b>mainnet</b>, you have to have paid API Key. Tatum covers the transaction fees on FLOW blockchain out of the box, so mainnet operations are available only on the paid API Key.<br/>\nTatum handles automatically proposal key management - we internally rotate the proposal keys for you, so you don't have to take care of that and can easily scale your transaction throughput.<br/>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.<br/>\nIt's not possible to pregenerate addresses on the Flow blockchain. You can generate only public keys, which are used to generate address using a create account transaction to the Flow blockchain.\nYou have to have existing account on the Flow to initialize new address creation. Transactions on the Flow blockchain are free.</p>\n",
      "name": "Flow"
    },
    {
      "description": "<p>XRP Blockchain enables access to the most commonly used XRP methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\n Examples of working with the XRP blockchain can be found in <a href=\"https://github.com/tatumio/tatum-js/tree/master/examples/xrp-example\" target=\"_blank\">Tatum XRP SDK</a>.<br/>\n Tatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain</li>\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a href=\"https://developers.ripple.com/xrp-test-net-faucet.html\" target=\"_blank\">https://developers.ripple.com/xrp-test-net-faucet.html</a>.</li></ul></p>\n<p><br/>In order to start using the XRP blockchain, we first need to create an XRP account. In XRP, the same account is used for the Mainnet and the Test chain. In order to have the account activated, it must be credited with 20 XRP. Because of this requirement, it is common to use one account for all customers and differentiate them via Destination tags, i.e. a number included in every transaction as an account distinguisher.<br/>\nWhen an off-chain deposit address is created for the ledger account, a Destination tag is generated, e.g. 12345 for that account. When a transaction to the blockchain is performed, it should contain the address of the recipient and the Destination tag as an account distinguisher.</p>\n",
      "name": "XRP"
    },
    {
      "description": "<p>XLM Blockchain enables access to the most commonly used XLM methods. These methods bring a small level of abstraction\nand are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\nto connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nExamples of working with the Stellar blockchain can be found in <a href=\"https://github.com/tatumio/tatum-js/tree/master/examples/xlm-example\" target=\"_blank\">Tatum XLM SDK</a>.<br/>\nTatum supports 2 chains:\n<ul><li> Mainnet - a regular live chain</li>\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a href=\"https://friendbot.stellar.org/?addr=address\" target=\"_blank\">https://friendbot.stellar.org/?addr=address</a>.</li></ul>\n<br/>In order to start using the XLM blockchain, we first need to create an XLM account. In order to have the account activated, it must be credited with 0.5 XLM.  Because of this requirement, it is common to use one account for all customers and differentiate them using a memo - a short text/number included in every transaction as an account distinguisher.<br/>\nWhen an off-chain deposit address is created for the ledger account, a memo is generated, e.g. 12345 for that account. When a transaction to the blockchain is performed, it should contain the address of the recipient and the memo as an account distinguisher.</p>\n",
      "name": "Stellar"
    },
    {
      "description": "<p>The Record section enables the storing of records on the blockchain. A record is stored permanently: it cannot be changed,\ndeleted, or modified by anyone and will be stored on the blockchain forever. Tatum supports storing data on the following blockchains:</p>\n<ul>\n<li>Ethereum</li>\n</ul>\n",
      "name": "Blockchain storage"
    },
    {
      "description": "<p>Binance Blockchain enables access to most commonly used Binance methods.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://www.binance.com/en/dex/testnet/address\">https://www.binance.com/en/dex/testnet/address</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "BNB Beacon Chain"
    },
    {
      "description": "<p>VeChain Blockchain enables access to the most commonly used VeChain methods. Tatum does not support off-chain capabilities for the VET blockchain.\nTatum KMS is not supported for VET transactions. VET supports 2 native assets - VET and VTHO. VTHO is used for paying transaction fees.\n<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a test chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet.vecha.in/\">https://faucet.vecha.in/</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "VeChain"
    },
    {
      "description": "<p><b>Support for Cardano is deprecated.</b></p>\n<s><p><b>Cardano is in maintenance mode.</b></p>\n<p><a href=\"https://cardano.org/\" target=\"_blank\">Cardano</a> is a decentralized, open-source blockchain. With Tatum, you can access the most commonly used Cardano methods. These methods bring a certain level of abstraction and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside virtual accounts to connect the blockchain and a virtual account, like generating a wallet or getting information about transactions.</p>\n<p>Tatum supports Cardano mainnet and <a href=\"https://docs.cardano.org/cardano-testnet/getting-started\" target=\"_blank\">Cardano preproduction testnet</a>.</p></s>\n",
      "name": "Cardano"
    },
    {
      "description": "<p>Custodial API is a set of operatinos, which allows you to work with managed blockchain addresses without having its private key.\nYou can easily create new managed address and export its details - with private key as well - once required.<br/>\nThis features are currently in <b>Alpha version</b>.</p>\n",
      "name": "Custodial managed wallets"
    },
    {
      "description": "<p>\"NFT\" stands for \"Non-Fungible Token\", which means that each token is unique and irreplaceable. NFTs are described by the ERC-721 standard on the Ethereum blockchain or by the equivalent standard on the other blockchains.</p>\n<p>NFTs can be used for nearly any digital asset or good to ensure authenticity and scarcity, for example:<p>\n<ul>\n<li><b>In-game assets:</b> NFTs can be used to create unique collectibles in the form of characters, weapons, skins, or other equipment. Players can resell or trade assets directly as they choose, and their authenticity is easily verifiable.</li>\n<li><b>Music and other digital media:</b> NFTs can be used to create rare and unique collectible digital releases. Similarly, NFTs can be used to sell videos, art, or any other type of digital media. Collectors can own digital originals of their favorite songs, movies, and so on.</li>\n<li><b>Digital sports merchandise:</b> Trading cards, memorabilia, classic moments in sports history, and one-of-a-kind experiences can be sold as NFTs.</li>\n</ul>\n<p>Each NFT-related API its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "NFT (ERC-721 or compatible)"
    },
    {
      "description": "<p>Fungible tokens are interchangeable and are used as a blockchain representation of the currency. Fungible tokens are described by the ERC-20 standard on the Ethereum blockchain or by the equivalent standard on the other blockchains.</p>\n<p>Each API related to fungible tokens supports its own set of the blockchains. The list of the supported blockchains is provided in the operation description further in this section.</p>\n",
      "name": "Fungible Tokens (ERC-20 or compatible)"
    },
    {
      "description": "<p>A Multi Token combines characteristics of fungible and non-fungible tokens. A single Multi Token smart contract allows you to mint fungible, non-fungible, and semi-fungible tokens and process different types of the tokens in a single transaction. Multi Tokens are described by the ERC-1155 standard on the Ethereum blockchain or by the equivalent standard on the other blockchains.<p/>\n<p>Multi Tokens can be used for nearly any digital asset or good to ensure authenticity and scarcity, for example:<p>\n<ul>\n<li><b>In-game assets:</b> Multi Tokens can be used to create unique collectibles in the form of characters, weapons, skins, or other equipment. Players can resell or trade assets directly as they choose, and their authenticity is easily verifiable.</li>\n<li><b>Music and other digital media:</b> Multi Tokens can be used to create rare and unique collectible digital releases. Similarly, Multi Tokens can be used to sell videos, art, or any other type of digital media. Collectors can own digital originals of their favorite songs, movies, and so on.</li>\n<li><b>Digital sports merchandise:</b> Trading cards, memorabilia, classic moments in sports history, and one-of-a-kind experiences can be sold as Multi Tokens.</li>\n</ul>\n<p>Each Multi Token-related API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Multi Tokens (ERC-1155 or compatible)"
    },
    {
      "description": "<p>Solana is a blockchain network focused on fast transactions and high throughput. It uses a unique method of ordering transactions to improve its speed. Users can pay their transaction fees and interact with smart contracts with SOL, the network's native cryptocurrency.<br/>\n<b>For now, Solana is in <b>BETA</b> and there is a rate limitation applied for all projects for Solana to 40 req/s on the platform.</b><br/>\nTatum supports 2 chains:\n<ul><li>Mainnet BETA - a regular live chain\n<li>Devnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://solfaucet.com/\">https://solfaucet.com/</a></li></ul></p>\n",
      "name": "Solana"
    },
    {
      "description": "<p>Binance Smart Chain is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://testnet.binance.org/faucet-smart\">https://testnet.binance.org/faucet-smart</a></li></ul></p>\n",
      "name": "BNB Smart Chain"
    },
    {
      "description": "<p>Polygon (Matic) is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Mumbai Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet.matic.network/\">https://faucet.matic.network/</a></li></ul></p>\n",
      "name": "Polygon"
    },
    {
      "description": "<p>Celo is fork of Celo with more than 1000 tps and possibility to pay for\ntransactions in it's own stable coin, cUSD. Celo Blockchain enables access to most commonly used Celo methods.\nThese methods bring small level of abstraction,\n       and are used for the type of applications that want to communicate with blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n       to connect blockchain and private ledger together, like wallet generation or getting information about transactions.<br/>\n      Tatum supports 2 chains:\n      <ul><li>Mainnet - regular live chain\n      <li>Alfajorec - test chain used for testing purposes. Coins on test chain have no value and can be obtained from\n      Faucet, e.g. <a target=\"_blank\" href=\"https://celo.org/developers/faucet\">https://celo.org/developers/faucet</a></li></ul><br/>\n      Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Celo"
    },
    {
      "description": "<p>Elrond (EGLD) is a distributed transactional computation protocol which relies on a sharded state architecture and a secure Proof of Stake consensus mechanism.\n<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Devnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://r3d4.fr/elrond/devnet/index.php\">https://r3d4.fr/elrond/devnet/</a></li></ul></p>\n",
      "name": "Elrond"
    },
    {
      "description": "<p>Algorand is a decentralized blockchain technology network. Algorand is enabling the simple creation of next generation financial products, protocols and exchange of value across defi, financial institutions and governments.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a></li></ul></p>\n",
      "name": "Algorand"
    },
    {
      "description": "<p>Tron Blockchain enables access to most commonly used Tron methods. It's possible to generate TRON account, send TRX, TRC10 and TRC20 assets. It's also possible to generate custom TRC10 or TRC20 tokens using API.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - regular live chain\n<li>Shasta Testnet - test chain used for testing purposes. Coins on test chain have no value and can be obtained from\nFaucet, e.g. <a target=\"_blank\" href=\"https://www.trongrid.io/shasta/\">https://www.trongrid.io/shasta/</a></li></ul>\n",
      "name": "Tron"
    },
    {
      "description": "<p>Klaytn is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Baobab Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://baobab.wallet.klaytn.com/access?next=faucet\">https://baobab.wallet.klaytn.com/access?next=faucet</a></li></ul></p>\n",
      "name": "Klaytn"
    },
    {
      "description": "<p>Harmony.ONE is an Oneeum L2 scaling solution 100% EVM compatible, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet.pops.one/\">https://faucet.pops.one/</a></li></ul></p>\n",
      "name": "Harmony"
    },
    {
      "description": "<p>XDC Network (XinFin) is enterprise ready hybrid blockchain for global trade and finance, combining the power of Public & Private blockchains with interoperable Smart Contracts.\n<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://apothem.network/#getTestXDC\">https://apothem.network/#getTestXDC</a></li></ul></p>\n",
      "name": "XinFin"
    },
    {
      "description": "<p>Kcs (KCS) is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Mumbai Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet-testnet.kcc.network/\">https://faucet-testnet.kcc.network/</a></li></ul></p>\n",
      "name": "KuCoin"
    }
  ],
  "x-tagGroups": [
    {
      "name": "Blockchain",
      "tags": [
        "Node RPC",
        "Algorand",
        "Bitcoin",
        "Bitcoin Cash",
        "BNB Smart Chain",
        "BNB Beacon Chain",
        "Cardano",
        "Celo",
        "Dogecoin",
        "Elrond",
        "Ethereum",
        "Flow",
        "Harmony",
        "Klaytn",
        "KuCoin",
        "Litecoin",
        "Polygon",
        "Solana",
        "Stellar",
        "Tron",
        "VeChain",
        "XinFin",
        "XRP"
      ]
    },
    { "name": "Subscriptions", "tags": ["Notification subscriptions"] },
    { "name": "Fee estimation", "tags": ["Blockchain fees", "Virtual account blockchain fees"] },
    {
      "name": "Smart Contracts",
      "tags": [
        "NFT (ERC-721 or compatible)",
        "Fungible Tokens (ERC-20 or compatible)",
        "Multi Tokens (ERC-1155 or compatible)",
        "Gas pump",
        "Marketplace",
        "Auction"
      ]
    },
    {
      "name": "Security",
      "tags": ["Key Management System", "Malicious address", "Custodial managed wallets"]
    },
    { "name": "Storage", "tags": ["IPFS", "Blockchain storage"] },
    {
      "name": "Virtual Accounts",
      "tags": [
        "Account",
        "Transaction",
        "Customer",
        "Virtual Currency",
        "Order Book",
        "Withdrawal",
        "Blockchain addresses",
        "Blockchain operations",
        "Deposit"
      ]
    },
    { "name": "Utils", "tags": ["Blockchain utils", "Exchange rate", "Service utils"] }
  ],
  "paths": {
    "/v3/ledger/account": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Create a new virtual account for a customer.</p>\n<ul>\n<li>If the customer that you specified in the request body already exists, the newly created virtual account is added to this customer's list of accounts.</li>\n<li>If the customer that you specified in the request body does not exist yet, a new customer is created together with the virtual account, and the virtual account is added to this customer.</li>\n</ul>\n<p>You can create a virtual account for any supported cryptocurrency, fiat currency, Tatum virtual currency, or fungible tokens created within Tatum. Once the currency/asset is set for a virtual account, it cannot be changed.</p>\n<p><b>Virtual account balance</b></p>\n<p>A virtual account has its own balance. The balance can be logically presented by the account balance and available balance:</p>\n<ul>\n<li>The <b>account balance</b> (<code>accountBalance</code>) represents all assets on the account, both available and blocked.</li>\n<li>The <b>available balance</b> (<code>availableBalance</code>) represents the account balance minus the blocked assets. Use the available balance to determine how much a customer can send or withdraw from their virtual account.</li>\n</ul>\n<p><b>Cryptocurrency virtual accounts</b></p>\n<p>When you create a virtual account based on a cryptocurrency (for example, BTC or ETH), you have to provide the extended public key (<code>xpub</code>) of the blockchain wallet that will be connected to this account.</p>\n<p><b>NOTE:</b> Adding <code>xpub</code> to the virtual account does <b>not</b> connect any specific blockchain address to this account. <code>xpub</code> is a generator of addresses, not an address itself.</p>\n<p>Not all blockchains provide <code>xpub</code> for wallets, or Tatum may not support wallets on some blockchains. In such cases, use the wallet address or the account address instead.</p>\n<ul>\n<li><b>ALGO:</b> No <code>xpub</code> provided; use <code>address</code> from the <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandGenerateWallet\" target=\"_blank\">generated wallet</a> instead.</li>\n<li><b>BCH:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Bitcoin-Cash#operation/BchGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>BNB:</b> No <code>xpub</code> provided; use <code>address</code> from the <a href=\"https://apidoc.tatum.io/tag/BNB-Beacon-Chain#operation/BnbGenerateWallet\" target=\"_blank\">generated wallet</a> instead.</li>\n<li><b>BSC:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/BNB-Smart-Chain#operation/BscGenerateWallet\" target=\"_blank\">generated wallet</a> instead.</li>\n<li><b>BTC:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Bitcoin#operation/BtcGenerateWallet\" target=\"_blank\">generated wallet</a> instead.</li>\n<li><b>CELO:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Celo#operation/CeloGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>DOGE:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Dogecoin#operation/DogeGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>EGLD:</b> No <code>xpub</code> provided; use <code>address</code> from the <a href=\"https://apidoc.tatum.io/tag/Elrond#operation/EgldGenerateAddress\" target=\"_blank\">generated blockchain address</a> instead.<br />Blockchain addresses on Elrond are generated based on the mnemonic of an Elrond wallet. If you do not have an Elrond wallet, <a href=\"https://apidoc.tatum.io/tag/Elrond/#operation/EgldGenerateWallet\" target=\"_blank\">create one</a>.</li>\n<li><b>ETH:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Ethereum#operation/EthGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>FLOW:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Flow#operation/FlowGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>KCS:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/KuCoin#operation/KcsGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>KLAY:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Klaytn#operation/KlaytnGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>LTC:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Litecoin#operation/LtcGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>MATIC:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Polygon#operation/PolygonGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>SOL:</b> No <code>xpub</code> provided; use <code>address</code> from the <a href=\"https://apidoc.tatum.io/tag/Solana#operation/SolanaGenerateWallet\" target=\"_blank\">generated wallet</a> instead.</li>\n<li><b>TRON:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/Tron#operation/GenerateTronwallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>XDC:</b> Obtain <code>xpub</code> from the <a href=\"https://apidoc.tatum.io/tag/XinFin#operation/XdcGenerateWallet\" target=\"_blank\">generated wallet</a>.</li>\n<li><b>XLM:</b> No <code>xpub</code> provided; use <code>address</code> from the <a href=\"https://apidoc.tatum.io/tag/Stellar#operation/XlmWallet\" target=\"_blank\">generated account</a> instead.</li>\n<li><b>XRP:</b> No <code>xpub</code> provided; use <code>address</code> from the <a href=\"https://apidoc.tatum.io/tag/XRP#operation/XrpWallet\" target=\"_blank\">generated account</a> instead.</li>\n</ul>\n<p><b>Connect a virtual account to the blockchain</b></p>\n<ul>\n<li>If the virtual account was created with the wallet's <code>xpub</code>, <a href=\"https://apidoc.tatum.io/tag/Blockchain-addresses#operation/generateDepositAddress\" target=\"_blank\">generate a new blockchain address</a> for this account.</li>\n<li>If the virtual account was created with the wallet's or account's address instead of the wallet's <code>xpub</code>, <a href=\"https://apidoc.tatum.io/tag/Blockchain-addresses#operation/assignAddress\" target=\"_blank\">assign an existing blockchain address</a> to this account.</li>\n</ul>\n<p>You can connect multiple blockchain addresses to one virtual account.</p>\n",
        "operationId": "createAccount",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CreateAccountXpub" },
                  { "$ref": "#/components/schemas/CreateAccount" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Account" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403ComplianceBtc" },
                    { "$ref": "#/components/schemas/Error403ComplianceEth" },
                    { "$ref": "#/components/schemas/Error403AccountTestnet" },
                    { "$ref": "#/components/schemas/Error403AccountXpub" },
                    { "$ref": "#/components/schemas/Error403AccountCurrency" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpub" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403CustomerNotExists" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create a virtual account",
        "tags": ["Account"]
      },
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Lists all accounts. Inactive accounts are also visible.</p>",
        "operationId": "getAccounts",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 20, "maximum": 50, "minimum": 1 },
            "required": false
          },
          {
            "description": "Page number",
            "in": "query",
            "name": "page",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Direction of sorting. Can be asc or desc",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "enum": ["asc", "desc"], "example": "asc" }
          },
          {
            "description": "Sort by",
            "in": "query",
            "name": "sortBy",
            "schema": {
              "type": "string",
              "example": "_id",
              "enum": ["_id", "account_number", "account_balance", "available_balance"]
            }
          },
          {
            "description": "Filter only active or non active accounts",
            "in": "query",
            "name": "active",
            "schema": { "type": "boolean", "example": true }
          },
          {
            "description": "Filter only accounts with non zero balances",
            "in": "query",
            "name": "onlyNonZeroBalance",
            "schema": { "type": "boolean", "example": true }
          },
          {
            "description": "Filter only frozen or non frozen accounts",
            "in": "query",
            "name": "frozen",
            "schema": { "type": "boolean", "example": true }
          },
          {
            "description": "Filter by currency",
            "in": "query",
            "name": "currency",
            "schema": { "type": "string", "example": "BTC" }
          },
          {
            "description": "Filter by account number",
            "in": "query",
            "name": "accountNumber",
            "schema": { "maxLength": 50, "example": "AC_1011_B", "minLength": 1, "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Account" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all accounts",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/count": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Count of accounts that were found from /v3/ledger/account</p>",
        "operationId": "getAccountsCount",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 20, "maximum": 50, "minimum": 1 },
            "required": false
          },
          {
            "description": "Page number",
            "in": "query",
            "name": "page",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Direction of sorting. Can be asc or desc",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "enum": ["asc", "desc"] }
          },
          {
            "description": "Sort by",
            "in": "query",
            "name": "sortBy",
            "schema": {
              "type": "string",
              "example": "_id",
              "enum": ["_id", "account_number", "account_balance", "available_balance"]
            }
          },
          {
            "description": "Filter only active or non active accounts",
            "in": "query",
            "name": "active",
            "schema": { "type": "boolean", "example": true }
          },
          {
            "description": "Filter only accounts with non zero balances",
            "in": "query",
            "name": "onlyNonZeroBalance",
            "schema": { "type": "boolean", "example": true }
          },
          {
            "description": "Filter only frozen or non frozen accounts",
            "in": "query",
            "name": "frozen",
            "schema": { "type": "boolean", "example": true }
          },
          {
            "description": "Filter by currency",
            "in": "query",
            "name": "currency",
            "schema": { "type": "string", "example": "BTC" }
          },
          {
            "description": "Filter by account number",
            "in": "query",
            "name": "accountNumber",
            "schema": { "maxLength": 50, "example": "AC_1011_B", "minLength": 1, "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EntitiesCount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Count of found entities for get accounts request",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/batch": {
      "post": {
        "description": "<h4>2 credits per API call + 1 credit for every account created.</h4><br/>\n<p>Creates new accounts for the customer in a batch call.</p>\n",
        "operationId": "createAccountBatch",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/CreateAccountBatch" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/Account" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403ComplianceBtc" },
                    { "$ref": "#/components/schemas/Error403ComplianceEth" },
                    { "$ref": "#/components/schemas/Error403AccountTestnet" },
                    { "$ref": "#/components/schemas/Error403AccountXpub" },
                    { "$ref": "#/components/schemas/Error403AccountCurrency" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpub" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403CustomerNotExists" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create multiple accounts in a batch call",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/customer/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Lists all accounts associated with a customer. Only active accounts are visible.</p>",
        "operationId": "getAccountsByCustomerId",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Internal customer ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "example": "5e68c66581f2ee32bc354087", "type": "string" }
          },
          {
            "description": "For bookkeeping to distinct account purpose.",
            "in": "query",
            "name": "accountCode",
            "schema": { "maxLength": 50, "example": "AC_1011_B", "minLength": 1, "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Account" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all customer accounts",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets active account by ID. Displays all information regarding the given account.</p>",
        "operationId": "getAccountByAccountId",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Account" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403AccountNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get account by ID",
        "tags": ["Account"]
      },
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Update account by ID. Only a small number of fields can be updated.</p>",
        "operationId": "updateAccountByAccountId",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/UpdateAccount" } } },
          "required": true
        },
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403AccountNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/{id}/balance": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get balance for the account.</p>",
        "operationId": "getAccountBalance",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/AccountBalance" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403AccountNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get account balance",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/block/{id}": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Blocks an amount in an account. Any number of distinct amounts can be blocked in one account.\nEvery new blockage has its own distinct ID, which is used as a reference. When the amount is blocked, it is debited from the available balance of the account.\nThe account balance remains the same. The account balance represents the total amount of funds in the account. The available balance represents the total amount of funds that can be used to perform transactions. When an account is frozen, the available balance is set to 0 minus all blockages for the account.</p>\n",
        "operationId": "blockAmount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e6be89ee6aa436299950c3f" }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BlockAmount" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Id" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403CustomerNotExists" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Block an amount in an account",
        "tags": ["Account"]
      },
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Unblocks a previously blocked amount in an account and invokes a ledger transaction from that account to a different recipient.\nIf the request fails, the amount is not unblocked.</p>\n",
        "operationId": "unblockAmountWithTransaction",
        "parameters": [
          {
            "description": "Blockage ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e6be89ee6aa436299950c3f" }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/UnblockAmount" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionResult" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BlockageNotExists" },
                    { "$ref": "#/components/schemas/Error403BlockageAmount" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403ComplianceBtc" },
                    { "$ref": "#/components/schemas/Error403ComplianceEth" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxRecipientNotFound" },
                    { "$ref": "#/components/schemas/Error403TxCurrency" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxNotCompliant" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Unblock an amount in an account and perform a transaction",
        "tags": ["Account"]
      },
      "delete": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Unblocks a previously blocked amount in an account. Increases the available balance in the account where the amount was blocked.</p>",
        "operationId": "deleteBlockAmount",
        "parameters": [
          {
            "description": "Blockage ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e6be89ee6aa436299950c3f" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Unblock a blocked amount in an account",
        "tags": ["Account"]
      },
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets blocked amounts for an account.</p>",
        "operationId": "getBlockAmount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e6be89ee6aa436299950c3f" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/Blockage" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get blocked amounts in an account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/block/{id}/detail": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets blocked amount by id.</p>",
        "operationId": "getBlockAmountById",
        "parameters": [
          {
            "description": "Blocked amount ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e6be89ee6aa436299950c3f" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Blockage" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get blocked amount by ID",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/block/account/{id}": {
      "delete": {
        "description": "<h4>1 credit per API call, 1 credit for each deleted blockage. 1 API call + 2 blockages  = 3 credits.</h4><br/><p>Unblocks previously blocked amounts in an account. Increases the available balance in the account where the amount was blocked.</p>",
        "operationId": "deleteAllBlockAmount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e6be89ee6aa436299950c3f" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403CustomerNotExists" },
                    { "$ref": "#/components/schemas/Error403BlockDelete" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Unblock all blocked amounts in an account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/{id}/activate": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Activates an account.</p>",
        "operationId": "activateAccount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due a to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AccountActive" },
                    { "$ref": "#/components/schemas/Error403CustomerNotExists" },
                    { "$ref": "#/components/schemas/Error403AccountCustomerInactive" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Activate account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/{id}/deactivate": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Deactivates an account. Only accounts with account and available balances of zero can be deactivated. Deactivated accounts are not visible in the list of accounts, it is not possible to send funds to these accounts or perform transactions. However, they are still present in the ledger and all transaction histories.</p>",
        "operationId": "deactivateAccount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AccountInactive" },
                    { "$ref": "#/components/schemas/Error403AccountBalanceNonZero" },
                    { "$ref": "#/components/schemas/Error403TradeBalanceNonZero" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deactivate account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/{id}/freeze": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Disables all outgoing transactions. Incoming transactions to the account are available. When an account is frozen, its available balance is set to 0. This operation will create a new blockage of type ACCOUNT_FROZEN, which is automatically deleted when the account is unfrozen.</p>",
        "operationId": "freezeAccount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AccountFrozen" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Freeze account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/account/{id}/unfreeze": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Unfreezes a previously frozen account. Unfreezing a non-frozen account not affect the account.</p>",
        "operationId": "unfreezeAccount",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AccountNotFrozen" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Unfreeze account",
        "tags": ["Account"]
      }
    },
    "/v3/ledger/transaction": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Sends a payment within Tatum Private Ledger. All assets are settled instantly.<br/>\nWhen a transaction is settled, 2 transaction records are created, 1 for each of the participants. These 2 records are connected via a transaction reference, which is the same for both of them.<br/>\nThis method is only used for transferring assets between accounts within Tatum and will not send any funds to blockchain addresses.<br/>\nIf there is an insufficient balance in the sender account, no transaction is recorded.<br/>\nIt is possible to perform an anonymous transaction where the sender account is not visible for the recipient.<br/>\nThe FIAT currency value of every transaction is calculated automatically. The FIAT value is based on the accountingCurrency of the account connected to the transaction and is available in the marketValue parameter of the transaction.</p>\n",
        "operationId": "sendTransaction",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/CreateTransaction" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionResult" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403ComplianceBtc" },
                    { "$ref": "#/components/schemas/Error403ComplianceEth" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxRecipientNotFound" },
                    { "$ref": "#/components/schemas/Error403TxCurrency" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxNotCompliant" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send payment",
        "tags": ["Transaction"]
      }
    },
    "/v3/ledger/transaction/batch": {
      "post": {
        "description": "<h4>2 + 2 * N per API call. (N - count of transactions)</h4><br/>\n<p>Sends the N payments within Tatum Private Ledger. All assets are settled instantly.<br/>\nWhen a transaction is settled, 2 transaction records are created, 1 for each of the participants. These 2 records are connected via a transaction reference, which is the same for both of them.<br/>\nThis method is only used for transferring assets between accounts within Tatum and will not send any funds to blockchain addresses.<br/>\nIf there is an insufficient balance in the sender account, no transaction is recorded.<br/>\nIt is possible to perform an anonymous transaction where the sender account is not visible for the recipient.<br/>\nThe FIAT currency value of every transaction is calculated automatically. The FIAT value is based on the accountingCurrency of the account connected to the transaction and is available in the marketValue parameter of the transaction.</p>\n",
        "operationId": "sendTransactionBatch",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/BatchCreateTransaction" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/BatchTransactionResult" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403ComplianceBtc" },
                    { "$ref": "#/components/schemas/Error403ComplianceEth" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxRecipientNotFound" },
                    { "$ref": "#/components/schemas/Error403TxCurrency" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxNotCompliant" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send payment in batch",
        "tags": ["Transaction"]
      }
    },
    "/v3/ledger/transaction/account": {
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Finds transactions for the account identified by the given account ID.</p>",
        "operationId": "getTransactionsByAccountId",
        "parameters": [
          {
            "description": "Max number of items per page is 50. Either count or pageSize is accepted.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 }
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Get the total transaction count based on the filter. Either count or pageSize is accepted.",
            "in": "query",
            "name": "count",
            "example": true,
            "schema": { "type": "boolean" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/TransactionFilter" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "items": { "$ref": "#/components/schemas/Transaction" }, "type": "array" },
                    { "type": "number", "description": "Total transaction count.", "example": 20 }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Find transactions for account.",
        "tags": ["Transaction"]
      }
    },
    "/v3/ledger/transaction/customer": {
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Finds transactions for all accounts of the customer identified by the given internal customer ID.</p>",
        "operationId": "getTransactionsByCustomerId",
        "parameters": [
          {
            "description": "Max number of items per page is 50. Either count or pageSize is accepted.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 }
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Get total transaction count based on the filter. Either count or pageSize is accepted.",
            "in": "query",
            "name": "count",
            "example": true,
            "schema": { "type": "boolean" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/TransactionFilterCustomer" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "items": { "$ref": "#/components/schemas/Transaction" }, "type": "array" },
                    { "type": "number", "description": "Total transaction count.", "example": 20 }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Find transactions for a customer across all of the customer's accounts.",
        "tags": ["Transaction"]
      }
    },
    "/v3/ledger/transaction/ledger": {
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Find transactions across whole ledger.</p>",
        "operationId": "getTransactions",
        "parameters": [
          {
            "description": "Max number of items per page is 50. Either count or pageSize is accepted.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 }
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Get the total transaction count based on the filter. Either count or pageSize is accepted.",
            "in": "query",
            "name": "count",
            "example": true,
            "schema": { "type": "boolean" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/TransactionFilterLedger" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "items": { "$ref": "#/components/schemas/Transaction" }, "type": "array" },
                    { "type": "number", "description": "Total transaction count.", "example": 20 }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Find transactions within the ledger.",
        "tags": ["Transaction"]
      }
    },
    "/v3/ledger/transaction/reference/{reference}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Finds transactions for all accounts with the given reference.</p>",
        "operationId": "getTransactionsByReference",
        "parameters": [
          {
            "in": "path",
            "name": "reference",
            "required": true,
            "schema": { "maxLength": 100, "minLength": 20, "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Transaction" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Find transactions with a given reference across all accounts.",
        "tags": ["Transaction"]
      }
    },
    "/v3/ledger/deposits": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Lists all deposits for API key.</p>",
        "operationId": "getDeposits",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 20, "maximum": 50, "minimum": 1 },
            "required": false
          },
          {
            "description": "Page number",
            "in": "query",
            "name": "page",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Direction of sorting. Can be asc or desc",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "enum": ["asc", "desc"], "example": "asc" }
          },
          {
            "description": "Status of the deposit",
            "in": "query",
            "name": "status",
            "schema": { "type": "string", "enum": ["Done", "InProgress"], "example": "Done" }
          },
          {
            "description": "Filter by currency",
            "name": "currency",
            "in": "query",
            "schema": { "type": "string", "example": "BTC" }
          },
          {
            "description": "Filter by txId",
            "name": "txId",
            "in": "query",
            "schema": { "type": "string", "example": 2.0589336591536965e76, "maxLength": 80, "minLength": 10 }
          },
          {
            "description": "Filter by to address",
            "name": "to",
            "in": "query",
            "schema": { "type": "string", "example": 9.557027372635822e47 }
          },
          {
            "description": "Filter by account id",
            "name": "accountId",
            "in": "query",
            "schema": { "type": "string", "example": "628bae6095e9ad06b52eb229" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Deposit" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all deposits for product",
        "tags": ["Deposit"]
      }
    },
    "/v3/ledger/deposits/count": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Counts total entities found by get deposits request.</p>",
        "operationId": "getDepositsCount",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 20, "maximum": 50, "minimum": 1 },
            "required": false
          },
          {
            "description": "Page number",
            "in": "query",
            "name": "page",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Direction of sorting. Can be asc or desc",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "enum": ["asc", "desc"], "example": "asc" }
          },
          {
            "description": "Type of the deposit",
            "in": "query",
            "name": "status",
            "schema": { "type": "string", "enum": ["Done", "InProgress"], "example": "Done" }
          },
          {
            "description": "Filter by currency",
            "name": "currency",
            "in": "query",
            "schema": { "type": "string", "example": "BTC" }
          },
          {
            "description": "Filter by txId",
            "name": "txId",
            "in": "query",
            "schema": { "type": "string", "example": 2.0589336591536965e76, "maxLength": 80, "minLength": 10 }
          },
          {
            "description": "Filter by to address",
            "name": "to",
            "in": "query",
            "schema": { "type": "string", "example": 9.557027372635822e47 }
          },
          {
            "description": "Filter by account id",
            "name": "accountId",
            "in": "query",
            "schema": { "type": "string", "example": "628bae6095e9ad06b52eb229" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EntitiesCount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Count of found entities for get deposits request",
        "tags": ["Deposit"]
      }
    },
    "/v3/record": {
      "post": {
        "description": "<h4>2 credits per API call. Additional credits are debited based on the size of the stored data and the type of blockchain.</h4><br/>\n<p>Stores record data on blockchain. Tatum currently supports the Ethereum, CELO, MATIC, ONE, XDC, BSC, KLAY and EGLD to store data.<br/>\nThe total cost of the transaction (in credits) on the Ethereum blockchain is dependent on the size of the data. Data are stored as a HEX string and the maximum data size is approximatelly 130 kB on mainnet, 30 kB on testnet.<br/>\nEvery 5 characters of data costs 1 credit, so an API call with a data of length 1 kB = 1024 characters and would cost 205 credits.\n</p>\n",
        "operationId": "StoreLog",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CreateRecord" },
                  { "$ref": "#/components/schemas/CreateRecordCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Store log record",
        "tags": ["Blockchain storage"]
      },
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets log data from the Ethereum blockchain.</p>",
        "operationId": "GetLog",
        "parameters": [
          {
            "description": "The blockchain to get the log record from",
            "in": "query",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "example": "ETH", "enum": ["ETH"] }
          },
          {
            "description": "ID of the log record / transaction on the blockchain",
            "in": "query",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326",
              "minLength": 1,
              "maxLength": 100
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["data"],
                  "properties": {
                    "data": {
                      "type": "string",
                      "description": "Data stored in the record.",
                      "example": "My log record data."
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get log record",
        "tags": ["Blockchain storage"]
      }
    },
    "/v3/ipfs/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets data from the IPFS.</p>",
        "operationId": "GetIPFSData",
        "parameters": [
          {
            "description": "IPFS CID of the file",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj" }
          }
        ],
        "responses": {
          "200": {
            "content": { "*": { "schema": { "type": "string", "format": "binary" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get file from IPFS",
        "tags": ["IPFS"]
      }
    },
    "/v3/ipfs": {
      "post": {
        "description": "<h4>2 credits per API call. Only files up to 50MB are available for storing.</h4><br/>\n<p>Stores file on the IPFS. We are leveraging <a href=\"https://nft.storage/\" target=\"_blank\">nft.storage</a> from <a href=\"https://protocol.ai/\" target=\"_blank\">Protocol Labs</a> for free storage on the IPFS.</p>\n",
        "operationId": "StoreIPFS",
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary",
                    "example": 127654187631872620,
                    "description": "Your file to store"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "ipfsHash": { "type": "string", "description": "IPFS CID identifier of the stored file." }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Store data to IPFS",
        "tags": ["IPFS"]
      }
    },
    "/v3/bitcoin/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m'/44'/0'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Bitcoin wallet.</p>\n",
        "operationId": "BtcGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate a Bitcoin wallet",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.</p>\n",
        "operationId": "BtcGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of a wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of the desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number", "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/GeneratedAddressBtc" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate a Bitcoin address from the wallet's extended public key",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "BtcGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate the private key for a Bitcoin address",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/info": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.</p>\n",
        "operationId": "BtcGetBlockChainInfo",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BtcInfo" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Bitcoin blockchain information",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/block/hash/{i}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Gets a Bitcoin block hash. Returns the hash of the block to get the block's details.</p>\n",
        "operationId": "BtcGetBlockHash",
        "parameters": [
          {
            "description": "The number of blocks preceding a particular block on a blockchain.",
            "in": "path",
            "name": "i",
            "required": true,
            "schema": { "type": "number", "example": 1580117 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BtcBlockHash" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the hash of a Bitcoin block",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Gets Bitcoin block detail by block hash or height.</p>\n",
        "operationId": "BtcGetBlock",
        "parameters": [
          {
            "description": "Block hash or height.",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "00000000ca231a439a5c0a86a5a5dd6dc1918a8e897b96522fa9499288e70183"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BtcBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Block not found.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error404BlockNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get a Bitcoin block by its hash or height",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/address/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the balance of a Bitcoin address.</p>\n",
        "operationId": "BtcGetBalanceOfAddress",
        "parameters": [
          {
            "description": "The blockchain address to get the balance for",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "2MsM67NLa71fHvTUBqNENW15P68nHB2vVXb" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/BtcBasedBalance" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the balance of a Bitcoin address",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/transaction/address/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get all transactions for a Bitcoin address.</p>\n",
        "operationId": "BtcGetTxByAddress",
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "2MsM67NLa71fHvTUBqNENW15P68nHB2vVXb" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/BtcTx" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get all transactions for a Bitcoin address",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send BTC to blockchain addresses.</p>\n<p>Bitcoin transactions are based on UTXOs. \"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>. To check UTXOs in a transaction, see the <a href=\"#operation/BtcGetUTXO\">API for getting information about a transaction output (UTXO) in a Bitcoin transaction</a>.</p>\n<p>You can build a BTC transaction by one of the following methods:</p>\n<ul>\n<li><b>Sending BTC from blockchain addresses</b><br/>The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from.<br/> To use this method, use the <code>BtcTransactionFromAddress</code> or <code>BtcTransactionFromAddressKMS</code> schema of the request body.</li>\n<li><b>Sending BTC from UTXOs</b><br/>The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send.<br/> To use this method, use the <code>BtcTransactionFromUTXO</code> or <code>BtcTransactionFromUTXOKMS</code> schema of the request body.</li>\n</ul>\n<p>When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend:<br/><code>1 BTC (from T1) + 2 BTC (from T2) = 3 BTC (to spend in total)</code></p>\n<p>You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive.</p>\n<p><b>Paying the gas fee and receiving the change</b><br/>\nWhen the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the <code>fee</code> and <code>changeAddress</code> parameters in the request body, correspondingly).</p>\n<p><b>Signing a transaction</b><br/>\nWhen sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BtcTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BtcTransactionFromAddress" },
                  { "$ref": "#/components/schemas/BtcTransactionFromAddressKMS" },
                  { "$ref": "#/components/schemas/BtcTransactionFromUTXO" },
                  { "$ref": "#/components/schemas/BtcTransactionFromUTXOKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BTC to Bitcoin addresses",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/transaction/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Bitcoin Transaction detail by transaction hash.</p>\n",
        "operationId": "BtcGetRawTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "1451692ebbfbea1a2d2ec6fe6782596b6aa2e46c0589d04c406f491b5b46bc6a"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BtcTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403TxNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get a Bitcoin transaction by its hash",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/utxo/{hash}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent.</p>\n<p>\"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>.</p>\n<ul>\n<li>If the transaction output is an UTXO, the API returns data about it.</li>\n<li>If the transaction output has been spent and there is no UTXO to return, the API returns an error with the <code>404</code> response code.</li>\n</ul>\n",
        "operationId": "BtcGetUTXO",
        "parameters": [
          {
            "description": "The transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 64,
              "maxLength": 64,
              "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc"
            }
          },
          {
            "description": "The index of the transaction output that you want to check for the UTXO",
            "in": "path",
            "name": "index",
            "required": true,
            "schema": { "type": "number", "example": 0, "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BtcUTXO" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcUTXO" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get information about a transaction output (UTXO) in a Bitcoin transaction",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/mempool": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Gets Bitcoin transaction IDs in the mempool.</p>\n",
        "operationId": "BtcGetMempool",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "TX ID of the transaction in mempool",
                    "example": "4c7846a8ff8415945e96937dea27bdb3144c15d793648d725602784826052586"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403BtcBlockchain" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get transactions from the Bitcoin mempool",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries.\nIt is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.</p>\n",
        "operationId": "BtcBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast a signed Bitcoin transaction",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/bitcoin/node": {
      "post": {
        "description": "<p>This endpoint is deprecated. Do not use it.<br/>\nInstead, use <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">this API</a>.</b></p><br/>\n<p><b>2 credits per API call</b></p>\n<p>Use this endpoint URL as an http-based JSON RPC driver to connect directly to the node provided by Tatum.\nTo learn more about JSON RPC, visit the <a href=\"https://developer.bitcoin.org/reference/rpc/index.html\" target=\"_blank\">Bitcoin developers' guide</a>.</p>\n",
        "deprecated": true,
        "operationId": "BtcRpcDriver",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid JSON RPC method content body.",
                "properties": {
                  "jsonrpc": {
                    "type": "string",
                    "description": "Version of the JSON RPC.",
                    "example": "1.0"
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the request, could be any arbitrary identifier.",
                    "example": "test"
                  },
                  "method": {
                    "type": "string",
                    "description": "Method to invoke on the node.",
                    "example": "getblockcount"
                  },
                  "params": {
                    "type": "array",
                    "description": "Params to the method call, if required.",
                    "example": [],
                    "items": { "type": "object" }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid RPC response.",
                  "example": { "jsonrpc": "1.0", "id": "test", "result": 654321 }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Connect to a Bitcoin node through an RPC driver",
        "tags": ["Bitcoin"]
      }
    },
    "/v3/blockchain/estimate": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Estimate current transaction fee for different operations.<br/>\nSupported blockchains:\n<ul>\n<li>Bitcoin</li>\n<li>Litecoin</li>\n<li>Harmony.ONE</li>\n<li>The XDC Network</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Klaytn</li>\n<li>Binance Smart Chain</li>\n<li>Polygon</li>\n</ul>\n</p>\n",
        "operationId": "EstimateFeeBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/EstimateFee" },
                  { "$ref": "#/components/schemas/EstimateFeeBatchMintNft" },
                  { "$ref": "#/components/schemas/EstimateFeeDeployCustodialWallet" },
                  { "$ref": "#/components/schemas/EstimateFeeTransferFromCustodial" },
                  { "$ref": "#/components/schemas/EstimateFeeFromAddress" },
                  { "$ref": "#/components/schemas/EstimateFeeFromUTXO" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "headers": {
              "x-current-block": {
                "schema": { "type": "number", "example": 15632152 },
                "description": "Current block of the blockchain."
              },
              "x-current-block-time": {
                "schema": { "type": "string", "format": "date-time", "example": "2021-11-11T11:54:49.000Z" },
                "description": "Current block time."
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/FeeBtc" },
                    { "$ref": "#/components/schemas/FeeETH" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate the fee for a transaction",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/ethereum/gas": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the Ethereum transaction. Gas price is obtained from multiple sources + calculated based on the latest N blocks and the current mempool state. The <b>fast</b> one is used by default.\n</p>\n",
        "operationId": "EthEstimateGas",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthEstimateGas" } } },
          "required": true
        },
        "responses": {
          "200": {
            "headers": {
              "x-current-block": {
                "schema": { "type": "number" },
                "description": "Current block of the blockchain."
              },
              "x-current-block-time": {
                "schema": { "type": "string", "format": "date-time", "example": "2021-11-11T11:54:49.000Z" },
                "description": "Current block time."
              }
            },
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/EthGasEstimation" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate Ethereum transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/ethereum/gas/batch": {
      "post": {
        "description": "<h4>10 credits per API call + 10 credits per each gas estimation.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the Ethereum transaction. Gas price is obtained from multiple sources + calculated based on the latest N blocks and the current mempool state.\nThe <b>fast</b> one is used by default.<br/>\nResult is calculated  in the order of the request array items.\n</p>\n",
        "operationId": "EthEstimateGasBatch",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/EthEstimateGasArray" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "headers": {
              "x-current-block": {
                "schema": { "type": "number" },
                "description": "Current block of the blockchain."
              },
              "x-current-block-time": {
                "schema": { "type": "string", "format": "date-time", "example": "2021-11-11T11:54:49.000Z" },
                "description": "Current block time."
              }
            },
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/EthGasEstimationBatch" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate multiple Ethereum transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/polygon/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the Polygon transaction. Gas price is obtained from <a href=\"https://gasstation-mainnet.matic.network/\" target=\"_blank\">https://gasstation-mainnet.matic.network/</a>.\n</p>\n",
        "operationId": "PolygonEstimateGas",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/PolygonEstimateGas" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "string",
                      "description": "Gas limit for transaction in gas price.",
                      "example": "40000"
                    },
                    "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "20" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403PolygonTxBody" },
                    { "$ref": "#/components/schemas/Error403PolygonGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate Polygon transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/celo/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the CELO transaction. Gas price is obtained from <a href=\"https://explorer.bitquery.io/celo_rc1/gas\" target=\"_blank\">https://explorer.bitquery.io/celo_rc1/gas</a>.\n</p>\n",
        "operationId": "CeloEstimateGas",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CeloEstimateGas" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "number",
                      "description": "Gas limit for transaction in gas price.",
                      "example": 40000
                    },
                    "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "20" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403CeloTxBody" },
                    { "$ref": "#/components/schemas/Error403CeloGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate Celo Chain transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/bsc/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the BSC transaction. Gas price is obtained from <a href=\"https://explorer.bitquery.io/bsc/gas\" target=\"_blank\">https://explorer.bitquery.io/bsc/gas</a>.\n</p>\n",
        "operationId": "BscEstimateGas",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BscEstimateGas" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "string",
                      "description": "Gas limit for transaction in gas price.",
                      "example": "40000"
                    },
                    "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "20" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BscTxBody" },
                    { "$ref": "#/components/schemas/Error403BscGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate BNB Smart Chain transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/klaytn/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the Klaytn transaction. Gas price is obtained from <a href=\"https://explorer.bitquery.io/klaytn/gas\" target=\"_blank\">https://explorer.bitquery.io/klaytn/gas</a>.\n</p>\n",
        "operationId": "KlaytnEstimateGas",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/KlaytnEstimateGas" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "string",
                      "description": "Gas limit for transaction in gas price.",
                      "example": "40000"
                    },
                    "gasPrice": { "type": "string", "description": "Gas price in peb.", "example": "20" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KlaytnTxBody" },
                    { "$ref": "#/components/schemas/Error403KlaytnGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate Klaytn transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/xdc/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the XDC transaction. Gas price is obtained from <a href=\"https://rpc.xinfin.network/gasPrice\" target=\"_blank\">https://rpc.xinfin.network/gasPrice</a>.\n</p>\n",
        "operationId": "XdcEstimateGas",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XdcEstimateGas" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "string",
                      "description": "Gas limit for transaction in gas price.",
                      "example": "40000"
                    },
                    "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "5" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403XdcGasCalculation" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate XinFin transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/kcs/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the Kcs transaction.\n</p>\n",
        "operationId": "KcsEstimateGas",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/KcsEstimateGas" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "string",
                      "description": "Gas limit for transaction in gas price.",
                      "example": "40000"
                    },
                    "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "20" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KcsTxBody" },
                    { "$ref": "#/components/schemas/Error403KcsGasCalculation" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate KuCoin Community Chain transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/vet/transaction/gas": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Estimate gas required for transaction.</p>",
        "operationId": "VetEstimateGas",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VetEstimateGas" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "type": "number", "example": 21000 } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate VeChain Gas for transaction",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/egld/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the EGLD transaction. Gas limit is obtained from <a href=\"https://gateway.elrond.com/transaction/cost\" target=\"_blank\">https://gateway.elrond.com/transaction/cost</a>.\nGas price is obtained from <a href=\"https://gateway.elrond.com/network/config\" target=\"_blank\">https://gateway.elrond.com/network/config</a>.\n</p>\n",
        "operationId": "EgldEstimateGas",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/TransactionFeeEgldBlockchain" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["gasLimit", "gasPrice"],
                  "properties": {
                    "gasLimit": {
                      "type": "number",
                      "description": "Gas limit for transaction in gas price.",
                      "example": 77000
                    },
                    "gasPrice": { "type": "number", "description": "Gas price.", "example": 1000000000 }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403EgldGasCalculation" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate EGLD transaction fees",
        "tags": ["Blockchain fees"]
      }
    },
    "/v3/blockchain/sc/address/{chain}/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the blockchain address of a smart contract by the ID of its deployment transaction.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Elrond</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n<li>XinFix</li>\n</ul>\n",
        "operationId": "SCGetContractAddress",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["BSC", "CELO", "EGLD", "ETH", "FLOW", "KLAY", "MATIC", "ONE", "TRON", "XDC"]
            }
          },
          {
            "description": "The ID (hash) of the deployment transaction",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "The blockchain address of the smart contract",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the blockchain address of a smart contract by the deployment transaction ID",
        "tags": ["Blockchain utils"]
      }
    },
    "/v3/gas-pump": {
      "post": {
        "summary": "Precalculate gas pump addresses",
        "description": "<p><b>2 credits per API call</b></p>\n<p>Precalculate (generate) gas pump addresses that you can assign to the customers of your custodial application.</p>\n<p>This API does not make any changes on the blockchain itself, just generates addresses that follow the blockchain's requirements for the address format; therefore, no gas fee is applied.</p><p/>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p><b>Address index</b><br/>\nEach address should be associated with its own index. Use the <code>from</code> and <code>to</code> request body parameters to set a range of index values for the addresses to precalculate. You can start with any number, but we recommend that you start from 0.</p>\n<p>In one API call, you can precalculate:</p>\n<ul>\n<li>Up to 4,000 addresses for Harmony</li>\n<li>Up to 500 addresses for TRON</li>\n<li>Up to 5,000 addresses for the other supported blockchains</li>\n</ul>\n<p>If you need more addresses than one API call can precalculate, make several API calls. For example, if you need 10,000 addresses on Ethereum, make an API call with an index range from 0 through 4,999 and then make another API call with an index range from 5,000 through 9,999.</p>\n<p>The order in which the precalculated addresses are returned in the API response is the order of the values in the index range, and the index values are assigned to the addresses accordingly.<br/>For example, you precalculated three gas pump addresses with a range of index values from 3 to 5. The first address in the returned arrray is assigned the index value \"3\", the second one - \"4\", and the third one - \"5\".</p>\n<pre>\n[\n  \"0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea\", // index is 3\n  \"0x5c6079c14e9cd3d2ea8cb76aed9c5e336ef96126\", // index is 4\n  \"0xc5e336ef9612614e9cd3d2ea8cb76aed95c6079c\"  // index is 5\n]\n</pre>\n<p><b>The owner of the gas pump addresses</b><br/>\nThe owner (also referred to as \"master address\") is the blockchain address that will own the precalculated gas pump addresses. The owner will also be paying gas fees for operations made on the gas pump addresses. You have to make sure that the owner always has enough funds to cover these gas fees.</p>\n<p><b>Activated and not activated addresses</b><br/>\nThe precalculated addresses can be immediately assigned to customers and can <b>receive</b> funds. However, they cannot be used to <b>send</b> funds to other addresses. This is because the addresses are not activated. To make the addresses be able to send funds, <a href=\"#operation/ActivateGasPumpAddresses\">activate them</a>.</p>\n",
        "operationId": "PrecalculateGasPumpAddresses",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CreateGasPump" } } }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/GasPumpAddress" } }
              }
            }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "tags": ["Gas pump"]
      }
    },
    "/v3/gas-pump/activate": {
      "post": {
        "summary": "Activate gas pump addresses",
        "description": "<p><b>2 credits per API call</b></p>\n<p>Activate the <a href=\"#operation/PrecalculateGasPumpAddresses\">precalulated gas pump addresses</a>. Activating a gas pump address allows this address to send funds to other addresses.</p>\n<p>You can activate up to 270 addresses in one call. If you need to activate more than 270 addresses, make several API calls. For example, if you need to activate 500 addresses, make an API call with 270 addresses (set up the range of their index values accordingly in the <code>from</code> and <code>to</code> request body parameters) and then make another API call with the remaining 230 addresses.</p>\n<p><b>When to activate a gas pump address</b><br/>\nBecause activating a gas pump address costs some amount of gas on a blockchain, you want to activate only those addresses that will be used for sending funds to other addresses. If you know that a gas pump address will not be used for sending funds, you can leave this address not activated. The customer who uses this address will still be able to receive funds.</p>\n<p>Depending on your business needs and requirements, you can choose when to activate the gas pump addresses. If you know for sure that all the precalculated addresses will be sending funds, you can activate all the addresses right after they have been precalculated.</p>\n<p>Alternatively, you can set up the activation in such a way so that a gas pump address gets activated only when a specific event is triggered. For example, you can activate a gas pump address:</p>\n<ul>\n<li>When it receives an asset for the first time</li>\n<li>When the customer tries to send an asset from this address for the first time</li>\n</ul>\n<p>After you make an API call to activate gas pump addresses, use the <a href=\"#operation/ActivatedNotActivatedGasPumpAddresses\">API for getting the results of the address activation transaction</a>.</p>\n<p><b>Paying the gas fee for activating gas pump addresses</b><br/>\nYou can pay the gas fees for each activation transaction yourself, or Tatum can cover it for you.</p>\n<ul>\n<li>When <b>paying the gas fees yourself</b>, you must sign the transaction with either the private key of the blockchain address from which you want to pay the fees or the signature ID of that private key (if you use <a href=\"https://apidoc.tatum.io/tag/Key-Management-System\" target=\"_blank\">Key Management System</a>, KMS).<br/>\nTo pay the fees yourself, use this API with any schema of the request body except for <code>ActivateGasPumpTatum</code>. For example, if you are activating gas pump addresses on Ethereum and you use KMS, use the <code>ActivateGasPumpKMS</code> schema.\n</li>\n<li>If you want <b>Tatum to cover the fees</b>, use this API with the <code>ActivateGasPumpTatum</code> schema of the request body.\n<ul>\n<li>On the <b>mainnet</b>, you have to have a <a href=\"https://tatum.io/pricing\" target=\"_blank\">paid pricing plan</a>.<br/>\nTatum pays the fees from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you activate the addresses.</li>\n<li>On the <b>testnet</b>, no credits are deducted from the monthly credit allowance. You can activate gas pump addresses regardless of your pricing plan.</li>\n</ul>\n</li>\n</ul>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ActivateGasPumpTatum" },
                  { "$ref": "#/components/schemas/ActivateGasPump" },
                  { "$ref": "#/components/schemas/ActivateGasPumpKMS" },
                  { "$ref": "#/components/schemas/ActivateGasPumpCelo" },
                  { "$ref": "#/components/schemas/ActivateGasPumpCeloKMS" },
                  { "$ref": "#/components/schemas/ActivateGasPumpTron" },
                  { "$ref": "#/components/schemas/ActivateGasPumpTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "operationId": "ActivateGasPumpAddresses",
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "tags": ["Gas pump"]
      }
    },
    "/v3/gas-pump/address/{chain}/{txId}": {
      "get": {
        "summary": "Get the results of the address activation transaction",
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the results of the activation transaction after <a href=\"#operation/ActivateGasPumpAddresses\">activating gas pump addresses</a>.</p>\n<p>If the activation transaction got recorded into a block, the API returns two arrays:</p>\n<ul>\n<li><code>valid</code>, with the activated gas pump addresses</li>\n<li><code>invalid</code>, with the gas pump addresses that for some reason did not get activated together with the reason why</li>\n</ul>\n<p>If the transaction is still being processed, the API returns an error message. In this case, repeat the call later.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "parameters": [
          {
            "name": "chain",
            "in": "path",
            "required": true,
            "description": "The blockchain to work with",
            "schema": {
              "type": "string",
              "enum": ["BSC", "CELO", "ETH", "KLAY", "MATIC", "ONE", "TRON"],
              "example": "ETH"
            }
          },
          {
            "name": "txId",
            "in": "path",
            "required": true,
            "description": "The ID of the address activation transaction",
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326",
              "maxLength": 80,
              "minLength": 10
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/GasPumpTrxOut" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "operationId": "ActivatedNotActivatedGasPumpAddresses",
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "tags": ["Gas pump"]
      }
    },
    "/v3/gas-pump/activated/{chain}/{owner}/{index}": {
      "get": {
        "summary": "Check whether the gas pump address with a specified index is activated",
        "description": "<p><b>1 credit per API call</b></p>\n<p>Check whether the gas pump address with a specified index is <a href=\"#operation/ActivateGasPumpAddresses\">activated</a> and can send funds to other addresses.</p>\n<p>You can use this API when a customer initiates a fund transfer and you need to check whether their gas pump address is allowed to send funds.</p> \n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "parameters": [
          {
            "name": "chain",
            "in": "path",
            "description": "The blockchain to work with",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["BSC", "CELO", "ETH", "MATIC", "KLAY", "ONE", "TRON"],
              "example": "ETH"
            }
          },
          {
            "name": "owner",
            "in": "path",
            "description": "The blockchain address that owns the gas pump address to check; can be referred to as \"master address\"",
            "required": true,
            "schema": { "type": "string" }
          },
          {
            "name": "index",
            "in": "path",
            "description": "The index of the gas pump address to check",
            "required": true,
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Activated" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "operationId": "GasPumpAddressesActivatedOrNot",
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/sc/custodial/transfer": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Transfer (send) an asset from a gas pump address to the other address. The gas fee for sending the asset will be covered by crypto funds on the master address. Make sure that the master address always has enough funds to cover gas fees.</p>\n<ul>\n<li>To be able to send the asset, the gas pump address must be <a href=\"#operation/ActivateGasPumpAddresses\">activated</a>.</li>\n<li>To check whether the gas pump address is activated, use <a href=\"#operation/GasPumpAddressesActivatedOrNot\">this API</a>.</li>\n</ul>\n<p>With this API, you can send only one asset per API call. If you want to send multiple assets, use the <a href=\"#operation/TransferCustodialWalletBatch\">API for transferring multiple assets from a gas pump account</a>.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n<li>XinFin</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen transferring an asset, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TransferCustodialWallet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferCustodialWallet" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletKMS" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletCelo" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletCeloKMS" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletTron" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transfer an asset from a gas pump address",
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/sc/custodial/transfer/batch": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Transfer (send) multiple assets from a gas pump address to the other address. The gas fee for sending the assets will be covered by crypto funds on the master address. Make sure that the master address always has enough funds to cover gas fees.</p>\n<ul>\n<li>To be able to send the assets, the gas pump address must be <a href=\"#operation/ActivateGasPumpAddresses\">activated</a>.</li>\n<li>To check whether the gas pump address is activated, use <a href=\"#operation/GasPumpAddressesActivatedOrNot\">this API</a>.</li>\n</ul>\n<p>If you want to send only one asset, you can also use the <a href=\"#operation/TransferCustodialWallet\">API for transferring an asset from a gas pump account</a>.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n<li>XinFin</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen transferring assets, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TransferCustodialWalletBatch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferCustodialWalletBatch" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletBatchKMS" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletBatchCelo" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletBatchCeloKMS" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletBatchTron" },
                  { "$ref": "#/components/schemas/TransferCustodialWalletBatchTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transfer multiple assets from a gas pump address",
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/sc/custodial/approve": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Allow another blockchain address (the <code>spender</code> parameter in the request body) to transfer the asset from a gas pump address on behalf of the master address.</p>\n<p>Use this API when the customer using the gas pump address sells assets on a marketplace or auction. After the customer creates a listing of the asset, they have to allow the marketplace/auction smart contract to transfer the asset to the buyer after the asset has been bought.</p>\n<p>The asset can be one of the following types:</p>\n<ul>\n<li>Fungible token (ERC-20 or equivalent)</li>\n<li>NFT (ERC-721 or equivalent)</li>\n<li>Multi Token (ERC-1155 or equivalent)</li>\n</ul>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>XinFin</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen approving the transfer of an asset, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "ApproveTransferCustodialWallet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ApproveTransferCustodialWallet" },
                  { "$ref": "#/components/schemas/ApproveTransferCustodialWalletKMS" },
                  { "$ref": "#/components/schemas/ApproveTransferCustodialWalletCelo" },
                  { "$ref": "#/components/schemas/ApproveTransferCustodialWalletCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Approve the transfer of an asset from a gas pump address",
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/sc/custodial/batch": {
      "post": {
        "deprecated": true,
        "description": "<p><b>This API is deprecated.<br/>To start with the gas pump, use the <a href=\"#operation/PrecalculateGasPumpAddresses\">API for precalculating the gas pump addresses</a>.</b></p><br/>\n<p><b>2 credits per API call</b></p>\n<p>Generate new gas pump smart contract address on the blockchain. This address enables custodial providers to\nreceive native assets, ERC20 / ERC721 / ERC1155 tokens on behalf of their customers on dedicated blockchain address, but in the same time it can initiate transfer of those assets away.\nGas required for the transfer from that address is going to be deducted from the providers address - the one, which was used to generate the address on the blockchain.<br/>\nThis operation deploys a smart contract on the blockchain.<br/>\nFor paid plans, it is possible to pay for the gas costs - you don't have to provide private key or signatureId. Blockchain fees will be covered by your credits.\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n<li>XinFix</li>\n</ul>\n",
        "operationId": "GenerateCustodialWalletBatch",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatchPayer" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatch" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatchKMS" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatchCelo" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatchCeloKMS" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatchTron" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletBatchTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate a gas pump wallet address",
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/sc/custodial": {
      "post": {
        "deprecated": true,
        "description": "<p><b>This API is deprecated.<br/>To start with the gas pump, use the <a href=\"#operation/PrecalculateGasPumpAddresses\">API for precalculating the gas pump addresses</a>.</b></p>\n<p><b>If you built your gas pump solution using this API and the <a href=\"#operation/GenerateCustodialWalletBatch\">API for generating a gas pump wallet address</a>, you can still use this API for creating more custodial addresses for your solution. However, we recommend that you switch to the <a href=\"#operation/PrecalculateGasPumpAddresses\">API for precalculating the gas pump addresses</a></b>.</p><br/>\n<p><b>2 credits per API call</b></p>\n<p>Generate new gas pump smart contract address on the blockchain. It's possible to enable tokens, which should be detected and supported on that address. This address enables custodial providers to\nreceive native assets, ERC20 / ERC721 / ERC1155 tokens on behalf of their customers on dedicated blockchain address, but in the same time it can initiate transfer of those assets away.</p>\n<p>Gas required for the transfer from that address is going to be deducted from the providers address - the one, which was used to generate the address on the blockchain.</p>\n<p>There are multiple options, how this address can be setup - it cannot be changed in the future:</p>\n<ul>\n<li>Native assets only - ETH, BSC, CELO, MATIC, ONE, TRX</li>\n<li>Native assets + ERC20 tokens</li>\n<li>Native assets + ERC721 tokens</li>\n<li>Native assets + ERC1155 tokens - TRON does not support 1155 standard</li>\n<li>Native assets + ERC20 + ERC721 tokens</li>\n<li>Native assets + ERC20 + ERC1155 tokens - TRON does not support 1155 standard</li>\n<li>Native assets + ERC721 + ERC1155 tokens - TRON does not support 1155 standard</li>\n<li>Native assets + ERC20 + ERC721 + ERC1155 tokens - TRON does not support 1155 standard</li>\n</ul>\n<p>All of these options could be enabled with a batch mode as well - in 1 transaction, it is possible to transfer multiple different assets from that address, e.g. ETH + USDC + ERC721 token.\nWithout batch mode, 3 separate transaction must have been performed.</p>\n<p>This operation deploys a smart contract on the blockchain. More assets you will support, more intial gas will be used for address creation. Batch mode adds more gas for every type.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Polygon</li>\n<li>TRON (except for Multi Tokens)</li>\n</ul>\n",
        "operationId": "GenerateCustodialWallet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/GenerateCustodialWallet" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletKMS" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletCelo" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletCeloKMS" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletTron" },
                  { "$ref": "#/components/schemas/GenerateCustodialWalletTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate a custodial wallet address",
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/sc/custodial/{chain}/{hash}": {
      "get": {
        "deprecated": true,
        "description": "<p><b>This API is deprecated.<br/>To start with the gas pump, use the <a href=\"#operation/PrecalculateGasPumpAddresses\">API for precalculating the gas pump addresses</a>.</b></p>\n<p><b>If you built your gas pump solution using the <a href=\"#operation/GenerateCustodialWalletBatch\">API for generating a gas pump wallet address</a> and <a href=\"#operation/GenerateCustodialWallet\">API for generating a custodial wallet address</a>, you can still use this API for getting the custodial wallet address from the transaction. However, we recommend that you switch to the <a href=\"#operation/PrecalculateGasPumpAddresses\">API for precalculating the gas pump addresses</a></b>.</p><br/>\n<p><b>1 credit per API call</b></p>\n<p>Get gas pump smart contract addresses from deploy transaction.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "SCGetCustodialAddresses",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["CELO", "MATIC", "KLAY", "ETH", "ONE", "BSC", "TRON"] }
          },
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "Address of the wallet smart contract.",
                    "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the custodial wallet address from the transaction",
        "tags": ["Gas pump"]
      }
    },
    "/v3/blockchain/marketplace/listing": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Deploy an NFT marketplace smart contract on the blockchain. With a deployed marketplace smart contract, you and your customers can create new  listings for assets such as non-fungible tokens and combinations of token types as described by the ERC-721 and ERC-1155 standards on the Ethereum blockchain or by the equivalent standards on the other blockchains. As the marketplace operator, you can set a fee as a percentage of the asset price that will be paid on top of the asset price.</p>\n<p>The purchase process looks like the following:</p>\n<ol>\n<li>The seller <a href=\"#operation/SellAssetOnMarketplace\">creates a listing for an asset on the NFT marketplace</a>. The listing can be offered for the native blockchain assets (for example, ETH, BSC, and so on) or for the fungible tokens of the blockchain.</li>\n<li>The seller <a href=\"https://apidoc.tatum.io/tag/Auction#operation/ApproveNftAuctionSpending\" target=\"_blank\">allows the marketplace smart contract to transfer the asset that they are selling</a>.</li>\n<li>A buyer buys the asset.\n<ul><li>If the buyer wants to pay with the <b>native blockchain assets</b>, they <a href=\"#operation/BuyAssetOnMarketplace\">make the purchase</a> (the <code>buyAssetFromListing()</code> method is called against the marketplace smart contract) and send the required amount of the native assets to the marketplace smart contract.</li>\n<li>If the buyer wants to pay with the <b>fungible tokens</b>:\n<ol><li>The buyer <a href=\"https://apidoc.tatum.io/tag/Fungible-Tokens-(ERC-20-or-compatible)#operation/Erc20Approve\" target=\"_blank\">allows the marketplace smart contract to access their tokens</a> and makes the purchase (the <code>buyAssetFromListing()</code> method is called against the marketplace smart contract).</li>\n<li>The marketplace smart contract deducts the required amount of tokens from the smart contract where the buyer holds the tokens.</li></ol></li></ul></li>\n<li>The marketplace smart contract transfers the asset to the buyer, transfers the asset price to the seller, and sends the fee to the marketplace fee recepient.</li>\n</ol>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When deploying an NFT marketplace smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "GenerateMarketplace",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/GenerateMarketplace" },
                  { "$ref": "#/components/schemas/GenerateMarketplaceKMS" },
                  { "$ref": "#/components/schemas/GenerateMarketplaceCelo" },
                  { "$ref": "#/components/schemas/GenerateMarketplaceCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create an NFT marketplace",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/sell": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Create a new listing for an asset on the NFT marketplace. The listing can be offered for the native blockchain assets (for example, ETH, BSC, and so on) or for any fungible tokens.</p>\n<p>After the listing is created, <a href=\"https://apidoc.tatum.io/tag/Auction#operation/ApproveNftAuctionSpending\" target=\"_blank\">allow the marketplace smart contract to transfer the asset that you are selling</a>.</p>\n<p>You can create a listing only for an existing asset that you own (you must be the owner of the asset).</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>NOTE:</b> When making this API call, you may get the following message:<br/>\n<code>Although one or more Error Occurred [execution reverted] Contract Execution Completed</code><br/>\nThis message is a result of the marketplace version check and has no impact on completing the API call. You can safely ignore it.</p>\n<p><b>Signing a transaction</b></p>\n<p>When creating a new listing on the NFT marketplace, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "SellAssetOnMarketplace",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/SellAssetOnMarketplace" },
                  { "$ref": "#/components/schemas/SellAssetOnMarketplaceKMS" },
                  { "$ref": "#/components/schemas/SellAssetOnMarketplaceCelo" },
                  { "$ref": "#/components/schemas/SellAssetOnMarketplaceCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Sell an asset on the NFT marketplace",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/buy": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Buy an asset listed on the NFT marketplace.</p>\n<p>You can buy the asset either for the native blockchain assets (for example, ETH, BSC, and so on) or for the fungible tokens of the blockchain.</p>\n<ul>\n<li>If you want to pay for the asset with the <b>native assets</b>, send the required amount of the assets with the API call.</li>\n<li>If you want to pay with the <b>fungible tokens</b>, <a href=\"https://apidoc.tatum.io/tag/Fungible-Tokens-(ERC-20-or-compatible)#operation/Erc20Approve\" target=\"_blank\">allow the marketplace smart contract to access your tokens</a> before making the purchase. When you make the API call, the marketplace smart contract will deduct the required amount of the tokens from the smart contract where you hold the tokens.</li>\n</ul>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>NOTE:</b> When making this API call, you may get the following message:<br/>\n<code>Although one or more Error Occurred [execution reverted] Contract Execution Completed</code><br/>\nThis message is a result of the marketplace version check and has no impact on completing the API call. You can safely ignore it.</p>\n<p><b>Signing a transaction</b></p>\n<p>When buying an asset on the NFT marketplace, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BuyAssetOnMarketplace",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BuyAssetOnMarketplace" },
                  { "$ref": "#/components/schemas/BuyAssetOnMarketplaceKMS" },
                  { "$ref": "#/components/schemas/BuyAssetOnMarketplaceCelo" },
                  { "$ref": "#/components/schemas/BuyAssetOnMarketplaceCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Buy an asset on the NFT marketplace",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/cancel": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Cancel the selling of an asset on the NFT marketplace.</p>\n<p>You can cancel the selling only if you are the seller of the asset or the marketplace operator. Once the selling is canceled, the asset is returned to the seller.</p>\n<p>You cannot cancel the selling if the asset has already been purchased.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>NOTE:</b> When making this API call, you may get the following message:<br/>\n<code>Although one or more Error Occurred [execution reverted] Contract Execution Completed</code><br/>\nThis message is a result of the marketplace version check and has no impact on completing the API call. You can safely ignore it.</p>\n<p><b>Signing a transaction</b></p>\n<p>When cancelling the selling of an asset, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "CancelSellMarketplaceListing",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CancelSellAssetOnMarketplace" },
                  { "$ref": "#/components/schemas/CancelSellAssetOnMarketplaceKMS" },
                  { "$ref": "#/components/schemas/CancelSellAssetOnMarketplaceCelo" },
                  { "$ref": "#/components/schemas/CancelSellAssetOnMarketplaceCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Cancel the selling of an asset on the NFT marketplace",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/{type}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the open, sold, or cancelled listings from the NFT marketplace.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "GetMarketplaceListings",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "example": "CELO", "enum": ["CELO", "ETH", "MATIC"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          },
          {
            "description": "The type of listings to return",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": { "type": "string", "example": "INITIATED", "enum": ["INITIATED", "SOLD", "CANCELLED"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "type": "string", "description": "ID of the listing.", "example": "12345" }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the listings of a certain type from the NFT marketplace",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/listing/{id}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get information about a specific listing on the NFT marketplace.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "GetMarketplaceListing",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "ONE", "CELO", "MATIC", "BSC", "KLAY"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          },
          {
            "description": "Listing ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "123456" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "amount": {
                      "type": "string",
                      "description": "Amount of NFTs to sold in this listing. Valid only for ERC1155 listings.",
                      "example": "1"
                    },
                    "buyer": {
                      "type": "string",
                      "description": "Address of the buyer, if exists.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "erc20Address": {
                      "type": "string",
                      "description": "Address of the ERC20 token smart contract, which should be used for paying for the asset..",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "isErc721": {
                      "type": "boolean",
                      "description": "If the listing is for ERC721 or ERC1155 token.",
                      "example": true
                    },
                    "listingId": {
                      "type": "string",
                      "description": "ID of the listing.",
                      "example": "12345"
                    },
                    "nftAddress": {
                      "type": "string",
                      "description": "Address of the NFT smart contract.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "price": {
                      "type": "string",
                      "description": "Price of the NFT asset in native currency or ERC20 token based on the presence of erc20Address field.",
                      "example": "1.234"
                    },
                    "seller": {
                      "type": "string",
                      "description": "Address of the seller.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "state": {
                      "type": "string",
                      "description": "State of the listing. 0 - available, 1 - sold, 2 - cancelled",
                      "enum": ["0", "1", "2"],
                      "example": "1"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get information about a listing on the NFT marketplace",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/fee": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the NFT marketplace fee.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "GetMarketplaceFee",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "ONE", "CELO", "MATIC", "BSC", "KLAY"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Fee in percents.", "example": 2.25 }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the NFT marketplace fee",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/{chain}/{contractAddress}/recipient": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the recipient of the NFT marketplace fee.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "GetMarketplaceFeeRecipient",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "ONE", "CELO", "MATIC", "BSC", "KLAY"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Address of the marketplace fee recipient.",
                      "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the recepient of the NFT marketplace fee",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/recipient": {
      "put": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Update the recepient of the NFT marketplace fee.</p>\n<p>You can update the fee recepient only if you are the marketplace operator.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When updating the recepient of the NFT marketplace fee, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "UpdateFeeRecipient",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/UpdateFeeRecipient" },
                  { "$ref": "#/components/schemas/UpdateFeeRecipientKMS" },
                  { "$ref": "#/components/schemas/UpdateFeeRecipientCelo" },
                  { "$ref": "#/components/schemas/UpdateFeeRecipientCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update the recepient of the NFT marketplace fee",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/marketplace/listing/fee": {
      "put": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Update the NFT marketplace fee.</p>\n<p>You can update the marketplace fee only if you are the marketplace operator.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When updating the NFT marketplace fee, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "UpdateFee",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/UpdateFee" },
                  { "$ref": "#/components/schemas/UpdateFeeKMS" },
                  { "$ref": "#/components/schemas/UpdateFeeCelo" },
                  { "$ref": "#/components/schemas/UpdateFeeCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update the NFT marketplace fee",
        "tags": ["Marketplace"]
      }
    },
    "/v3/blockchain/auction": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Deploy new smart contract for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155).\nOperator can set a fee in percentage, which will be paid on top of the price of the asset.\ncan be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation.\nBefore auction is created, seller must approve transfer of the NFT to the auction contract.\nBuyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token.\nBuyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called.\nOnce there is higher bid then the actual one, the previous bidder's funds will be returned to him and new bidder will be the current winning one.\nWhen auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.<br/>\nThis operation deploys a smart contract on the blockchain.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n</p>\n",
        "operationId": "GenerateAuction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/GenerateAuction" },
                  { "$ref": "#/components/schemas/GenerateAuctionKMS" },
                  { "$ref": "#/components/schemas/GenerateAuctionCelo" },
                  { "$ref": "#/components/schemas/GenerateAuctionCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create NFT Auction",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/sell": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Create new auction on the auction contract. Before operation, seller must approve spending of the NFT token for the Auction contract using <a href=\"#operation/ApproveNftAuctionSpending\">Approve NFT</a>.\nAfter auction is created, auction contract transfers the asset to the auction smart contract.\nOnly auction for existing NFTs can be created - seller must be owner of the NFT asset.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n</p>\n",
        "operationId": "CreateAuction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CreateAuction" },
                  { "$ref": "#/components/schemas/CreateAuctionKMS" },
                  { "$ref": "#/components/schemas/CreateAuctionCelo" },
                  { "$ref": "#/components/schemas/CreateAuctionCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Sell asset on the NFT Auction",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/bid": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Bid on the auction. Buyer must either send native assets with this operation, or <a href=\"https://apidoc.tatum.io/tag/Fungible-Tokens-(ERC-20-or-compatible)#operation/Erc20Approve\" target=\"_blank\">approve ERC20 token spending</a> in advance.</p>\n<p>After auction is sold, it's in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.</p>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n<p><b>NOTE:</b> When making this API call, you may get the following message:<br/>\n<code>Although one or more Error Occurred [execution reverted] Contract Execution Completed</code><br/>\nThis message is a result of the auction version check and has no impact on completing the API call. You can safely ignore it.</p>\n",
        "operationId": "BidOnAuction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BidOnAuction" },
                  { "$ref": "#/components/schemas/BidOnAuctionKMS" },
                  { "$ref": "#/components/schemas/BidOnAuctionCelo" },
                  { "$ref": "#/components/schemas/BidOnAuctionCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Bid for asset on the NFT Auction",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/cancel": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n<p><b>NOTE:</b> When making this API call, you may get the following message:<br/>\n<code>Although one or more Error Occurred [execution reverted] Contract Execution Completed</code><br/>\nThis message is a result of the auction version check and has no impact on completing the API call. You can safely ignore it.</p>\n",
        "operationId": "CancelAuction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CancelOrSettleAuction" },
                  { "$ref": "#/components/schemas/CancelOrSettleAuctionKMS" },
                  { "$ref": "#/components/schemas/CancelOrSettleAuctionCelo" },
                  { "$ref": "#/components/schemas/CancelOrSettleAuctionCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Cancel auction of the asset on the NFT Auction",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/settle": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n<p><b>NOTE:</b> When making this API call, you may get the following message:<br/>\n<code>Although one or more Error Occurred [execution reverted] Contract Execution Completed</code><br/>\nThis message is a result of the auction version check and has no impact on completing the API call. You can safely ignore it.</p>\n",
        "operationId": "SettleAuction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CancelOrSettleAuction" },
                  { "$ref": "#/components/schemas/CancelOrSettleAuctionKMS" },
                  { "$ref": "#/components/schemas/CancelOrSettleAuctionCelo" },
                  { "$ref": "#/components/schemas/CancelOrSettleAuctionCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Settle auction of the asset on the NFT Auction",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/approve": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Approve NFT transfer for auction to perform listing of the asset.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n</p>\n",
        "operationId": "ApproveNftAuctionSpending",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ApproveNftSpending" },
                  { "$ref": "#/components/schemas/ApproveNftSpendingKMS" },
                  { "$ref": "#/components/schemas/ApproveNftSpendingCelo" },
                  { "$ref": "#/components/schemas/ApproveNftSpendingCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Approve NFT token spending for the Auction / Marketplace",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/{chain}/{contractAddress}/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get detail of the specific auction.</p>",
        "operationId": "GetAuction",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "ONE", "CELO", "MATIC", "BSC"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          },
          {
            "description": "Auction ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "123456" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "amount": {
                      "type": "string",
                      "description": "Amount of NFTs to sold in this auction. Valid only for ERC1155 listings.",
                      "example": "1"
                    },
                    "bidder": {
                      "type": "string",
                      "description": "Address of the highest buyer, if exists.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "erc20Address": {
                      "type": "string",
                      "description": "Address of the ERC20 token smart contract, which should be used for paying for the asset..",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "isErc721": {
                      "type": "boolean",
                      "description": "If the listing is for ERC721 or ERC1155 token.",
                      "example": true
                    },
                    "startedAt": {
                      "type": "string",
                      "description": "Block height this auction started at.",
                      "example": "12345"
                    },
                    "endedAt": {
                      "type": "string",
                      "description": "Block height this auction ended at.",
                      "example": "12349"
                    },
                    "nftAddress": {
                      "type": "string",
                      "description": "Address of the NFT smart contract.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "endingPrice": {
                      "type": "string",
                      "description": "Final auction price of the NFT asset in native currency or ERC20 token based on the presence of erc20Address field.",
                      "example": "1.234"
                    },
                    "seller": {
                      "type": "string",
                      "description": "Address of the seller.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    },
                    "highestBid": {
                      "type": "string",
                      "description": "Current highest bid of the NFT asset in native currency or ERC20 token based on the presence of erc20Address field.",
                      "example": "1.234"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get auction details from the NFT Auction",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/{chain}/{contractAddress}/fee": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get fee of the auction.</p>",
        "operationId": "GetAuctionFee",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "ONE", "CELO", "MATIC", "BSC"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Fee in percents.", "example": 2.25 }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT Auction fee",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/{chain}/{contractAddress}/recipient": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get fee recipient of the auction.</p>",
        "operationId": "GetAuctionFeeRecipient",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "ONE", "CELO", "MATIC", "BSC"] }
          },
          {
            "description": "Contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Address of the auction fee recipient.",
                      "example": "0xe6e7340394958674cdf8606936d292f565e4ecc4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT Auction fee recipient",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/recipient": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Update fee recipient of the auction.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n</p>\n",
        "operationId": "UpdateAuctionFeeRecipient",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/UpdateFeeRecipient" },
                  { "$ref": "#/components/schemas/UpdateFeeRecipientKMS" },
                  { "$ref": "#/components/schemas/UpdateFeeRecipientCelo" },
                  { "$ref": "#/components/schemas/UpdateFeeRecipientCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update NFT Auction fee recipient",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/fee": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Update fee of the auction.<br/>\nSupported blockchains:\n<ul>\n<li>Binance Smart Chain</li>\n<li>Harmony.ONE</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Polygon (Matic)</li>\n<li>Klaytn</li>\n</ul>\n</p>\n",
        "operationId": "UpdateAuctionFee",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/UpdateFee" },
                  { "$ref": "#/components/schemas/UpdateFeeKMS" },
                  { "$ref": "#/components/schemas/UpdateFeeCelo" },
                  { "$ref": "#/components/schemas/UpdateFeeCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update NFT Auction fee",
        "tags": ["Auction"]
      }
    },
    "/v3/blockchain/auction/time/{chain}/{date}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get an estimated block height (number) for some future point in time.</p>\n<p>Note that this API returnes an <b>estimation</b> of what the block height might be and <b>not</b> the exact block height.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "GetAuctionEstimatedTime",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["BSC", "CELO", "ETH", "KLAY", "MATIC", "ONE"] }
          },
          {
            "description": "The date and time in the ISO 8601 standard format",
            "in": "path",
            "name": "date",
            "required": true,
            "schema": { "type": "string", "example": "2021-09-17T07:55:54Z" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "description": "The estimated block hight (number)",
                  "example": 15795762
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate the block height for a future point in time",
        "tags": ["Blockchain utils"]
      }
    },
    "/v3/blockchain/node/{chain}/{xApiKey}/{rpcPath}": {
      "post": {
        "description": "<p><b>The number of credits consumed depends on the number of methods submitted in an API call:<br/>\n* 50 credits per debug*/trace* method (for EVM-based blockchains)<br/>\n* 5 credits per eth_call method (for EVM-based blockchains)<br/>\n* 2 credits per any other RPC method</b></p>\n<p>Connect directly to the blockchain node provided by Tatum.</p>\n<p>The <code>POST</code> method is used. The API endpoint URL acts as an HTTP-based RPC driver.</p>\n<p>In the request body, provide valid Web3 RPC method content, for example:</p>\n<pre>\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"method_name\",\n  \"params\": []\n}\n</pre>\n<p>For the blockchains using the JSON-RPC 2.0 specification, you can submit multiple RPC methods in one API call:</p>\n<pre>\n[\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"method_1_name\",\n    \"params\": []\n  },\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"method_2_name\",\n    \"params\": []\n  },\n  ...\n]\n</pre>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n  <li><a href=\"https://developer.algorand.org/docs/rest-apis/restendpoints/\" target=\"_blank\">Algorand</a></li>\n  <li><a href=\"https://ethereum.org/en/developers/docs/apis/json-rpc/\" target=\"_blank\">Arbitrum</a></li>\n  <li><a href=\"https://doc.aurora.dev/compat/rpc/\" target=\"_blank\">Aurora</a></li>\n  <li><a href=\"https://docs.avax.network/apis/avalanchego/apis/c-chain\" target=\"_blank\">Avalanche C-Chain</a></li>\n  <li><a href=\"https://docs.avax.network/apis/avalanchego/apis/p-chain\" target=\"_blank\">Avalanche P-Chain</a></li>\n  <li><a href=\"https://docs.avax.network/apis/avalanchego/apis/x-chain\" target=\"_blank\">Avalanche X-Chain</a></li>\n  <li><a href=\"https://developer.bitcoin.org/reference/rpc/index.html\" target=\"_blank\">Bitcoin</a></li>\n  <li><a href=\"https://docs.bitcoincashnode.org/doc/json-rpc/\" target=\"_blank\">Bitcoin Cash</a></li>\n  <li><a href=\"https://docs.bnbchain.org/docs/rpc\" target=\"_blank\">BNB Smart Chain</a></li>\n  <li><a href=\"https://docs.cardano.org/cardano-components/cardano-rosetta\" target=\"_blank\">Cardano</a></li>\n  <li><a href=\"https://explorer.celo.org/api-docs\" target=\"_blank\">Celo</a></li>\n  <li><a href=\"https://cronos.org/docs/resources/chain-integration.html\" target=\"_blank\">Cronos</a></li>\n  <li><a href=\"https://dogecoin.com/\" target=\"_blank\">Dogecoin</a></li>\n  <li><a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/nodes/\" target=\"_blank\">Elrond</a></li>\n  <li><a href=\"https://developers.eos.io/welcome/latest/reference/nodeos-rpc-api-reference\" target=\"_blank\">EOSIO</a></li>\n  <li><a href=\"https://ethereum.org/en/developers/docs/apis/json-rpc/\" target=\"_blank\">Ethereum</a></li>\n  <li><a href=\"https://docs.fantom.foundation/api/public-api-endpoints\" target=\"_blank\">Fantom</a></li>\n  <li><a href=\"https://developers.gnosischain.com/for-developers/developer-resources\" target=\"_blank\">Gnosis</a></li>\n  <li><a href=\"https://docs.harmony.one/home/developers/api\" target=\"_blank\">Harmony</a></li>\n  <li><a href=\"https://docs.klaytn.foundation/dapp/json-rpc\" target=\"_blank\">Klaytn</a></li>\n  <li><a href=\"https://docs.kcc.io/\" target=\"_blank\">KuCoin Community Chain</a></li>\n  <li><a href=\"https://guide.kusama.network/docs/build-node-interaction/\" target=\"_blank\">Kusama</a></li>\n  <li><a href=\"https://lisk.com/documentation/lisk-service/references/api.html\" target=\"_blank\">Lisk</a></li>\n  <li><a href=\"https://litecoin.org/\" target=\"_blank\">Litecoin</a></li>\n  <li><a href=\"https://docs.near.org/api/rpc/introduction\" target=\"_blank\">NEAR</a></li>\n  <li><a href=\"https://docs.neo.org/docs/en-us/reference/rpc/latest-version/api.html\" target=\"_blank\">Neo</a></li>\n  <li><a href=\"https://docs.oasis.dev/oasis-core/oasis-node/rpc/\" target=\"_blank\">Oasis Network</a></li>\n  <li><a href=\"https://community.optimism.io/docs/developers/build/json-rpc/\" target=\"_blank\">Optimism</a></li>\n  <li><a href=\"https://docs.palm.io/Get-Started/Connect/Overview/\" target=\"_blank\">Palm</a></li>\n  <li><a href=\"https://wiki.polkadot.network/docs/build-node-interaction\" target=\"_blank\">Polkadot</a></li>\n  <li><a href=\"https://polygon.technology/developers\" target=\"_blank\">Polygon</a></li>\n  <li><a href=\"https://developers.rsk.co/rsk/node/architecture/json-rpc/\" target=\"_blank\">RSK</a></li>\n  <li><a href=\"https://docs.solana.com/developing/clients/jsonrpc-api\" target=\"_blank\">Solana</a></li>\n  <li><a href=\"https://developers.stellar.org/api\" target=\"_blank\">Stellar</a></li>\n  <li><a href=\"https://opentezos.com/tezos-basics/cli-and-rpc/\" target=\"_blank\">Tezos</a></li>\n  <li><a href=\"https://developers.tron.network/reference/full-node-api-overview\" target=\"_blank\">TRON</a></li>\n  <li><a href=\"https://www.vechain.org/\" target=\"_blank\">VeChain</a></li>\n  <li><a href=\"https://apidocs.xinfin.network/docs/\" target=\"_blank\">XinFin</a></li>\n  <li><a href=\"https://zcash-rpc.github.io/\" target=\"_blank\">ZCash</a></li>\n</ul>\n",
        "operationId": "NodeJsonPostRpcDriver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization. You can omit this path parameter and either use the X-Api-Key header, or the API key tied to your IP address without any header.",
            "in": "path",
            "name": "xApiKey",
            "required": false,
            "schema": { "type": "string", "example": "ea8ce228-6ca3-465c-abb0-fd3c5d35c0d5" }
          },
          {
            "description": "Blockchain to communicate with.",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "example": "ALGO",
              "enum": [
                "ADA",
                "ARB",
                "AURORA",
                "ALGO",
                "AVAX",
                "BCH",
                "BSC",
                "BTC",
                "CELO",
                "CRO",
                "DOGE",
                "EGLD",
                "EOS",
                "ETH",
                "FTM",
                "GNO",
                "KCS",
                "KSM",
                "KLAY",
                "LISK",
                "LTC",
                "NEAR",
                "OASIS",
                "OPTIMISM",
                "DOT",
                "PALM",
                "MATIC",
                "ONE",
                "RSK",
                "SOL",
                "TEZOS",
                "ZCASH",
                "TRON",
                "VET",
                "XDC",
                "XLM",
                "NEO"
              ]
            }
          },
          {
            "description": "Type of the node to access for Algorand.",
            "in": "query",
            "name": "nodeType",
            "required": false,
            "schema": { "type": "string", "enum": ["ALGOD", "INDEXER"] }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "query",
            "name": "testnetType",
            "required": false,
            "schema": {
              "type": "string",
              "default": "ethereum-sepolia",
              "enum": ["ethereum-sepolia", "ethereum-goerli"]
            }
          },
          {
            "description": "Type of Avalanche network. Defaults to Avalanche C-Chain.",
            "in": "query",
            "name": "chainType",
            "required": false,
            "schema": { "type": "string", "default": "avax-c", "enum": ["avax-c", "avax-p", "avax-x"] }
          },
          {
            "description": "Optional path of rpc call for non EVM nodes, e.g. Algorand or Stellar.",
            "in": "path",
            "name": "rpcPath",
            "required": false,
            "schema": { "type": "string", "example": "v2/accounts" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "A valid Web3 RPC method content body with one or multiple RPC methods",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "A valid RPC response",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": { "type": "object", "description": "A valid RPC error response." }
              }
            },
            "description": "Internal server error"
          }
        },
        "x-codeSamples": [],
        "summary": "Connect to the blockchain node through an RPC driver",
        "tags": ["Node RPC"]
      },
      "put": {
        "description": "<p><b>2 credits per RPC method in an API call</b></p>\n<p>Connect directly to the blockchain node provided by Tatum.</p>\n<p>The <code>PUT</code> method is used. The API endpoint URL acts as an HTTP-based RPC driver.</p>\n<p>In the request body, provide valid Web3 RPC method content, for example:</p>\n<pre>\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"method_name\",\n  \"params\": []\n}\n</pre>\n<p>For the blockchains using the JSON-RPC 2.0 specification, you can submit multiple RPC methods in one API call:</p>\n<pre>\n[\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"method_1_name\",\n    \"params\": []\n  },\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"method_2_name\",\n    \"params\": []\n  },\n  ...\n]\n</pre>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n  <li><a href=\"https://developer.algorand.org/docs/rest-apis/restendpoints/\" target=\"_blank\">Algorand</a></li>\n  <li><a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/nodes/\" target=\"_blank\">Elrond</a></li>\n  <li><a href=\"https://developers.stellar.org/api\" target=\"_blank\">Stellar</a></li>\n</ul>\n",
        "operationId": "NodeJsonRpcPutDriver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization. You can omit this path parameter and either use the X-Api-Key header, or the API key tied to your IP address without any header.",
            "in": "path",
            "name": "xApiKey",
            "required": false,
            "schema": { "type": "string", "example": "ea8ce228-6ca3-465c-abb0-fd3c5d35c0d5" }
          },
          {
            "description": "Blockchain to communicate with.",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "example": "ALGO", "enum": ["ALGO", "EGLD", "XLM"] }
          },
          {
            "description": "Type of the node to access for Algorand.",
            "in": "query",
            "name": "nodeType",
            "required": false,
            "schema": { "type": "string", "enum": ["ALGOD", "INDEXER"] }
          },
          {
            "description": "Optional path of rpc call for non EVM nodes, e.g. Algorand or Stellar.",
            "in": "path",
            "name": "rpcPath",
            "required": false,
            "schema": { "type": "string", "example": "v2/accounts" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "A valid Web3 RPC method content body with one or multiple RPC methods",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "A valid RPC response",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid RPC error response.",
                  "example": null
                }
              }
            },
            "description": "Internal server error"
          }
        },
        "x-codeSamples": [],
        "summary": "Connect to the blockchain node through an RPC driver",
        "tags": ["Node RPC"]
      },
      "get": {
        "description": "<p><b>2 credits per RPC method in an API call</b></p>\n<p>Connect directly to the blockchain node provided by Tatum.</p>\n<p>The <code>GET</code> method is used. The API endpoint URL acts as an HTTP-based RPC driver.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n  <li><a href=\"https://developer.algorand.org/docs/rest-apis/restendpoints/\" target=\"_blank\">Algorand</a></li>\n  <li><a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/nodes/\" target=\"_blank\">Elrond</a></li>\n  <li><a href=\"https://lisk.com/documentation/lisk-service/references/api.html\" target=\"_blank\">Lisk</a></li>\n  <li><a href=\"https://developers.stellar.org/api\" target=\"_blank\">Stellar</a></li>\n  <li><a href=\"https://opentezos.com/tezos-basics/cli-and-rpc/\" target=\"_blank\">Tezos</a></li>\n  <li><a href=\"https://developers.tron.network/reference/full-node-api-overview\" target=\"_blank\">TRON</a></li>\n</ul>\n",
        "operationId": "NodeJsonRpcGetDriver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization. You can omit this path parameter and either use the X-Api-Key header, or the API key tied to your IP address without any header.",
            "in": "path",
            "name": "xApiKey",
            "required": false,
            "schema": { "type": "string", "example": "ea8ce228-6ca3-465c-abb0-fd3c5d35c0d5" }
          },
          {
            "description": "Blockchain to communicate with.",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "example": "ALGO",
              "enum": ["ALGO", "EGLD", "LISK", "XLM", "TEZOS", "TRON"]
            }
          },
          {
            "description": "Type of the node to access for Algorand.",
            "in": "query",
            "name": "nodeType",
            "required": false,
            "schema": { "type": "string", "enum": ["ALGOD", "INDEXER"] }
          },
          {
            "description": "Optional path of rpc call for non EVM nodes, e.g. Algorand or Stellar.",
            "in": "path",
            "name": "rpcPath",
            "required": false,
            "schema": { "type": "string", "example": "v2/accounts" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "A valid RPC response",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": { "type": "object", "description": "Any valid RPC error response." }
              }
            },
            "description": "Internal server error"
          }
        },
        "x-codeSamples": [],
        "summary": "Connect to the blockchain node through an RPC driver",
        "tags": ["Node RPC"]
      }
    },
    "/v3/ethereum/wallet": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value which should never be revealed</li><li>Public Key - a public address to be published</li><li>Derivation index - an index of generated address</li></ul></p><p>Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44'/60'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerates a BIP44 compatible Ethereum wallet.</p>\n",
        "operationId": "EthGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generating extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Ethereum wallet",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/address/{xpub}/{index}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "EthGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of the address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/GeneratedAddressEth" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Ethereum account address from Extended public key",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/wallet/priv": {
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "EthGenerateAddressPrivateKey",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Ethereum private key",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as an http-based web3 driver to connect directly to the Ethereum node provided by Tatum.\nTo learn more about Ethereum Web3, visit the <a href=\"https://ethereum.org/en/developers/\" target=\"_blank\">Ethereum developers' guide</a>.</p>\n",
        "operationId": "EthWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "query",
            "name": "testnetType",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/block/current": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets the current Ethereum block number. This is the number of the latest block in the blockchain.</p>",
        "operationId": "EthGetCurrentBlock",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/block/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets an Ethereum block-by-block hash or block number.</p>",
        "operationId": "EthGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Ethereum block by hash",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/account/balance/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Gets an Ethereum account balance in ETH. This method does not display the balance of ERC20 or ERC721 tokens in the account.</p>",
        "operationId": "EthGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthBalance" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Ethereum account balance",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/transaction/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Ethereum transaction by transaction hash.</p>",
        "operationId": "EthGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Transaction not found.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error404TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Ethereum Transaction",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/transaction/count/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "EthGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing Ethereum transactions",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/account/transaction/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.</p>",
        "operationId": "EthGetTransactionByAddress",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 1, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 1, "example": 1087823 }
          },
          {
            "description": "Sorting of the data. ASC - oldest first, DESC - newest first.",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "default": "DESC", "example": "ASC", "enum": ["ASC", "DESC"] }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/EthTx" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Ethereum transactions by address",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send Ethereum or Tatum supported ERC20 token from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "EthBlockchainTransfer",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEthBlockchain" },
                  { "$ref": "#/components/schemas/TransferEthBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Ethereum / ERC20 from account to account",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on Ethereum.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "EthBlockchainSmartContractInvocation",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallReadSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthScBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on Ethereum",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/account/transaction/erc20/internal/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get Ethereum internal transactions by address.<br/></p>\n",
        "operationId": "EthGetInternalTransactionByAddress",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/EthTxInternal" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Ethereum internal transactions by address",
        "tags": ["Ethereum"]
      }
    },
    "/v3/ethereum/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "EthBroadcast",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403EthBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Ethereum transaction",
        "tags": ["Ethereum"]
      }
    },
    "/v3/kms/pending/{chain}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the list of pending transactions to sign and broadcast using <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">KMS</a>.</p>\n",
        "operationId": "GetPendingTransactionsToSign",
        "parameters": [
          {
            "description": "Blockchain to get pending transactions for.",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 24,
              "minLength": 24,
              "enum": [
                "BNB",
                "BTC",
                "ETH",
                "XLM",
                "XRP",
                "BCH",
                "LTC",
                "DOGE",
                "VET",
                "BSC",
                "MATIC",
                "CELO",
                "FLOW",
                "TRON",
                "ONE",
                "XDC",
                "EGLD",
                "KLAY",
                "SOL"
              ]
            }
          },
          {
            "description": "Signature IDs of the KMS which invokes this endpoint. If multiple, they should be separated by comma.",
            "in": "query",
            "name": "signatures",
            "required": false,
            "schema": {
              "type": "string",
              "example": "6d78dad2-518f-4e76-8255-8f1df0de6884,6d78dad2-518f-4e76-8255-8f1df0de6885,6d78dad2-518f-4e76-8255-8f1df0de6886"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/PendingTransaction" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get pending transactions to sign",
        "tags": ["Key Management System"]
      },
      "post": {
        "description": "<p><b>1 credit for every 500 signature IDs per API call</b></p>\n<p>Get the list of pending transactions to sign and broadcast using <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">KMS</a>.</p>\n<p><b>NOTE:</b> This API works only in KMS v5.0 or later. If you use KMS older than v5.0, use <a href=\"#operation/GetPendingTransactionsToSign\">this API</a> instead.</p>\n",
        "operationId": "ReceivePendingTransactionsToSign",
        "parameters": [
          {
            "description": "Blockchain to get pending transactions for.",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 24,
              "minLength": 24,
              "enum": [
                "BNB",
                "BTC",
                "ETH",
                "XLM",
                "XRP",
                "BCH",
                "LTC",
                "DOGE",
                "VET",
                "BSC",
                "MATIC",
                "CELO",
                "FLOW",
                "TRON",
                "ONE",
                "XDC",
                "EGLD",
                "KLAY",
                "SOL"
              ]
            }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/KmsSignatureIds" } } },
          "required": false,
          "description": "Signature IDs of the KMS which invokes this endpoint."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/PendingTransaction" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get pending transactions to sign",
        "tags": ["Key Management System"]
      }
    },
    "/v3/kms/{id}/{txId}": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Mark pending transaction to sign as a complete and update it with a transactionID from the blockchain.</p>\n",
        "operationId": "CompletePendingSignature",
        "parameters": [
          {
            "description": "ID of pending transaction",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string",
              "example": "f91827364f91827364ajdur7",
              "maxLength": 24,
              "minLength": 24
            }
          },
          {
            "description": "transaction ID of blockchain transaction",
            "in": "path",
            "name": "txId",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326",
              "maxLength": 80,
              "minLength": 10
            }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Complete pending transaction to sign",
        "tags": ["Key Management System"]
      }
    },
    "/v3/kms/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get detail of transaction to be signed / that was already signed and contains transactionId.</p>",
        "operationId": "GetPendingTransactionToSign",
        "parameters": [
          {
            "description": "ID of transaction",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 24, "minLength": 24 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/PendingTransaction" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403KMSNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get transaction details",
        "tags": ["Key Management System"]
      },
      "delete": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Delete transaction to be signed. When deleting offchain transaction, linked withdrawal will be cancelled automatically.</p>",
        "operationId": "DeletePendingTransactionToSign",
        "parameters": [
          {
            "description": "ID of transaction",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 24, "minLength": 24 }
          },
          {
            "description": "Defines whether fee should be reverted to account balance as well as amount. Defaults to true. Revert true would be typically used when withdrawal was not broadcast to blockchain. False is used usually for Ethereum ERC20 based currencies.",
            "in": "query",
            "name": "revert",
            "required": false,
            "schema": { "default": true, "example": true, "type": "boolean" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KMSNotExists" },
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Delete transaction",
        "tags": ["Key Management System"]
      }
    },
    "/v3/security/address/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Check, if the blockchain address is malicous. Malicous address can contain assets from the DarkWeb, is connected to the scam projects or contains stolen funds.</p><br/>\n<p>Supported Chains: ETH, BTC, LTC</p>\n",
        "operationId": "CheckMalicousAddress",
        "parameters": [
          {
            "description": "Blockchain Address to check",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "example": "0x002Bf459dC58584D58886169EA0E80f3Ca95FFAF", "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "description": "Whether address is malicous or not",
                      "example": "valid",
                      "enum": ["valid", "invalid"]
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Check malicous address",
        "tags": ["Malicious address"]
      }
    },
    "/v3/ledger/customer": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>List of all customers. Also inactive an disabled customers are present.</p>\n",
        "operationId": "findAllCustomers",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Customer" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all customers",
        "tags": ["Customer"]
      }
    },
    "/v3/ledger/customer/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Using anonymized external ID or internal customer ID you can access customer detail information. Internal ID is needed to call other customer related methods.</p>",
        "operationId": "getCustomerByExternalOrInternalId",
        "parameters": [
          {
            "description": "Customer external or internal ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 100, "minLength": 1 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Customer" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403CustomerNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get customer details",
        "tags": ["Customer"]
      },
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>This method is helpful in case your primary system will change ID's or customer will change the country he/she is supposed to be in compliance with.</p>",
        "operationId": "updateCustomer",
        "parameters": [
          {
            "description": "Customer internal ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 50, "minLength": 10 }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CustomerUpdate" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Customer" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403CustomerInternalNotExists" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update customer",
        "tags": ["Customer"]
      }
    },
    "/v3/ledger/customer/{id}/activate": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Activated customer is able to do any operation.</p>",
        "operationId": "activateCustomer",
        "parameters": [
          {
            "description": "Customer internal ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 50, "minLength": 10 }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403CustomerInternalNotExists" },
                    { "$ref": "#/components/schemas/Error403CustomerActive" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Activate customer",
        "tags": ["Customer"]
      }
    },
    "/v3/ledger/customer/{id}/deactivate": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Deactivate customer is not able to do any operation. Customer can be deactivated only when all their accounts are already deactivated.</p>",
        "operationId": "deactivateCustomer",
        "parameters": [
          {
            "description": "Customer internal ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 50, "minLength": 10 }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403CustomerDeactivateActiveAccounts" },
                    { "$ref": "#/components/schemas/Error403CustomerInactive" },
                    { "$ref": "#/components/schemas/Error403CustomerInternalNotExists" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deactivate customer",
        "tags": ["Customer"]
      }
    },
    "/v3/ledger/customer/{id}/enable": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Enabled customer can perform all operations. By default all customers are enabled. All previously blocked account balances will be unblocked.</p>",
        "operationId": "enableCustomer",
        "parameters": [
          {
            "description": "Customer internal ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 50, "minLength": 10 }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403CustomerInactive" },
                    { "$ref": "#/components/schemas/Error403CustomerEnabled" },
                    { "$ref": "#/components/schemas/Error403CustomerInternalNotExists" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Enable customer",
        "tags": ["Customer"]
      }
    },
    "/v3/ledger/customer/{id}/disable": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Disabled customer cannot perform end-user operations, such as create new accounts or send transactions. Available balance on all accounts is set to 0. Account balance will stay untouched.</p>",
        "operationId": "disableCustomer",
        "parameters": [
          {
            "description": "Customer internal ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 50, "minLength": 10 }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403CustomerInactive" },
                    { "$ref": "#/components/schemas/Error403CustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403CustomerInternalNotExists" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Disable customer",
        "tags": ["Customer"]
      }
    },
    "/v3/ledger/virtualCurrency": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Create new virtual currency with given supply stored in account. This will create Tatum internal virtual currency. Every virtual currency must be prefixed with <b>VC_</b>.<br/>\nEvery virtual currency must be pegged to existing FIAT or supported cryptocurrency. 1 unit of virtual currency has then the same amount as 1 unit of the base currency it is pegged to. It is possible to set a custom base rate for the virtual currency. (baseRate = 2 => 1 VC unit = 2 basePair units)<br/>\nTatum virtual currency acts as any other asset within Tatum. For creation of ERC20 token, see <a href=\\\"#tatum-blockchain-api-erc20\\\">ERC20 </a>.<br/>\nThis operation returns the newly created Tatum Ledger account with an initial balance set to the virtual currency's total supply. Total supply can be changed in the future.</p>\n",
        "operationId": "createCurrency",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VirtualCurrency" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Account" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403VCPrefix" },
                    { "$ref": "#/components/schemas/Error403VCDuplicate" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create new virtual currency",
        "tags": ["Virtual Currency"]
      },
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Change base pair and/or base rate of existing virtual currency.</p>",
        "operationId": "updateCurrency",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/VirtualCurrencyUpdate" } }
          },
          "required": true
        },
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VCNotFound" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update virtual currency",
        "tags": ["Virtual Currency"]
      }
    },
    "/v3/ledger/virtualCurrency/{name}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get detail of virtual currency.<p>",
        "operationId": "getCurrency",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": { "maxLength": 100, "minLength": 3, "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VC" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403VCNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get virtual currency",
        "tags": ["Virtual Currency"]
      }
    },
    "/v3/ledger/virtualCurrency/mint": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Create new supply of virtual currency linked on the given accountId. Method increases the total supply of the currency.<br/>\nThis method creates Ledger transaction with operationType MINT with undefined counterAccountId.<p>\n",
        "operationId": "mintCurrency",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/VirtualCurrencyOperation" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionResult" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403VCNoAccount" },
                    { "$ref": "#/components/schemas/Error403VCTxFailed" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create new supply of virtual currency",
        "tags": ["Virtual Currency"]
      }
    },
    "/v3/ledger/virtualCurrency/revoke": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Destroy supply of virtual currency linked on the given accountId. Method decreases the total supply of the currency.<br/>\nThis method creates Ledger transaction with operationType REVOKE with undefined counterAccountId.</p>\n",
        "operationId": "revokeCurrency",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/VirtualCurrencyOperation" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionResult" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403VCNoAccount" },
                    { "$ref": "#/components/schemas/Error403VCTxFailed" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403VCRevokeBalance" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Destroy supply of virtual currency",
        "tags": ["Virtual Currency"]
      }
    },
    "/v3/trade": {
      "post": {
        "description": "<h4>2 credits for API call, 2 credits for each fill of the counter trade. 1 API call + 2 fills  = 6 credits.</h4><br/>\n<p>Store new buy / sell trade. If there is trade already available to fill, fill as much trades as possible.<br/>\nIt is possible to charge fees for the trades. Fees are an extra amount on top of the trade amount and are paid in the currency that you going to block\ne.g.:\n- BUY BTC/USDT - fees will be paid in USDT\n- SELL BTC/ETH - fees will be paid in BTC\n</p>\n\n<p>\nIf you fill type of the trade with FUTURE_BUY or FUTURE_SELL the trade will behave as a trade future. The trade is concluded now but will be fulfilled in future.\nThe date of fulfillment is by the “Seal Date” field. You can also block a percentage of the amount until the future trade has expired.\n</p>\n<p>Futures can also penalize contracting parties if they don’t have the agreed balance available in their accounts.\nThe penalty is calculated in the following way: Penalty amount = (Percentage of incomplete deal amount because of shortage from user) × (Maximum Penalty percentage of futures deal based on blocked amount and time interval) × (total blocked value).\n</p>\n<p>Example of the BTC/USDT trade future:</p>\n<p>The maker creates a sell with the following properties: 1 BTC at a price of 60000 USDT, with a blocking percentage of 22%, a penalty percentage of 45%, a system commision of 1% and with an expiration time of within 12 hours.</p>\n<pre>\n{\n  \"type\": \"FUTURE_SELL\",\n  \"price\": \"60000\",\n  \"amount\": \"1\",\n  \"pair\": \"BTC/USDT\",\n  \"currency1AccountId\": \"60a236db1b57f60d62612bf3\",\n  \"currency2AccountId\": \"609d0696bf835c241ac2920f\",\n  \"fee\": 1,\n  \"feeAccountId\": \"609d0696bf835c251ac2920a\",\n  \"attr\": {\n    \"sealDate\": 1621990960631,\n    \"percentBlock\": 22,\n    \"percentPenalty\": 45\n  }\n}\n</pre>\n\nThe taker accepts the offer with a buy and blocks 13200 USDT (60000 USDT × 0.22) in their account.\n<pre>\n{\n  \"type\": \"FUTURE_BUY\",\n  \"price\": \"60000\",\n  \"amount\": \"1\",\n  \"pair\": \"BTC/USDT\",\n  \"currency1AccountId\": \"60a236db1b57f60d62612bf2\",\n  \"currency2AccountId\": \"609d0696bf835c241ac2920a\",\n  \"attr\": {\n    \"sealDate\": 1621990960631,\n    \"percentBlock\": 22,\n    \"percentPenalty\": 45\n  }\n}\n</pre>\n<p>At the time of the trade, the maker and taker have the following conditions.\nThe maker has 0.65 BTC (35% deficit) in their account and the taker has 49200 USDT (18% deficit) in their account.\n</p>\n\n<p>\nThe maker penalty is equal to 0.35 × 0.22 × (0.45 × 1 BTC) = 0.03465 BTC.\nThe taker penalty is equal to 0.18 × 0.22 × (0.45 × 60000 USDT) = 1069.2 USDT.\n</p>\n<p>\nThe system commission for the maker is 1 BTC × 1% = 0.01 BTC.\nThe system commission for the taker is 60000 USDT × 1% = 600 USDT.\n</p>\n<p>\nThe maker’s assets after deducting penalties and commissions equals 0.65 - 0.03465 - 0.01 = 0.60535 BTC. The taker’s assets after deducting penalties and commissions equals 49200 - 1069.2 - 600 = 47530.8 USDT.\n</p>\n<p>\nThe amount received by the maker after the trade is (0.60535 × 60000) + 1069.2 = 37390.2 USDT and the taker receives 0.60535 + 0.03465 = 0.64 BTC.\n</p>\n",
        "operationId": "storeTrade",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CreateTrade" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Id" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AccountCurrencyVC" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency1NotFound" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency1Frozen" },
                    { "$ref": "#/components/schemas/Error403OrderFeeNotFound" },
                    { "$ref": "#/components/schemas/Error403OrderFeeIncompatible" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency1CustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency2NotFound" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency2Frozen" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency2CustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency1Pair" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency2Pair" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency1Balance" },
                    { "$ref": "#/components/schemas/Error403OrderCurrency2Balance" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Store buy / sell trade",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/chart": {
      "post": {
        "description": "<h4>2 credits for API call.</h4><br/>\n<p>Obtain data from the closed trades for entering in the chart. Time interval is set between <i>from</i> and <i>to</i> and there is defined time frame. There can be obtained at most 200 time points in the time interval.</p>\n",
        "operationId": "chartRequest",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/ChartRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/Chart" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Obtain chart data from historical closed trades",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/history": {
      "get": {
        "deprecated": true,
        "description": "<h4>1 credit per API call.</h4><br/><p>List all historical trades. It is possible to list all trades, trades for specific trading pair and/or account.</p>",
        "operationId": "getHistoricalTrades",
        "parameters": [
          {
            "description": "Account ID. If present, only closed trades for given account will be present.",
            "in": "query",
            "name": "id",
            "required": false,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "Trade pair. If present, only closed trades on given trade pair will be present.",
            "in": "query",
            "name": "pair",
            "required": false,
            "schema": {
              "type": "string",
              "example": "BTC/ETH",
              "minLength": 3,
              "maxLength": 30,
              "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "in": "query",
            "name": "count",
            "example": true,
            "schema": { "type": "boolean" }
          },
          {
            "description": "Trade types.",
            "in": "query",
            "name": "types",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "example": "BUY",
                "enum": ["FUTURE_BUY", "FUTURE_SELL", "BUY", "SELL"]
              }
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all historical trades",
        "tags": ["Order Book"]
      },
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all historical trades. It is possible to list all trades, trades for specific trading pair and/or account.</p>",
        "operationId": "getHistoricalTradesBody",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/ListOderBookHistoryBody" } }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all historical trades",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/buy": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all active buy trades.</p>",
        "operationId": "getBuyTrades",
        "deprecated": true,
        "parameters": [
          {
            "description": "Account ID. If present, list current active buy trades for that account.",
            "in": "query",
            "name": "id",
            "required": false,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "Customer ID. If present, list current active buy trades for that customer.",
            "in": "query",
            "name": "customerId",
            "required": false,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Trade pair. If present, list current active buy trades for that pair.",
            "in": "query",
            "name": "pair",
            "schema": {
              "type": "string",
              "example": "BTC/EUR",
              "minLength": 3,
              "maxLength": 30,
              "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
            }
          },
          {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "in": "query",
            "name": "count",
            "example": true,
            "schema": { "type": "boolean" }
          },
          {
            "description": "Trade type.",
            "in": "query",
            "name": "tradeType",
            "example": "BUY",
            "required": false,
            "schema": { "type": "string", "enum": ["FUTURE_BUY", "BUY"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all active buy trades",
        "tags": ["Order Book"]
      },
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all active buy trades.</p>",
        "operationId": "getBuyTradesBody",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/ListOderBookActiveBuyBody" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all active buy trades",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/sell": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all active sell trades.</p>",
        "operationId": "getSellTrades",
        "deprecated": true,
        "parameters": [
          {
            "description": "Account ID. If present, list current active sell trades for that account.",
            "in": "query",
            "name": "id",
            "required": false,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "Customer ID. If present, list current active buy trades for that customer.",
            "in": "query",
            "name": "customerId",
            "required": false,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Trade pair. If present, list current active sell trades for that pair.",
            "in": "query",
            "name": "pair",
            "schema": {
              "type": "string",
              "example": "BTC/EUR",
              "minLength": 3,
              "maxLength": 30,
              "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
            }
          },
          {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "in": "query",
            "name": "count",
            "example": true,
            "schema": { "type": "boolean" }
          },
          {
            "description": "Trade type.",
            "in": "query",
            "name": "tradeType",
            "example": "SELL",
            "required": false,
            "schema": { "type": "string", "enum": ["FUTURE_SELL", "SELL"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all active sell trades",
        "tags": ["Order Book"]
      },
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all active sell trades.</p>",
        "operationId": "getSellTradesBody",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/ListOderBookActiveSellBody" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all active sell trades",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/matched": {
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all matched orders from the FUTURE_BUY OR FUTURE_SELL orders.</p>",
        "operationId": "getMatchedTrades",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/ListOderBookMatchedBody" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Trade" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all matched orders from FUTURE_SELL/FUTURE_BUY trades",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/{id}": {
      "get": {
        "description": "<h4>1 credit for API call</h4><br/><p>Get existing opened trade.</p>",
        "parameters": [
          {
            "description": "Trade ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "operationId": "getTradeById",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Trade" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get existing trade",
        "tags": ["Order Book"]
      },
      "delete": {
        "description": "<h4>1 credit for API call</h4><br/><p>Cancel existing trade.</p>",
        "parameters": [
          {
            "description": "Trade ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "operationId": "deleteTrade",
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Cancel existing trade",
        "tags": ["Order Book"]
      }
    },
    "/v3/trade/account/{id}": {
      "delete": {
        "description": "<h4>1 credit for API call, 1 credit for each cancelled trade. 1 API call + 2 cancellations  = 3 credits.</h4><br/><p>Cancel all trades for account.</p>",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "operationId": "deleteAccountTrades",
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Cancel all existing trades for account",
        "tags": ["Order Book"]
      }
    },
    "/v3/subscription": {
      "post": {
        "description": "<p><b>2 credits per API call + credits spent on subscriptions themselves<br/>\nEach subscription type consumes a different number of credits.</b></p>\n<p>For Free plans, there is a monthly limit of sent webhooks, which is <b>1000</b>.</p>\n<p>If the webhook is sent unsuccessfully, it will be retried. The number of retries depends on the plan. </p>\n<ul>\n  <li><b>Free Plan</b> - 3 retries</li>\n  <li><b>Paid plans</b> - 10 retries</li>\n</ul>\n<p>Create a subscription as an HTTP web hook.</p>\n<p>The following subscription types are available:</p>\n<ul>\n<li><b>ADDRESS_TRANSACTION</b> - Enable HTTP POST JSON notifications for any blockchain transaction (both incoming and outgoing) at a specified address. This notification applies to transactions in the native blockchain currency or with any type of blockchain tokens.<br/>\n- For <b>EMV-based blockchains</b> (ETH), this web hook is first invoked when a transaction appears in the mempool, and then it is invoked again once the transaction is added to a block.<br/>\n- For the <b>other blockchains</b>, this webhook is invoked when a transaction is added to a block.<br/>\nFree community plans can monitor up to 10 addresses per plan.<br/>\nThe following table describes the availability of this notification type on different blockchains and the credit consumption:<br/>\n<table>\n  <tr>\n    <th>Chain</th>\n    <th>Testnet/Mainnet</th>\n    <th>Token assets support</th>\n    <th>Plan limitation</th>\n    <th>Credit consumption / day / address</th>\n  </tr>\n  <tr>\n    <td>Solana</td>\n    <td>Yes/Yes</td>\n    <td>SOL, SPL and NFTs</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>50 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Ethereum</td>\n    <td>Yes/Yes</td>\n    <td>ETH, Internal transfers, ERC20, ERC721, ERC1155</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>25 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Polygon</td>\n    <td>Yes/Yes</td>\n    <td>MATIC, ERC20, ERC721, ERC1155</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>40 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Celo</td>\n    <td>Yes/Yes</td>\n    <td>CELO, Internal transfers, ERC20, ERC721, ERC1155</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>25 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Klaytn</td>\n    <td>Yes/Yes</td>\n    <td>Klay, ERC20, ERC721, ERC1155</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>25 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Bitcoin</td>\n    <td>Yes/Yes</td>\n    <td>BTC</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>5 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Litecoin</td>\n    <td>Yes/Yes</td>\n    <td>LTC</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>7 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Bitcoin Cash</td>\n    <td>Yes/Yes</td>\n    <td>BCH, only incoming transactions</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>5 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Dogecoin</td>\n    <td>Yes/Yes</td>\n    <td>DOGE, only incoming transactions</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>7 credits / day / address</td>\n  </tr>\n   <tr>\n    <td>Tron</td>\n    <td>Yes/Yes</td>\n    <td>Tron, TRC10/TRC20</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>30 credits / day / address</td>\n  </tr>\n  <tr>\n    <td>Binance Smart Chain</td>\n    <td>Yes/Yes</td>\n    <td>BSC, BEP20, ERC721, ERC1155</td>\n    <td>Free plans - 10 addresses across all blockchains, Paid plans - unlimited addresses across all blockchains</td>\n    <td>40 credits / day / address</td>\n  </tr>\n</table>\nThe request body of the POST request is a JSON object with the following structure:<br/>\n<pre>{\n  \"address\": \"FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ\", // the address on which the transaction occurs; for EVM-based chains, this is the recipient's address\n  \"txId\": \"2rdy3YCZHSwvpWtuDom1d4Jjy5UU9STLxF3ffXau6GToReDkfw8wEgX541fvzvh6btVC5D8iNapcKTXfPsoDBk7A\", // the transaction ID\n  \"blockNumber\": 110827114, // the block number; does not appear if the transaction is in the mempool (for EMV-based blockchains)\n  \"asset\": \"3gUeeR3BfVhukYJMwtHownRtRkGcf1bvwiV8TbKMZBVz\", // the asset of the transaction: for token assets, this is the token address; for native blochckain assets, this is the name of the asset (for example, SOL)\n  \"amount\": \"1\", // the amount of the asset that was credited to (+) or debited from (-) the address; for EVM-based chains, when \"counterAddress\" is present, the amount is always positive\n  \"tokenId\": \"1\", // (ERC-721 / ERC-1155 only) the ID of the transferred token\n  \"type\": \"token\", // the type of the transaction; can be either \"native\" or \"token\"\n  \"mempool\": true, // (EMV-based blockchains only) if appears and set to \"true\", the transaction is in the mempool; if set to \"false\" or does not appear at all, the transaction has been added to a block\n  \"counterAddress\": undefined // an optional counter party address of the transaction; for EVM-based blockchains, this is the recipient's address\n  \"addressesRiskRatio\": [ // (optional, subject to change; for Solana mainnet only) risk levels assigned to the addresses with which the address communicated within the transaction; the addresses are assessed using the AML/CFT solution by blockmate.io, see https://docs.blockmate.io/docs/risk-API/sources\n    {\"vTEfAhXTmvgFmepgfhzBbRrJ4EtUP9adbMJjpzLsDMk\": 0},\n    {\"zBbRrJ4EtUP9adbMJjpzLsDMkvTEfAhXTmvgFmepgfh\": 100}\n  ]\n}</pre>\n<b>5 credits are debited for each fired web hook.</b><br/></li>\n<li><b>CONTRACT_NFT_TXS_PER_BLOCK</b> - Enable HTTP POST JSON notifications for any event of minting, transferring, or burning an NFT that was emitted from any smart contract. This notification is fired as a batch notification per block: it includes all NFT minting, transferring, or burning events from all smart contracts that got recorded into a block.<br/>\nFree community plans can monitor 1 event across all blockchains per plan.<br/><br/>\nThe following table describes the availability of this notification type on different blockchains and the credit consumption:<br/>\n<table>\n  <tr>\n    <th>Chain</th>\n    <th>Available chains (the \"chain\" parameter in the response payload)</th>\n    <th>Credit consumption / day</th>\n  </tr>\n  <tr>\n    <td>Ethereum</td>\n    <td>ethereum-sepolia / ethereum-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Polygon</td>\n    <td>polygon-mumbai / polygon-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Celo</td>\n    <td>celo-testnet / celo-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Klaytn</td>\n    <td>klaytn-baobab / klaytn-cypress</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>BNB Smart Chain</td>\n    <td>bsc-testnet / bsc-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n</table>\nThe request body of the POST request is a JSON object with the following structure:<br/>\n<pre>{\n \"events\": [\n   {\n     \"timestamp\": 1661961758000,\n     \"from\": \"0x0000000000000000000000000000000000000000\",\n     \"to\": \"0xfa4e7035b34294407e5df1603215983d65e5a773\",\n     \"tokenId\": \"14671\",\n     \"txId\": \"0x916fcf878656f7a3772317697e6d2740ac8b1b7dbe6d029aa79592fd72f3fb0b\",\n     \"contractAddress\": \"0x55a2430e32dcebc3649120f26f917d1f0686f74c\",\n     \"type\": \"erc721\",\n     \"amount\": \"1\",\n     \"logIndex\": 578,\n     \"metadataURI\": \"https://graphigo.prd.galaxy.eco/metadata/0x55a2430e32dcebc3649120f26f917d1f0686f74c/14671.json\"\n   }\n ],\n \"blockNumber\": 32522207,\n \"chain\": \"polygon-mainnet\",\n \"subscriptionType\": \"CONTRACT_NFT_TXS_PER_BLOCK\"\n }</pre>\n<b>1 credit is debited for each fired web hook.</b><br/></li>\n<li><b>CONTRACT_MULTITOKEN_TXS_PER_BLOCK</b> - Enable HTTP POST JSON notifications for any event of minting, transferring, or burning a Multi-Token that was emitted from any smart contract. This notification is fired as a batch notification per block: it includes all Multi Token minting, transferring, or burning events from all smart contracts that got recorded into a block.<br/>\nFree community plans can monitor 1 event across all blockchains per plan.<br/><br/>\nThe following table describes the availability of this notification type on different blockchains and the credit consumption:<br/>\n<table>\n  <tr>\n    <th>Chain</th>\n    <th>Available chains (the \"chain\" parameter in the response payload)</th>\n    <th>Credit consumption / day</th>\n  </tr>\n  <tr>\n    <td>Ethereum</td>\n    <td>ethereum-sepolia / ethereum-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Polygon</td>\n    <td>polygon-mumbai / polygon-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Celo</td>\n    <td>celo-testnet / celo-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Klaytn</td>\n    <td>klaytn-baobab / klaytn-cypress</td>\n    <td>500,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>BNB Smart Chain</td>\n    <td>bsc-testnet / bsc-mainnet</td>\n    <td>500,000 credits / day</td>\n  </tr>\n</table>\nThe request body of the POST request is a JSON object with the following structure:<br/>\n<pre>{\n \"events\": [\n   {\n     \"timestamp\": 1661961758000,\n     \"from\": \"0x85bd970cf0e49acd572f9c2d608713bc55b5ee0e\",\n     \"to\": \"0x9ab31230d5413e4af01af9bb697651a3c70c95c9\",\n     \"tokenId\": \"1450000023306\",\n     \"txId\": \"0x565b9ca6b7b5ff1b1ce0725acd785dbf5ff0930d5ff547bad044c0960291555f\",\n     \"contractAddress\": \"0xdb6290f355a528a7284bdd528b05a78fb05226ca\",\n     \"type\": \"erc1155\",\n     \"amount\": \"1\",\n     \"logIndex\": 571,\n     \"metadataURI\": \"https://touhao.bj.bcebos.com/nft/metadata/1450000023306.json\"\n   }\n ],\n \"blockNumber\": 32522207,\n \"chain\": \"polygon-mainnet\",\n \"subscriptionType\": \"CONTRACT_MULTITOKEN_TXS_PER_BLOCK\"\n}</pre>\n<b>1 credit is debited for each fired web hook.</b><br/></li>\n<li><b>CONTRACT_LOG_EVENT</b> - Enable HTTP POST JSON notifications for any event that was emitted from any smart contract. This notification is fired as a batch notification per block: it includes all events from all smart contracts that got recorded into a block.<br/>\nFree community plans can monitor 1 event across all blockchains per plan.<br/><br/>\nThe following table describes the availability of this notification type on different blockchains and the credit consumption:<br/>\n<table>\n  <tr>\n    <th>Chain</th>\n    <th>Available chains (the \"chain\" parameter in the response payload)</th>\n    <th>Credit consumption / day</th>\n  </tr>\n  <tr>\n    <td>Ethereum</td>\n    <td>ethereum-sepolia / ethereum-mainnet</td>\n    <td>50,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Polygon</td>\n    <td>polygon-mumbai / polygon-mainnet</td>\n    <td>50,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Celo</td>\n    <td>celo-testnet / celo-mainnet</td>\n    <td>50,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>Klaytn</td>\n    <td>klaytn-baobab / klaytn-cypress</td>\n    <td>50,000 credits / day</td>\n  </tr>\n  <tr>\n    <td>BNB Smart Chain</td>\n    <td>bsc-testnet / bsc-mainnet</td>\n    <td>50,000 credits / day</td>\n  </tr>\n</table>\nThe request body of the POST request is a JSON object with the following structure:<br/>\n<pre>{\n \"events\": [\n   {\n     \"txId\": \"0xc98307f09ed527d5cff8305e8f65226b790e3317ded10b9e58f6f07286dcf8f1\",\n     \"logIndex\": 326,\n     \"timestamp\": 1661774265000,\n     \"address\": \"0xc2132d05d31c914a87c6611c10748aeb04b58e8f\",\n     \"topic_0\": \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n     \"topic_1\": \"0x000000000000000000000000a91ab7d77892a559d2a95baaf1d748fc97c65d29\",\n     \"topic_2\": \"0x0000000000000000000000009b08288c3be4f62bbf8d1c20ac9c5e6f9467d8b7\",\n     \"topic_3\": null,\n     \"data\": \"0x0000000000000000000000000000000000000000000000000000000002c9e3e4\"\n   }\n ],\n \"blockNumber\": 32447538,\n \"chain\": \"polygon-mumbai\",\n \"subscriptionType\": \"CONTRACT_LOG_EVENT\"\n}</pre>\n<b>1 credit is debited for each fired web hook.</b><br/></li>\n<li><b>ACCOUNT_INCOMING_BLOCKCHAIN_TRANSACTION</b> - Enable HTTP POST JSON notifications about incoming blockchain transactions on virtual accounts.\nThis web hook is invoked when an incoming transaction is reflected on the balance of the virtual account (the balance is credited with the transaction amount). This happens when the transaction has the sufficient number of blockchain confirmations: two confirmations for BTC, LTC, BCH, and DOGE, and one confirmation for the other blockchains.<br/>\nThe request body of the POST request is a JSON object with the following structure:\n<pre>{\n  \"date\": 1619176527481,\n  \"amount\": \"0.005\",\n  \"currency\": \"BTC\",\n  \"accountId\": \"6082ab462936b4478117c6a0\",\n  \"reference: \"c9875708-4ba3-41c9-a4cd-271048b41b9a\", // the reference of the transaction in the virtual account\n  \"txId\": \"45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\",\n  \"blockHash\": \"45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\", // the hash of the block, might not be present every time\n  \"blockHeight\": 12345,\n  \"from\": \"SENDER_ADDRESS\", // might not be present every time; not present for UTXO-based blockchains\n  \"to\": \"RECIPIENT_ADDRESS_CONNECTED_TO_LEDGER_ACCOUNT\", // the blockchain address of the recipient\n  \"index\": 5 // for UTXO-based blockchains (BCH, BTC, DOGE, LTC), this is the index of the output in the transaction\n}</pre>\n1 credit is debited for each monitored account every day.</li>\n<li><b>ACCOUNT_PENDING_BLOCKCHAIN_TRANSACTION</b> - Enable HTTP POST JSON notifications about incoming blockchain transactions on virtual accounts.<br />\nThis web hook is supported only for BCH, BTC, DOGE, ETH, and LTC accounts.<br />\n- For <b>BTC-based blockchains</b> (BCH, BTC, DOGE, and LTC), this web hook is invoked when an incoming transaction appears in a block for the first time. At that time, the transaction has one confirmation but this is not enough for the transaction to be reflected on the balance of the virtual account yet. Instead, a deposit corresponding to the pending transaction with a status of \"in progress\" appears on the virtual account. Once the transaction is added to the block, the deposit's status changes to \"done\", and the account balance gets updated.<br />\n- For <b>EMV-based blockchains</b> (ETH), this web hook is invoked when an incoming transaction appears in the mempool. The virtual account balance is not updated until the transaction is added to a block. Instead, a deposit corresponding to the pending transaction with a status of \"in progress\" appears on the virtual account. Once the transaction is added to the block, the deposit's status changes to \"done\", and the account balance gets updated.<br />\nThe request body of the POST request is a JSON object with the following structure:<br/>\n<pre>{\n  \"date\": 1619176527481,\n  \"amount\": \"0.005\",\n  \"currency\": \"BTC\",\n  \"accountId\": \"6082ab462936b4478117c6a0\",\n  \"reference: \"c9875708-4ba3-41c9-a4cd-271048b41b9a\", // the reference of the transaction in the virtual account\n  \"txId\": \"45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\",\n  \"blockHash\": \"45af182a0ffab58e5ba32fee57b297b2260c6e23a1de5ddc76c7ee22d72dea99\", // the hash of the block, might not be present every time; if set to \"null\", the transaction is in the mempool (for EMV-based blockchains)\n  \"blockHeight\": 12345, // if set to \"null\", the transaction is in the mempool (for EMV-based blockchains)\n  \"from\": \"SENDER_ADDRESS\", // might not be present every time; not present for UTXO-based blockchains (BCH, BTC, DOGE, LTC)\n  \"to\": \"RECIPIENT_ADDRESS_CONNECTED_TO_LEDGER_ACCOUNT\", // the blockchain address of the recipient\n  \"index\": 5 // for UTXO-based blockchains (BCH, BTC, DOGE, LTC), this is the index of the output in the transaction\n}</pre>\n1 credit is debited for each monitored account every day.</li>\n<li><b>CUSTOMER_TRADE_MATCH</b> - Enable HTTP POST JSON notifications on closed trade, which occurs on any customer account.\nThis web hook will be invoked, when the open trade is filled and closed. Works also for the Trade Futures. If is triggered by the futures, bool field expiredWithoutMatch is present.\nRequest body of the POST request will be JSON object with attributes:<br/>\n<pre>{\n  \"created\": 1619176527481,\n  \"amount\": \"0.005\",\n  \"price\": \"0.02\",\n  \"type\": \"SELL\",\n  \"pair\": \"VC_CHF/VC_CHF3\",\n  \"id\": \"6082ab462936b4478117c6a0\", // id of the trade\n  \"currency1AccountId\": \"6082ab462936b4478117c6a0\",\n  \"currency2AccountId\": \"6082ab512936b4478117c6a2\",\n  \"fee\": null,\n  \"feeAccountId\": null,\n  \"isMaker\": true,\n  \"expiredWithoutMatch\": false\n}</pre>\n10 credits will be debited for every monitored customer every day.</li>\n<li><b>CUSTOMER_PARTIAL_TRADE_MATCH</b> - Enable HTTP POST JSON notifications on partialy filled trade, which occurs on any customer account.\nThis web hook will be invoked, when the open trade is partialy filled.\nRequest body of the POST request will be JSON object with attributes:<br/>\n<pre>{\n  \"created\": 1619176527481,\n  \"amount\": \"0.005\",\n  \"orderAmount\": \"0.1\",\n  \"price\": \"0.02\",\n  \"type\": \"SELL\",\n  \"pair\": \"VC_CHF/VC_CHF3\",\n  \"id\": \"6082ab462936b4478117c6a0\", // id of the trade\n  \"currency1AccountId\": \"6082ab462936b4478117c6a0\",\n  \"currency2AccountId\": \"6082ab512936b4478117c6a2\",\n  \"fee\": null,\n  \"feeAccountId\": null,\n  \"isMaker\": true,\n  \"expiredWithoutMatch\": false\n}</pre>\n10 credits will be debited for every monitored customer every day.</li>\n<li><b>TRANSACTION_IN_THE_BLOCK</b> - Enable HTTP POST JSON notifications on ledger => blockchain transaction, when transaction is included in the block.\nThis web hook will be invoked, when the outgoing transaction is included in the block.\nRequest body of the POST request will be JSON object with attributes:<br/>\n<pre>\n  {\n    \"txId\": \"0x026f4f05b972c09279111da13dfd20d8df04eff436d7f604cd97b9ffaa690567\",\n    \"reference\": \"90270634-5b07-4fad-b17b-f82899953533\",\n    \"accountId\": \"6086ed0744c45b24d4fbd039\",\n    \"currency\": \"BSC\",\n    \"withdrawalId\": \"608fe5b73a893234ba379ab2\",\n    \"address\": \"0x8ce4e40889a13971681391AAd29E88eFAF91f784\",\n    \"amount\": \"0.1\",\n    \"blockHeight\": 8517664\n  }</pre>\n10 credits will be debited every day, 1 credit for every included transaction notified via web hook.</li>\n<li><b>KMS_FAILED_TX</b> - Enable HTTP POST JSON notifications on error during KMS signature process.\nThis web hook will be invoked, when the Tatum KMS receives error during processing transactions.\nRequest body of the POST request will be JSON object with attributes:<br/>\n<pre>{\n  \"signatureId\": \"6082ab462936b4478117c6a0\",\n  \"error\": \"Error message from the KMS\"\n}</pre>\n10 credits will be debited every day.</li>\n<li><b>KMS_COMPLETED_TX</b> - Enable HTTP POST JSON notifications on successful completion of KMS signature process.\nThis web hook will be invoked, when the Tatum KMS successfully completes the signature during processing transactions.\nRequest body of the POST request will be JSON object with attributes:<br/>\n<pre>{\n  \"signatureId\": \"6082ab462936b4478117c6a0\",\n  \"txId\": \"0x7bb7d3b90567e89f999f2e3d263bc3738a018dbbcfa9f5397678cf17cdf0235f\"\n}</pre>\n10 credits will be debited every day.</li>\n<li><b>ACCOUNT_BALANCE_LIMIT</b> - Report with all account balances above desired limit.</li>\n<li><b>TRANSACTION_HISTORY_REPORT</b> - Report with all ledger transactions for last X hours, where X is set by the subscription attribute as interval.\nMaximum number of transactions returned by this report is 20000. Transactions are obtained from the time of the invocation of the GET method to obtain report - X hours.</li>\n</ul>\nIn case of unsuccesful web hook response status - other then 2xx - web hook is repeated 9 more times with exponential backoff.\nParameters are T = 15 * 2.7925^9, where 15 is interval in s, backoff rate is 2.7925 and 9 is current number of retries. Last web hook is fired after 24 hours approximatelly. After last failed attempt, web hook is deleted from our system. The 2xx response must be returned in 10 seconds after web hook is fired.<br/>\nResult of the operation is subscription ID, which can be used to cancel subscription or obtain additional data connected to it like reports.</p>\n",
        "operationId": "createSubscription",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to ethereum-sepolia.",
            "in": "query",
            "name": "testnetType",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": ["ethereum-sepolia", "ethereum-goerli"]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CreateSubscriptionNotification" },
                  { "$ref": "#/components/schemas/CreateSubscriptionNftTransferEvent" },
                  { "$ref": "#/components/schemas/CreateSubscriptionMultiTokenTransferEvent" },
                  { "$ref": "#/components/schemas/CreateSubscriptionContractLogEvent" },
                  { "$ref": "#/components/schemas/CreateSubscriptionIncoming" },
                  { "$ref": "#/components/schemas/CreateSubscriptionPending" },
                  { "$ref": "#/components/schemas/CreateSubscriptionTradeMatch" },
                  { "$ref": "#/components/schemas/CreateSubscriptionPartialTradeMatch" },
                  { "$ref": "#/components/schemas/CreateSubscriptionKMSError" },
                  { "$ref": "#/components/schemas/CreateSubscriptionKMSSuccess" },
                  { "$ref": "#/components/schemas/CreateSubscriptionTxInTheBlock" },
                  { "$ref": "#/components/schemas/CreateSubscriptionBalance" },
                  { "$ref": "#/components/schemas/CreateSubscriptionInterval" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Id" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403SubscriptionType" },
                    { "$ref": "#/components/schemas/Error403SubscriptionCurrency" },
                    { "$ref": "#/components/schemas/Error403SubscriptionBalance" },
                    { "$ref": "#/components/schemas/Error403SubscriptionInterval" },
                    { "$ref": "#/components/schemas/Error403SubscriptionId" },
                    { "$ref": "#/components/schemas/Error403SubscriptionPendingId" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create a subscription",
        "tags": ["Notification subscriptions"]
      },
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all active subscriptions.</p>",
        "operationId": "getSubscriptions",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Value for filtering by address",
            "in": "query",
            "name": "address",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Subscription" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all active subscriptions",
        "tags": ["Notification subscriptions"]
      },
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Enable HMAC hash ID on the fired webhooks from Tatum API.\nIn order to make sure that a webhook is sent by us, we have the possibility to sign it with the HMAC Sha512 Hex algorithm.<br/>\nTo verify that a webhook is sent by us\n<ol>\n<li>Get a webhook <b>x-payload-hash</b> header value and payload as it is as a JSON file.</li>\n<li>Convert the HTTP webhook body to stringify JSON without any spaces. In JavaScript, you would do it like this <pre>JSON.stringify(req.body)</pre></li>\n<li>Perform calculations on your side to create a digest using Secret Key, webhook payload in bytes and HMAC SHA512 algorithm. JavaScript example:\n<pre>require('crypto').createHmac('sha512', hmacSecret).update(JSON.stringify(req.body)).digest('base64')</pre>.</li>\n<li>Compare x-payload-hash header value with calculated digest as a Base64 string.</li></p>\n",
        "operationId": "enableWebHookHmac",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HmacWebHook" } } },
          "required": true
        },
        "responses": {
          "204": { "description": "OK" },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Enable HMAC webhook digest",
        "tags": ["Notification subscriptions"]
      },
      "delete": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Disable HMAC hash ID on the fired webhooks from Tatum API.</p>\n",
        "operationId": "disableWebHookHmac",
        "responses": {
          "204": { "description": "OK" },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Disable HMAC webhook digest",
        "tags": ["Notification subscriptions"]
      }
    },
    "/v3/subscription/count": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Count of subscriptions that were found from /v3/subscription</p>",
        "operationId": "getSubscriptionsCount",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Value for filtering by address",
            "in": "query",
            "name": "address",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EntitiesCount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Count of found entities for get webhook request",
        "tags": ["Notification subscriptions"]
      }
    },
    "/v3/subscription/{id}": {
      "delete": {
        "description": "<h4>1 credit for API call</h4><br/><p>Cancel existing subscription.</p>",
        "parameters": [
          {
            "description": "Subscription ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "operationId": "deleteSubscription",
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Cancel existing subscription",
        "tags": ["Notification subscriptions"]
      }
    },
    "/v3/subscription/report/{id}": {
      "get": {
        "description": "<h4>1 credit for API call. Based on the required report type, additional credits may be charged.</h4><br/>\n<p>Obtain report from subscription based on its type. Following reports are supported:\n<ul>\n<li><b>ACCOUNT_BALANCE_LIMIT</b> - obtain list of all ledger accounts with account balance above the limit. 1 credit per 50 returned records is charged.</li>\n<li><b>TRANSACTION_HISTORY_REPORT</b> - obtain list of all ledger transaction for last X hours from the time of invocation. 1 credit per 50 returned records is charged.</li>\n</ul></p>\n",
        "parameters": [
          {
            "description": "Subscription ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "operationId": "getSubscriptionReport",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "items": { "$ref": "#/components/schemas/Account" }, "type": "array" },
                    { "items": { "$ref": "#/components/schemas/Transaction" }, "type": "array" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403SubscriptionNotExists" },
                    { "$ref": "#/components/schemas/Error403ReportNotAvailable" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Obtain report for subscription",
        "tags": ["Notification subscriptions"]
      }
    },
    "/v3/subscription/webhook": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>List all webhooks.</p>",
        "operationId": "getAllWebhooks",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Direction of sorting",
            "in": "query",
            "name": "direction",
            "schema": { "type": "string", "enum": ["asc", "desc"], "example": "asc" }
          },
          {
            "description": "Flag indicating whether the webhook was successful or not",
            "in": "query",
            "name": "failed",
            "schema": { "type": "boolean", "example": false }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/WebHook" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "List all executed webhooks",
        "tags": ["Notification subscriptions"]
      }
    },
    "/v3/subscription/webhook/count": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Count of webhooks that were found from /v3/subscription/webhook</p>",
        "operationId": "getAllWebhooksCount",
        "parameters": [
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Direction of sorting",
            "in": "query",
            "name": "direction",
            "schema": { "type": "string", "example": "asc", "enum": ["asc", "desc"] }
          },
          {
            "description": "Flag indicating whether the webhook was successful or not",
            "in": "query",
            "name": "failed",
            "schema": { "type": "boolean", "example": false }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EntitiesCount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Count of found entities for get webhook request",
        "tags": ["Notification subscriptions"]
      }
    },
    "/v3/offchain/account/{id}/address": {
      "post": {
        "description": "<p><b>2 credits per API call<br/>\nOn Flow, additional 3000 credits are consumed for <a href=\"https://apidoc.tatum.io/tag/Flow#operation/FlowGenerateAddress\" target=\"_blank\">each created address</a>.</b></p>\n<p>Create a deposit address associated with a virtual account.</p>\n<p>You can create multiple deposit addresses for one virtual account. When you have multiple deposit addresses created for the same virtual account, you aggregate various blockchain transactions from different addresses under a single account.<br/>You can deposit funds from another blockchain address to a deposit address associated with the virtual account, and the funds will be credited to that virtual account.</p>\n<p><b>Scanning for incoming deposits</b></p>\n<p>By default, deposit addresses are scanned for incoming deposits. Deposit addresses are automatically synchronized with the associated virtual account, and you can see incoming deposits on the virtual account.<br/>Scanning deposit addresses for incoming deposits consumes <b>20 credits per address per day</b>.</p>\n<p>If you want to be notified about certain events occurring on the deposit addresses, <a href=\"https://apidoc.tatum.io/tag/Notification-subscriptions#operation/createSubscription\" target=\"_blank\">subscribe for notifications</a>.</p>\n<p><b>Virtual account cryptocurrency</b></p>\n<p>Depending on the cryptocurrency of the virtual account, this API generates:<p>\n<ul>\n<li><b>Public address</b> for BTC, BCH, ETH, or LTC</li>\n<li><b>DestinationTag</b> for XRP</li>\n<li><b>Message</b> for XLM</li>\n</ul>\n<p>For fore information about supported blockchains and address types, see the <a href=\"https://apidoc.tatum.io/tag/Account#operation/createAccount\" target=\"_blank\">API for creating virtual accounts</a>.</p>\n<p>Deposit addresses are generated in the natural order of the extended public key provided in the virtual account. The derivation index is the representation of that order; it starts from 0 and ends at 2^31.</p>\n<p>When a new deposit address is generated, the last not used index is used to generate the address. You can skip some addresses to a different index, which means all the skipped addresses will no longer be used.</p>\n",
        "operationId": "generateDepositAddress",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "<p>Derivation path index for specific address. If not present, last used index for given xpub of account + 1 is used. We recommend not to pass this value manually, since when some of the indexes are skipped, it is not possible to use them lately to generate address from it.</p>",
            "in": "query",
            "name": "index",
            "schema": { "type": "number", "example": 2 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Address" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create a deposit address for a virtual account",
        "tags": ["Blockchain addresses"]
      },
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get all deposit addresses generated for a virtual account.</p>\n",
        "operationId": "getAllDepositAddresses",
        "parameters": [
          {
            "description": "The ID of the virtual account to get deposit addresses for",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Address" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get all deposit addresses for a virtual account",
        "tags": ["Blockchain addresses"]
      }
    },
    "/v3/offchain/account/address/batch": {
      "post": {
        "description": "<p><b>2 credits per API call + 1 credit for each created address<br/>\nOn Flow, additional 3000 credits are consumed for <a href=\"https://apidoc.tatum.io/tag/Flow#operation/FlowGenerateAddress\" target=\"_blank\">each created address</a>.</b></p>\n<p>Create multiple deposit addresses associated with a virtual account.</p>\n<p>When you have multiple deposit addresses created for the same virtual account, you aggregate various blockchain transactions from different addresses under a single account.<br/>You can deposit funds from another blockchain address to a deposit address associated with the virtual account, and the funds will be credited to that virtual account.</p>\n<p><b>Scanning for incoming deposits</b></p>\n<p>By default, deposit addresses are scanned for incoming deposits. Deposit addresses are automatically synchronized with the associated virtual account, and you can see incoming deposits on the virtual account.<br/>Scanning deposit addresses for incoming deposits consumes <b>20 credits per address per day</b>.</p>\n<p>If you want to be notified about certain events occurring on the deposit addresses, <a href=\"https://apidoc.tatum.io/tag/Notification-subscriptions#operation/createSubscription\" target=\"_blank\">subscribe for notifications</a>.</p>\n<p><b>Virtual account cryptocurrency</b></p>\n<p>Depending on the cryptocurrency of the virtual account, this API generates:<p>\n<ul>\n<li><b>Public address</b> for BTC, BCH, ETH, or LTC</li>\n<li><b>DestinationTag</b> for XRP</li>\n<li><b>Message</b> for XLM</li>\n</ul>\n<p>For fore information about supported blockchains and address types, see the <a href=\"https://apidoc.tatum.io/tag/Account#operation/createAccount\" target=\"_blank\">API for creating virtual accounts</a>.</p>\n<p>Deposit addresses are generated in the natural order of the extended public key provided in the virtual account. The derivation index is the representation of that order; it starts from 0 and ends at 2^31.</p>\n<p>When a new deposit address is generated, the last not used index is used to generate the address. You can skip some addresses to a different index, which means all the skipped addresses will no longer be used.</p>\n",
        "operationId": "generateDepositAddressesBatch",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/OffchainAddresses" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/Address" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create multiple deposit addresses for a virtual account",
        "tags": ["Blockchain addresses"]
      }
    },
    "/v3/offchain/account/address/{address}/{currency}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Check whether a blockchain address with the specified cryptocurrency is registered within Tatum and is assigned to a virtual account (that is, whether this blockchain address is a deposit address associated with the virtual account).</p>\n<p>If the blockchain address is assigned to a virtual account, information about this account is returned. Otherwise, an error message is returned.</p>\n",
        "operationId": "addressExists",
        "parameters": [
          {
            "description": "The cryptocurrency of the blockchain address to check",
            "in": "path",
            "name": "currency",
            "required": true,
            "schema": { "type": "string", "example": "BNB" }
          },
          {
            "description": "The blockchain address to check",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "example": "tbnb1sfj9981j2eo1ij2e09", "type": "string" }
          },
          {
            "description": "In case of XLM or XRP, this is a memo or DestinationTag to search for.",
            "in": "query",
            "name": "index",
            "required": false,
            "schema": { "example": 1, "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Account" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Check whether a blockchain address is assigned to a virtual account",
        "tags": ["Blockchain addresses"]
      }
    },
    "/v3/offchain/account/{id}/address/{address}": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Assign an existing blockchain address to a virtual account. The blockchain address becomes a deposit address associated with this account.</br>Use this API when the <a href=\"https://apidoc.tatum.io/tag/Account#operation/createAccount\" target=\"_blank\">virtual account has no default extended public key</a> (<code>xpub</code>) and deposit addresses are handled manually.</p>\n<p>You can assign multiple blockchain addresses to one virtual account. When you have multiple blockchain addresses assigned to the same virtual account, you aggregate various blockchain transactions from different addresses under a single account.<br/>You can deposit funds from another blockchain address to a deposit address associated with the virtual account, and the funds will be credited to that virtual account.</p>\n<p><b>Scanning for incoming deposits</b></p>\n<p>By default, deposit addresses are scanned for incoming deposits. Deposit addresses are automatically synchronized with the associated virtual account, and you can see incoming deposits on the virtual account.<br/>Scanning deposit addresses for incoming deposits consumes <b>20 credits per address per day</b>.</p>\n<p>If you want to be notified about certain events occurring on the deposit addresses, <a href=\"https://apidoc.tatum.io/tag/Notification-subscriptions#operation/createSubscription\" target=\"_blank\">subscribe for notifications</a>.</p>\n",
        "operationId": "assignAddress",
        "parameters": [
          {
            "description": "The ID of the virtual account to assign a blockchain address to",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "The blockchain address to assign to the virtual account",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "2MsM67NLa71fHvTUBqNENW15P68nHB2vVXb" }
          },
          {
            "description": "Destination tag or memo attribute for XRP or XLM addresses",
            "in": "query",
            "name": "index",
            "required": false,
            "schema": { "type": "number", "minimum": 1, "example": 1 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Address" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Assign a blockchain address to a virtual account",
        "tags": ["Blockchain addresses"]
      },
      "delete": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Remove a deposit address from the virtual account.</p>\n<p>The deposit address will no longer be scanned for incoming deposits. You will no longer be able to generate this address again.</p>\n",
        "operationId": "removeAddress",
        "parameters": [
          {
            "description": "Account ID",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "example": "5e68c66581f2ee32bc354087" }
          },
          {
            "description": "Blockchain address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "2MsM67NLa71fHvTUBqNENW15P68nHB2vVXb" }
          },
          {
            "description": "Destination tag or memo attribute for XRP, BNB or XLM addresses",
            "in": "query",
            "name": "index",
            "required": false,
            "schema": { "type": "number", "minimum": 1, "example": 1 }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403AccountNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Remove a deposit address from a virtual account",
        "tags": ["Blockchain addresses"]
      }
    },
    "/v3/offchain/withdrawal": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/><p>\n<p>Create a withdrawal from Tatum Ledger account to the blockchain.<br/>\n  <h4>BTC, LTC, DOGE, BCH</h4>\n  <p>\n    When withdrawal from Tatum is executed, all deposits, which are not processed yet are used as an input and\n    change is moved to pool address 0 of wallet for defined account's xpub. If there are no unspent deposits, only last pool address 0 UTXO is used.\n    If balance of wallet is not sufficient, it is impossible to perform withdrawal from this account -> funds were transferred to another\n    linked wallet within system or outside of Tatum visibility.<br/>\n    For the first time of withdrawal from wallet, there must be some deposit made and funds are obtained from that. Since\n    there is no withdrawal, there was no transfer to pool address 0 and thus it is not present in vIn. Pool transfer is identified by missing data.address property in response.\n    When last not cancelled withdrawal is not completed and thus there is no tx id of output transaction given,\n    we cannot perform next withdrawal.\n  </p>\n  <h4>ETH</h4>\n  <p>\n    Withdrawal from Tatum can be processed only from 1 account. In Ethereum Blockchain, each address is recognized as an account and only funds from that account can be sent in 1 transaction.\n    Example: Account A has 0.5 ETH, Account B has 0.3 ETH. Account A is linked to Tatum Account 1, Account B is linked to Tatum Account 2. Tatum Account 1 has balance 0.7 Ethereum and\n    Tatum Account 2 has 0.1 ETH. Withdrawal from Tatum Account 1 can be at most 0.5 ETH, even though balance in Tatum Private Ledger is 0.7 ETH.\n    Because of this Ethereum Blockchain limitation, withdrawal request should always contain sourceAddress, from which withdrawal will be made. To get available balances for Ethereum wallet accounts, use hint endpoint.\n  </p>\n  <h4>XRP</h4>\n  <p>\n    XRP withdrawal can contain DestinationTag except of address, which is placed in attr parameter of withdrawal request.\nSourceTag of the blockchain transaction should be withdrawal ID for autocomplete purposes of withdrawals.\n  </p>\n  <h4>XLM</h4>\n  <p>\n    XLM withdrawal can contain memo except of address, which is placed in attr parameter of withdrawal request. XLM blockchain does not have possibility to enter source account information.\n    It is possible to create memo in format 'destination|source', which is supported way of memo in Tatum and also there is information about the sender account in the blockchain.\n  </p>\n<br/>\nWhen withdrawal is created, all other withdrawals with the same currency are pending, unless the current one is marked as complete or cancelled.<br/>\nTatum ledger transaction is created for every withdrawal request with operation type WITHDRAWAL. The value of the transaction is the withdrawal amount + blockchain fee, which should be paid.\nIn the situation, when there is withdrawal for ERC20, XLM, or XRP based custom assets, the fee is not included in the transaction because it is paid in different assets than the withdrawal itself.\n</p>\n",
        "operationId": "storeWithdrawal",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Withdrawal" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/WithdrawalResponse" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtcOffchain" },
                    { "$ref": "#/components/schemas/Error403TxAmountEthOffchain" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Store withdrawal",
        "tags": ["Withdrawal"]
      },
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get withdrawals.</p>",
        "operationId": "GetWithdrawals",
        "parameters": [
          {
            "description": "Currency of the withdrawal",
            "in": "query",
            "name": "currency",
            "schema": { "minLength": 2, "maxLength": 30, "type": "string", "example": "BTC" }
          },
          {
            "description": "Status of the withdrawal",
            "in": "query",
            "name": "status",
            "schema": { "type": "string", "example": "Done", "enum": ["InProgress", "Done", "Cancelled"] }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/WithdrawalObject" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get withdrawals",
        "tags": ["Withdrawal"]
      }
    },
    "/v3/offchain/withdrawal/{id}/{txId}": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Invoke complete withdrawal as soon as blockchain transaction ID is available. All other withdrawals for the same currency will be pending unless the last one is processed and marked as completed.</p>\n",
        "operationId": "completeWithdrawal",
        "parameters": [
          {
            "description": "ID of created withdrawal",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 50, "minLength": 10 }
          },
          {
            "description": "Blockchain transaction ID of created withdrawal",
            "in": "path",
            "name": "txId",
            "required": true,
            "schema": { "type": "string", "maxLength": 80, "minLength": 10 }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403OffchainBroadcastState" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Complete withdrawal",
        "tags": ["Withdrawal"]
      }
    },
    "/v3/offchain/withdrawal/{id}": {
      "delete": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>This method is helpful if you need to cancel the withdrawal if the blockchain transaction fails or is not yet processed.\nThis does not cancel already broadcast blockchain transaction, only Tatum internal withdrawal, and the ledger transaction, that was linked to this withdrawal.<br/>\nBy default, the transaction fee is included in the reverted transaction. There are situations, like sending ERC20 on ETH, TRC token on TRON, XLM or XRP based assets, when the fee should not be reverted, because e.g. the fee is in calculated\nin Ethereum and transaction was in ERC20 currency. In this situation, only the transaction amount should be reverted, not the fee.\n</p>\n",
        "operationId": "cancelInProgressWithdrawal",
        "parameters": [
          {
            "description": "ID of created withdrawal",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": { "type": "string", "maxLength": 24, "minLength": 24 }
          },
          {
            "description": "Defines whether fee should be reverted to account balance as well as amount. Defaults to true. Revert true would be typically used when withdrawal was not broadcast to blockchain. False is used usually for Ethereum based currencies when gas was consumed but transaction was reverted.",
            "in": "query",
            "name": "revert",
            "required": false,
            "schema": { "default": true, "example": true, "type": "boolean" }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403WithdrawalCancelled" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Cancel withdrawal",
        "tags": ["Withdrawal"]
      }
    },
    "/v3/offchain/withdrawal/broadcast": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Broadcast signed raw transaction end complete withdrawal associated with it.\nWhen broadcast succeeded but it is impossible to complete withdrawal, transaction id of transaction is returned and withdrawal must be completed manually.\n</p>\n",
        "operationId": "broadcastBlockchainTransaction",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastWithdrawal" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastResponse" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403OffchainBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403OffchainBroadcastState" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed transaction and complete withdrawal",
        "tags": ["Withdrawal"]
      }
    },
    "/v3/offchain/blockchain/estimate": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate current transaction fee for ledger to blockchain transaction.<br/>\nSupported blockchains:\n<ul>\n<li>Bitcoin</li>\n<li>Litecoin</li>\n<li>Dogecoin</li>\n</ul>\n</p>\n",
        "operationId": "offchainEstimateFee",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/OffchainEstimateFee" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "headers": {
              "x-current-block": {
                "schema": { "type": "number" },
                "description": "Current block of the blockchain."
              },
              "x-current-block-time": {
                "schema": { "type": "string", "format": "date-time", "example": "2021-11-11T11:54:49.000Z" },
                "description": "Current block time."
              }
            },
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FeeBtc" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Estimate ledger to blockchain transaction fee",
        "tags": ["Virtual account blockchain fees"]
      }
    },
    "/v3/offchain/bitcoin/transfer": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Send BTC (Bitcoin) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Bitcoin server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits\nwhich are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li>\n<li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis method is a helper method, which internally wraps these steps:\n<ol>\n<li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li>\n<li><a href=\"#operation/BtcTransferBlockchain\">Perform blockchain transaction</a> - </li>\n<li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li>\n</ol>\nWhen some of the steps fails, <a href=\"#operation/cancelInProgressWithdrawal\">Cancel withdrawal</a> operation is used, which cancels withdrawal and creates refund transaction to the sender account.</li>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "BtcTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferBtcMnemonic" },
                  { "$ref": "#/components/schemas/TransferBtcKeyPair" },
                  { "$ref": "#/components/schemas/TransferBtcKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcMnemonicTxFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403BtcTxUtxoFailed" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" },
                    { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtcOffchain" },
                    { "$ref": "#/components/schemas/Error403TxAmountEthOffchain" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BTC from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/bcash/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Send BCH (Bitcoin Cash) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Bitcoin Cash server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits\nwhich are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li>\n<li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis method is a helper method, which internally wraps these steps:\n<ol>\n<li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li>\n<li><a href=\"#operation/BchTransferBlockchain\">Perform blockchain transaction</a> - </li>\n<li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li>\n</ol>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "BchTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferBchMnemonic" },
                  { "$ref": "#/components/schemas/TransferBchKeyPair" },
                  { "$ref": "#/components/schemas/TransferBchKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcMnemonicTxFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" },
                    { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BCH from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/litecoin/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Send LTC (Litecoin) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Litecoin server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits\nwhich are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li>\n<li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis method is a helper method, which internally wraps these steps:\n<ol>\n<li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li>\n<li><a href=\"#operation/LtcTransferBlockchain\">Perform blockchain transaction</a> - </li>\n<li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li>\n</ol>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "LtcTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferLtcMnemonic" },
                  { "$ref": "#/components/schemas/TransferLtcKeyPair" },
                  { "$ref": "#/components/schemas/TransferLtcKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcMnemonicTxFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403BtcTxUtxoFailed" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" },
                    { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send LTC from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/flow/transfer": {
      "post": {
        "description": "<h4>100 credits per API call. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.</h4><br/>\n<p>Send FLOW (Flow) or FUSD from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Flow server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic and index - private key is generated based on the index in the mnemonic.</li>\n<li>Using secret - private keys is entered manually.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis method is a helper method, which internally wraps these steps:\n<ol>\n<li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li>\n<li><a href=\"#operation/FlowTransferBlockchain\">Perform blockchain transaction</a> - </li>\n<li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li>\n</ol>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "FlowTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferFlowMnemonic" },
                  { "$ref": "#/components/schemas/TransferFlowPK" },
                  { "$ref": "#/components/schemas/TransferFlowKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcMnemonicTxFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403BtcTxUtxoFailed" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" },
                    { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send FLOW from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/dogecoin/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send DOGE (Dogecoin) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Dogecoin server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic - all of the addresses, that are generated from the mnemonic are scanned for the incoming deposits\nwhich are used as a source of the transaction. Assets, which are not used in a transaction are moved to the system address wih the derivation index 0. Address with index 0 cannot be assigned automatically to any account and is used for custodial wallet use cases. For non-custodial wallets, field <b>attr</b> should be present and it should be address with the index 1 of the connected wallet.</li>\n<li>Using keyPair - addresses which are used as a source of the transaction are entered manually</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis method is a helper method, which internally wraps these steps:\n<ol>\n<li><a href=\"#operation/storeWithdrawal\">Store withdrawal</a> - create a ledger transaction, which debits the assets on the sender account.</li>\n<li><a href=\"#operation/DogeTransferBlockchain\">Perform blockchain transaction</a> - </li>\n<li><a href=\"#operation/completeWithdrawal\">Complete withdrawal</a> - move the withdrawal to the completed state, when all of the previous steps were successful.</li>\n</ol>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "DogeTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferDogeMnemonic" },
                  { "$ref": "#/components/schemas/TransferDogeKeyPair" },
                  { "$ref": "#/components/schemas/TransferDogeKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcMnemonicTxFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403BtcTxUtxoFailed" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" },
                    { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send DOGE from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/ethereum/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send ETH (Ethereum) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Ethereum server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "EthTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEth" },
                  { "$ref": "#/components/schemas/TransferEthMnemonic" },
                  { "$ref": "#/components/schemas/TransferEthKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send ETH from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/polygon/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send MATIC (Polygon) or ERC-20-equivalent Polygon tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Polygon server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "PolygonTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEth" },
                  { "$ref": "#/components/schemas/TransferEthMnemonic" },
                  { "$ref": "#/components/schemas/TransferEthKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send MATIC from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/kcs/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send KCS (KuCoin Community Chain (KCC)) or ERC-20-equivalent KCC tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If KCS server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "KcsTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferKCS" },
                  { "$ref": "#/components/schemas/TransferKCSMnemonic" },
                  { "$ref": "#/components/schemas/TransferKCSKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send KCS from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/ethereum/erc20/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send Ethereum ERC-20 tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Ethereum server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "EthTransferErc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferErc20" },
                  { "$ref": "#/components/schemas/TransferErc20Mnemonic" },
                  { "$ref": "#/components/schemas/TransferErc20KMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Ethereum ERC-20 tokens from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/ethereum/erc20": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p>\n<p>First step to create new ERC20 token with given supply on Ethereum blockchain with support of Tatum's private ledger.<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of ERC20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with ERC20 token name as account's currency.<br/>\nNewly created account is frozen until the specific ERC20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create ERC20 smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/registerErc20Token\">Create ERC20 token</a> - creates a virtual currency within Tatum</li>\n<li><a href=\"#operation/EthDeployErc20Blockchain\">Deploy ERC20 smart contract</a> - create new ERC20 smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTokenAddress\">Store ERC20 smart contract address</a> - link newly created ERC20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC20 Tatum accounts</li>\n</ol>\nThere is a helper method <a href=\"#operation/EthDeployErc20\">Deploy Ethereum ERC20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "createErc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/Erc20" },
                  { "$ref": "#/components/schemas/Erc20Address" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new Ethereum ERC-20 token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/ethereum/erc20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy an Ethereum ERC-20 smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createErc20\">Register new ERC20 token in the ledger</a> and <a href=\"#operation/EthDeployErc20Blockchain\">Deploy blockchain ERC20</a>.<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "EthDeployErc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy an Ethereum ERC-20 smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/bsc/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send BSC (BNB Smart Chain) or BEP-20 tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<br/>\n<br/>\n<ul>\n<li>If BSC server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "BscOrBepTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferBsc" },
                  { "$ref": "#/components/schemas/TransferBscMnemonic" },
                  { "$ref": "#/components/schemas/TransferBscKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BSC from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/bsc/bep20": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p>\n<p>First step to create new BEP20 token with given supply on BSC blockchain with support of Tatum's private ledger.<br/>\n<br/>\n<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of BEP20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with BEP20 token name as account's currency.<br/>\nNewly created account is frozen until the specific BEP20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create BEP20 smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/registerErc20Token\">Register BEP20 token</a> - creates a virtual currency within Tatum</li>\n<li><a href=\"#operation/BscDeployErc20Blockchain\">Deploy BEP20 smart contract</a> - create new BEP20 smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTokenAddress\">Store BEP20 smart contract address</a> - link newly created BEP20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for BEP20 Tatum accounts</li>\n</ol>\nThere is a helper method <a href=\"#operation/EthDeployErc20\">Deploy BSC BEP20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "createBep20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/Erc20" },
                  { "$ref": "#/components/schemas/Erc20Address" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new BNB Smart Chain BEP-20 token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/bsc/bep20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy a BNB Smart Chain BEP-20 smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createBep20\">Register new BEP20 token in the ledger</a> and <a href=\"#operation/BscDeployBep20Blockchain\">Deploy blockchain BEP20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "BscDeployBep20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a BNB Smart Chain BEP-20 smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/klaytn/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send KLAY or ERC-20-equivalent tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<br/>\n<br/>\n<ul>\n<li>If KLAY server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "KlayTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEth" },
                  { "$ref": "#/components/schemas/TransferEthMnemonic" },
                  { "$ref": "#/components/schemas/TransferEthKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send KLAY from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/klaytn/erc20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy a Klaytn ERC-20-equivalent smart contract. This is a helper method, which is combination of\n<a href=\"#operation/registerErc20Token\">Register new ERC20 token in the ledger</a> and <a href=\"#operation/Erc20Deploy\">Deploy blockchain ERC20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "KlayDeployErc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a Klaytn ERC-20-equivalent smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xdc/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send XDC (XinFin) or ERC-20-equivalent XinFin tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<br/>\n<br/>\n<ul>\n<li>If XDC server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XdcTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEth" },
                  { "$ref": "#/components/schemas/TransferEthMnemonic" },
                  { "$ref": "#/components/schemas/TransferEthKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send XDC from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xdc/erc20": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p>\n<p>First step to create new ERC20 token with given supply on XDC blockchain with support of Tatum's private ledger.<br/>\n<br/>\n<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of ERC20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with ERC20 token name as account's currency.<br/>\nNewly created account is frozen until the specific ERC20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create ERC20 smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/registerErc20Token\">Register ERC20 token</a> - creates a virtual currency within Tatum</li>\n<li><a href=\"#operation/Erc20Deploy\">Deploy ERC20 smart contract</a> - create new ERC20 smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTokenAddress\">Store ERC20 smart contract address</a> - link newly created ERC20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC20 Tatum accounts</li>\n</ol>\nThere is a helper method <a href=\"#operation/Erc20Deploy\">Deploy XDC ERC20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "createXdc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/Erc20" },
                  { "$ref": "#/components/schemas/Erc20Address" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new XinFin ERC-20-equivalent token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xdc/erc20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy a XinFin ERC-20-equivalent smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createXdc20\">Register new ERC20 token in the ledger</a> and <a href=\"#operation/Erc20Deploy\">Deploy blockchain ERC20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XdcDeployErc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a XinFin ERC-20-equivalent smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/one/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send ONE (Harmony) or HRM-20 tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<br/>\n<br/>\n<ul>\n<li>If ONE server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "OneTransfer",
        "parameters": [
          {
            "description": "Shard to operate on",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEth" },
                  { "$ref": "#/components/schemas/TransferEthMnemonic" },
                  { "$ref": "#/components/schemas/TransferEthKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send ONE from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/one/hrm20": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p>\n<p>First step to create new HRM20 token with given supply on ONE blockchain with support of Tatum's private ledger.<br/>\n<br/>\n<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of HRM20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with HRM20 token name as account's currency.<br/>\nNewly created account is frozen until the specific HRM20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create HRM20 smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/registerErc20Token\">Register HRM20 token</a> - creates a virtual currency within Tatum</li>\n<li><a href=\"#operation/Erc20Deploy\">Deploy HRM20 smart contract</a> - create new HRM20 smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTokenAddress\">Store HRM20 smart contract address</a> - link newly created HRM20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for HRM20 Tatum accounts</li>\n</ol>\nThere is a helper method <a href=\"#operation/Erc20Deploy\">Deploy ONE HRM20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "createHrm20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/Erc20" },
                  { "$ref": "#/components/schemas/Erc20Address" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new Harmony HRM-20 token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/one/hrm20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy a Harmony HRM-20 smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createHrm20\">Register new HRM20 token in the ledger</a> and <a href=\"#operation/Erc20Deploy\">Deploy blockchain HRM20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "OneDeployHrm20",
        "parameters": [
          {
            "description": "Shard to operate on",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a Harmony HRM-20 smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/token/{chain}": {
      "post": {
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "example": "ETH",
              "type": "string",
              "enum": ["ETH", "CELO", "MATIC", "KCS", "BSC", "ONE", "XDC", "KLAY", "SOL"]
            }
          }
        ],
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>This is the first step to create a new ERC-20 or ERC-20 equivalent token with some supply in a virtual account.<br/>\n<br/>\n<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with token name as account's currency.<br/>\nNewly created account is frozen until the specific smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/registerErc20Token\">Register token</a> - creates a virtual currency within Tatum</li>\n<li>Deploy smart contract - create new smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTokenAddress\">Store smart contract address</a> - link newly created smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for Tatum accounts</li>\n</ol>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "registerErc20Token",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/Erc20" },
                  { "$ref": "#/components/schemas/Erc20Address" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new ERC-20 or ERC-20-equivalent token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/token/{name}/{address}": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Set the contact address of an ERC-20 or ERC-20-equivalent token (for example, BEP-20, HRM-20, and so on) to be able to communicate with the smart contract.\n<br/>\n<br/>\n<p>After creating and deploying an ERC-20 or ERC-20-equivalent token to the blockchain, the smart contract address is generated and must be set within Tatum. If the address is not set, the Tatum platform will not be able to detect incoming deposits of the tokens and transfer the tokens from virtual accounts to blockchain addresses.</p>\n<p><b>NOTE:</b>For Algorand, the contact address should be the token asset ID (AssetID), for example, <code>55351976</code>.</p>\n",
        "operationId": "storeTokenAddress",
        "parameters": [
          {
            "description": "Contract address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "maxLength": 100,
              "minLength": 1,
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
              "type": "string"
            }
          },
          {
            "description": "Symbol name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "maxLength": 30,
              "minLength": 1,
              "pattern": "^[a-zA-Z0-9_]+$",
              "example": "MY_TOKEN",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthErc20NotFound" },
                    { "$ref": "#/components/schemas/Error403EthErc20Set" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Set the contact address of an ERC-20 or ERC-20-equivalent token",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/celo/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send CELO (Celo), ERC-20-equivalent Celo tokens, cUSD, or cEUR from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<br/>\n<br/>\n<ul>\n<li>If Celo server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "CeloOrErc20Transfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferCelo" },
                  { "$ref": "#/components/schemas/TransferCeloMnemonic" },
                  { "$ref": "#/components/schemas/TransferCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send CELO from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/celo/erc20": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>This method is deprecated. Use <a href=\"#operation/registerErc20Token\">Register token</a> instead.</p>\n<p>First step to create new ERC-20 token with given supply on Celo blockchain with support of Tatum's private ledger.<br/>\n<br/>\n<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of ERC-20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with ERC-20 token name as account's currency.<br/>\nNewly created account is frozen until the specific ERC-20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create ERC-20 smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/registerErc20Token\">Register Celo ERC-20 token</a> - creates a virtual currency within Tatum</li>\n<li><a href=\"#operation/CeloDeployErc20\">Deploy Celo ERC-20 smart contract</a> - create new ERC-20 smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTokenAddress\">Store Celo ERC-20 smart contract address</a> - link newly created ERC-20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for ERC-20 Tatum accounts</li>\n</ol>\nThere is a helper method <a href=\"#operation/CeloDeployErc20Ledger\">Deploy Celo ERC-20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "createCeloErc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/Erc20" },
                  { "$ref": "#/components/schemas/Erc20Address" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new Celo ERC-20-equivalent token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/celo/erc20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy a Celo ERC-20-equivalent smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createCeloErc20\">Register new Celo ERC-20 token in the ledger</a> and <a href=\"#operation/CeloDeployErc20\">Deploy blockchain ERC-20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "CeloDeployErc20Ledger",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployCeloErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployCeloErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployCeloErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployCeloErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployCeloErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployCeloErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a Celo ERC-20-equivalent smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/kcs/erc20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy a KuCoin Community Chain (KCC) ERC-20-equivalent smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createErc20\">Register new Kcs ERC20 token in the ledger</a> and <a href=\"#operation/KcsDeployErc20Blockchain\">Deploy blockchain ERC-20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "KcsDeployErc20Ledger",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployKCSErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployKCSErc20OffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployKCSErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployKCSErc20OffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployKCSErc20OffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployKCSErc20OffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a KuCoin Community Chain (KCC) ERC-20-equivalent smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/celo/erc20/{name}/{address}": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<b>This method is deprecated. Please use <a href=\"#operation/storeTokenAddress\">this method</a> instead.</b>\n",
        "operationId": "storeCeloErc20Address",
        "parameters": [
          {
            "description": "ERC-20 contract address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "maxLength": 100,
              "minLength": 1,
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
              "type": "string"
            }
          },
          {
            "description": "ERC-20 symbol name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "maxLength": 30,
              "minLength": 1,
              "pattern": "^[a-zA-Z0-9_]+$",
              "example": "MY_TOKEN",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthErc20NotFound" },
                    { "$ref": "#/components/schemas/Error403EthErc20Set" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Set the contact address of a Celo ERC-20-equivalent token",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/solana/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Send SOL (Solana), USDC_SOL, or custom SPL tokens from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. When every system works as expected,\nwithdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If SOL server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "SolTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferSol" },
                  { "$ref": "#/components/schemas/TransferSolKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send SOL from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xlm/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Send XLM (Stellar) or XLM-based assets from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. When every system works as expected,\nwithdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If XLM server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XlmTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferXlm" },
                  { "$ref": "#/components/schemas/TransferXlmKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XlmFailed" },
                    { "$ref": "#/components/schemas/Error403XlmTxFailed" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send XLM from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xlm/asset": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Create an XLM-based asset in a virtual account. The asset must be created and configured on the Stellar blockchain before <a href=\"https://apidoc.tatum.io/tag/Stellar#operation/XlmTrustLineBlockchain\">creating a trust line</a>.</p>\n<p>This API call will create an internal virtual currency. You can create virtual accounts with off-chain support.</p>\n",
        "operationId": "XlmAssetOffchain",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CreateXlmAsset" } } },
          "required": true
        },
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VCCreateFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create an XLM-based asset",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xrp/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Send XRP (Ripple) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. When every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If XRP server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be\ncompleted manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XrpTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferXrp" },
                  { "$ref": "#/components/schemas/TransferXrpKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpAttr" },
                    { "$ref": "#/components/schemas/Error403XrpBroadcast" },
                    { "$ref": "#/components/schemas/Error403XrpFee" },
                    { "$ref": "#/components/schemas/Error403XrpSign" },
                    { "$ref": "#/components/schemas/Error403XrpCode" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send XRP from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/xrp/asset": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/><p>\n<p>Create an XRP-based asset in a virtual account. The asset must be created and configured on the Ripple blockchain before <a href=\"https://apidoc.tatum.io/tag/XRP#operation/XrpTrustLineBlockchain\">creating a trust line</a>.</p>\n<p>This API call will create an internal virtual currency. You can create virtual accounts with off-chain support.</p>\n",
        "operationId": "XrpAssetOffchain",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CreateXrpAsset" } } },
          "required": true
        },
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VCCreateFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create XRP based Asset",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/bnb/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Send BNB (BNB Beacon Chain) or BNB assets from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. When every system works as expected,\nwithdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If BNB server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be\ncompleted manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "BnbTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferBnb" },
                  { "$ref": "#/components/schemas/TransferBnbKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK",
            "headers": { "Access-Control-Allow-Origin": { "schema": { "type": "string" } } }
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BnbFailed" },
                    { "$ref": "#/components/schemas/Error403BnbAddressFailed" },
                    { "$ref": "#/components/schemas/Error403BnbBroadcatSigFailed" },
                    { "$ref": "#/components/schemas/Error403BnbTxStateFailed" },
                    { "$ref": "#/components/schemas/Error403BnbTxFailed" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BNB from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/bnb/asset": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/><p>        \n<p>Create a BNB-based asset in a virtual account. The asset must first be <a href=\"https://docs.binance.org/tokens.html\" targer=\"_blank\">created and configured on BNB Beacon Chain blockhain</a>.</p>\n<p>This API call will create an internal virtual currency. You can create virtual accounts with off-chain support.</p>\n",
        "operationId": "BnbAssetOffchain",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CreateBnbAsset" } } },
          "required": true
        },
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VCCreateFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create a BNB-based asset",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/ada/transfer": {
      "post": {
        "description": "<p><b>Support for Cardano is deprecated.</b></p><br/>\n<h4>10 credits per API call.</h4><p>Send ADA (Cardano) from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If ADA server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "AdaTransferOffchain",
        "deprecated": true,
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferAdaKeyPair" },
                  { "$ref": "#/components/schemas/TransferAdaMnemonic" },
                  { "$ref": "#/components/schemas/TransferAdaKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send ADA from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/tron/transfer": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>Send TRON or TRX assets from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<ul>\n<li>If Tron server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "TronTransferOffchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferTron" },
                  { "$ref": "#/components/schemas/TransferTronMnemonic" },
                  { "$ref": "#/components/schemas/TransferTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send TRON from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/tron/trc": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>First step to create new TRC 10/20 token with given supply on the Tron blockchain with support of Tatum's private ledger.<br/>\nThis method only creates Tatum Private ledger virtual currency with predefined parameters. It will not generate any blockchain smart contract.<br/>\nThe whole supply of TRC 10/20 token is stored in the customer's newly created account. Then it is possible to create new Tatum accounts with TRC 10/20 token name as account's currency.<br/>\nNewly created account is frozen until the specific TRC 10/20 smart contract address is linked with the Tatum virtual currency, representing the token.<br/>\nOrder of the steps to create TRC 10/20 smart contract with Tatum private ledger support:\n<ol>\n<li><a href=\"#operation/createTrc\">Create TRC 10/20 token</a> - creates a virtual currency within Tatum</li>\n<li><a href=\"#operation/TronCreateTrc20\">Deploy TRC 10</a> or <a href=\"#operation/TronCreateTrc10\">TRC 20 smart contract</a> - create new TRC 10/20 smart contract on the blockchain</li>\n<li><a href=\"#operation/storeTrcAddress\">Store TRC 10/20 smart contract address</a> - link newly created TRC 10/20 smart contract address with Tatum virtual currency - this operation enables frozen account and enables ledger synchronization for TRC 10/20 Tatum accounts</li>\n</ol>\nThere is a helper method <a href=\"#operation/TronDeployTrc\">Deploy TRC 10/20 Smart Contract to Blockchain and Ledger</a>, which wraps first 2 steps into 1 method.<br/>\nAddress on the blockchain, where all initial supply will be transferred, can be defined via the address or xpub and derivationIndex. When xpub is present, the account connected to this virtualCurrency will be set as the account's xpub.\n</p>\n",
        "operationId": "createTrc",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Trc" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Erc20Response" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Register a new TRON TRC-10 or TRC-20 token in the virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/tron/trc/deploy": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Deploy a TRON TRC-10 or TRC-20 smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createTrc\">Register new TRC-10/20 token in the ledger</a> and <a href=\"#operation/TronCreateTrc20\">Deploy blockchain TRC20</a> or <a href=\"#operation/TronCreateTrc10\">Deploy blockchain TRC10</a>.<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "TronDeployTrc",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployTrcOffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployTrcOffchainMnemXpub" },
                  { "$ref": "#/components/schemas/DeployTrcOffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployTrcOffchainPKXpub" },
                  { "$ref": "#/components/schemas/DeployTrcOffchainKMSAddress" },
                  { "$ref": "#/components/schemas/DeployTrcOffchainKMSXpub" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployErc20Response" },
                    { "$ref": "#/components/schemas/DeployErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a TRON TRC-10 or TRC-20 smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/tron/trc/{name}/{address}": {
      "post": {
        "deprecated": true,
        "description": "<h4>2 credits per API call.</h4><br/>\n<b>This method is deprecated. Please use <a href=\"#operation/storeTokenAddress\">this method</a> instead.</b>\n",
        "operationId": "storeTrcAddress",
        "parameters": [
          {
            "description": "TRC-10 Token ID or TRC-20 contract address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "maxLength": 34,
              "minLength": 7,
              "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
              "type": "string"
            }
          },
          {
            "description": "TRC 10/20 symbol name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "maxLength": 30,
              "minLength": 1,
              "pattern": "^[a-zA-Z0-9_]+$",
              "example": "MY_TOKEN",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthErc20NotFound" },
                    { "$ref": "#/components/schemas/Error403EthErc20Set" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Set the contact address of a TRC-10 or TRC-20 token",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/egld/transfer": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Send EGLD from a virtual account to the blockchain. This will create Tatum internal withdrawal request with ID. If every system works as expected, withdrawal request is marked as complete and transaction id is assigned to it.\n<br/>\n<br/>\n<ul>\n<li>If server connection is unavailable, withdrawal request is cancelled.</li>\n<li>If blockchain transfer is successful, but is it not possible to reach Tatum, transaction id of blockchain transaction is returned and withdrawal request must be completed manually, otherwise all other withdrawals will be pending.</li>\n</ul>\nIt is possible to perform ledger to blockchain transaction for ledger accounts without blockchain address assigned to them.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "EgldTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEth" },
                  { "$ref": "#/components/schemas/TransferEthMnemonic" },
                  { "$ref": "#/components/schemas/TransferEthKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send EGLD from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/algo/erc20/deploy": {
      "post": {
        "description": "<h4>4 credits per API call.</h4><br/>\n<p>Deploy an Algorand ERC-20-equivalent smart contract. This is a helper method, which is combination of\n<a href=\"#operation/createErc20\">Register new Algorand ERC20 token in the ledger</a> and <a href=\"#operation/AlgoDeployErc20Blockchain\">Deploy blockchain ERC-20</a>.<br/>\n<br/>\n<br/>\nAfter deploying a contract to blockchain, the contract address will become available and must be stored within Tatum. Otherwise, it will not be possible to interact with it and starts automatic blockchain synchronization.<br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "AlgoDeployErc20Ledger",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployAlgoErc20OffchainMnemonicAddress" },
                  { "$ref": "#/components/schemas/DeployAlgoErc20OffchainPKAddress" },
                  { "$ref": "#/components/schemas/DeployAlgoErc20OffchainKMSAddress" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/DeployAlgoErc20Response" },
                    { "$ref": "#/components/schemas/DeployAlgoErc20SignatureResponse" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403Erc20Prefix" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubBoth" },
                    { "$ref": "#/components/schemas/Error403Erc20XpubMissing" },
                    { "$ref": "#/components/schemas/Error403Erc20NameDuplicate" },
                    { "$ref": "#/components/schemas/Error403CustomerNotActive" },
                    { "$ref": "#/components/schemas/Error403VCCreateFailed" },
                    { "$ref": "#/components/schemas/Error403AccountNotExists" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubMissing" },
                    { "$ref": "#/components/schemas/Error403AddressAccountXpubUsed" },
                    { "$ref": "#/components/schemas/Error403AddressIndexUsed" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403AddressUsed" },
                    { "$ref": "#/components/schemas/Error403AddressXpub" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy an Algorand ERC-20-equivalent smart contract to the blockchain and a virtual account",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/offchain/algorand/transfer": {
      "post": {
        "description": "<p><b>4 credits per API call</b></p>\n<p>Send Algos or ERC-20-equivalent Algorand tokens from a virtual account (even from a virtual account without deposit addresses adssigned) to the Algorand blockchain.</p>\n<p>The recipient has to agree in advance to receive assets because Algorand charges users for storing assets on their addresses, and an Algorand blockchain address by default does not receive assets unless explicitly agreed. Before sending any asset from a virtual account to the blockchain, make sure that the recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">has agreed to receive the assets</a> to their address.</p>\n<p>Sending Algorand assets creates an internal Tatum withdrawal request with an ID. If everything works as expected, the withdrawal request is marked as complete and a transaction ID is assigned to it.</p>\n<ul>\n<li>If a server connection is unavailable, the withdrawal request is cancelled.</li>\n<li>If the transfer to the blockchain is successful, but the Tatum infrastructure cannot be accesses, the ID of the blockchain transaction is returned and you have to <a href=\"https://apidoc.tatum.io/tag/Withdrawal#operation/completeWithdrawal\" target=\"_blank\">complete the withdrawal request manually</a>. Otherwise, all other withdrawals will be pending.</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When sending Algos or ERC-20-equivalent Algorand tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "AlgoTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferAlgo" },
                  { "$ref": "#/components/schemas/TransferAlgoErc20" },
                  { "$ref": "#/components/schemas/TransferAlgoKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/OffchainTransactionResult" },
                    { "$ref": "#/components/schemas/OffchainTransactionSignatureResult" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403WithdrawalNotFound" },
                    { "$ref": "#/components/schemas/Error403RateNotFound" },
                    { "$ref": "#/components/schemas/Error403VCNotFound" },
                    { "$ref": "#/components/schemas/Error403RecipientFormat" },
                    { "$ref": "#/components/schemas/Error403WithdrawalFailed" },
                    { "$ref": "#/components/schemas/Error403WithdrawalVC" },
                    { "$ref": "#/components/schemas/Error403OffchainNotSupported" },
                    { "$ref": "#/components/schemas/Error403AmountFormat" },
                    { "$ref": "#/components/schemas/Error403FeeFormat" },
                    { "$ref": "#/components/schemas/Error403OffchainNotCancelled" },
                    { "$ref": "#/components/schemas/Error403OffchainCancelled" },
                    { "$ref": "#/components/schemas/Error403TxSenderNotFound" },
                    { "$ref": "#/components/schemas/Error403TxSenderCustomerDisabled" },
                    { "$ref": "#/components/schemas/Error403TxBalance" },
                    { "$ref": "#/components/schemas/Error403TxAmountBtc" },
                    { "$ref": "#/components/schemas/Error403TxAmountEth" },
                    { "$ref": "#/components/schemas/Error403TxSenderFrozen" },
                    { "$ref": "#/components/schemas/Error403WithdrawalPending" },
                    { "$ref": "#/components/schemas/Error403EthMnemonicPrivateKey" },
                    { "$ref": "#/components/schemas/Error403EthErc20Unsupported" },
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthTxBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Algos from a virtual account to the blockchain",
        "tags": ["Blockchain operations"]
      }
    },
    "/v3/bcash/wallet": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Bitcoin Cash wallet with derivation path m'/44'/145'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Bitcoin Cash wallet.</p>\n",
        "operationId": "BchGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Bitcoin Cash wallet",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/node": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as an http-based JSON RPC driver to connect directly to the node provided by Tatum.\nTo learn more about JSON RPC, visit <a href=\"https://github.com/gcash/bchd/blob/master/docs/json_rpc_api.md#Methods\" target=\"_blank\">Bitcoin Cash developers' guide</a>.</p>\n",
        "deprecated": true,
        "operationId": "BchRpcDriver",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid JSON RPC method content body.",
                "properties": {
                  "jsonrpc": {
                    "type": "string",
                    "description": "Version of the JSON RPC.",
                    "example": "1.0"
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the request, could be any arbitrary identifier.",
                    "example": "test"
                  },
                  "method": {
                    "type": "string",
                    "description": "Method to invoke on the node.",
                    "example": "getblockcount"
                  },
                  "params": {
                    "type": "array",
                    "description": "Params to the method call, if required.",
                    "example": []
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid RPC response.",
                  "example": { "jsonrpc": "1.0", "id": "test", "result": 654321 }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "x-codeSamples": [],
        "summary": "JSON RPC HTTP driver",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/info": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Bitcoin Cash Blockchain Information. Obtain basic info like testnet / mainnet version of the chain, current block number and it's hash.</p>",
        "operationId": "BchGetBlockChainInfo",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BchInfo" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Bitcoin Cash Blockchain Information",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/block/hash/{i}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Bitcoin Cash Block hash. Returns hash of the block to get the block detail.</p>",
        "operationId": "BchGetBlockHash",
        "parameters": [
          {
            "description": "The number of blocks preceding a particular block on a block chain.",
            "in": "path",
            "name": "i",
            "required": true,
            "schema": { "type": "number", "example": 1580117 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "description": "Block hash",
                      "example": "0000000053f225e202cf27fe3046e06719efd3b31b5ab75fc5ef7f853c8b246f"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Bitcoin Cash Block hash",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/block/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Bitcoin Cash Block detail by block hash or height.</p>",
        "operationId": "BchGetBlock",
        "parameters": [
          {
            "description": "Block hash or height",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "00000000000000cfb22714715f09b3721f89819a325f7f4d39b2c22a061d1be8"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BchBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Bitcoin Cash Block by hash",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/transaction/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Bitcoin Cash Transaction by transaction hash.</p>",
        "operationId": "BchGetRawTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "1451692ebbfbea1a2d2ec6fe6782596b6aa2e46c0589d04c406f491b5b46bc6a"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BchTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Bitcoin Cash Transaction by hash",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/transaction/address/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Bitcoin Cash Transaction by address. Limit is 50 transaction per response.</p>",
        "operationId": "BchGetTxByAddress",
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "2MsM67NLa71fHvTUBqNENW15P68nHB2vVXb" }
          },
          {
            "description": "Define, how much transactions should be skipped to obtain another page.",
            "in": "query",
            "name": "skip",
            "required": false,
            "schema": { "type": "integer", "example": 2 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/BchTx" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Bitcoin Cash Transactions by address",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/address/{xpub}/{index}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate Bitcoin Cash deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1. Generates new format of address starting with bitcoincash: in case of mainnet, bchtest: in case of testnet..</p>\n",
        "operationId": "BchGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Bitcoin Cash address",
                      "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzezc"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Bitcoin Cash deposit address from Extended public key",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/wallet/priv": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "BchGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Bitcoin Cash private key",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/transaction": {
      "post": {
        "description": "<p><b>10 credits per API call</b></p>\n<p>Send BCH to blockchain addresses.</p>\n<p>Bitcoin Cash transactions are based on UTXOs. \"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of BCH that remains at a Bitcoin Cash address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information the UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>.</p>\n<p>You build a BCH transaction by sending BCH from UTXOs. Each UTXO is included in the transaction.</p>\n<p>When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BCH and T2 with 2 BCH. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BCH to spend:<br/><code>1 BCH (from T1) + 2 BCH (from T2) = 3 BCH (to spend in total)</code></p>\n<p>You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive.</p>\n<p><b>Paying the gas fee and receiving the change</b><br/>\nWhen the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the <code>fee</code> and <code>changeAddress</code> parameters in the request body, correspondingly).</p>\n<p><b>Signing a transaction</b><br/>\nWhen sending BCH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BchTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BchTransaction" },
                  { "$ref": "#/components/schemas/BchTransactionKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BCH to Bitcoin Cash addresses",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/bcash/broadcast": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to Bitcoin Cash blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "BchBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Bitcoin Cash transaction",
        "tags": ["Bitcoin Cash"]
      }
    },
    "/v3/litecoin/wallet": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Litecoin wallet with derivation path m'/44'/2'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/litecoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/litecoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Litecoin wallet.</p>\n",
        "operationId": "LtcGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Litecoin wallet",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/node": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as an http-based JSON RPC driver to connect directly to the node provided by Tatum.</p>\n",
        "operationId": "LtcRpcDriver",
        "deprecated": true,
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid JSON RPC method content body.",
                "properties": {
                  "jsonrpc": {
                    "type": "string",
                    "description": "Version of the JSON RPC.",
                    "example": "1.0"
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the request, could be any arbitrary identifier.",
                    "example": "test"
                  },
                  "method": {
                    "type": "string",
                    "description": "Method to invoke on the node.",
                    "example": "getblockcount"
                  },
                  "params": {
                    "type": "array",
                    "description": "Params to the method call, if required.",
                    "example": []
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid RPC response.",
                  "example": { "jsonrpc": "1.0", "id": "test", "result": 654321 }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "x-codeSamples": [],
        "summary": "JSON RPC HTTP driver",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/info": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Litecoin Blockchain Information. Obtain basic info like testnet / mainnet version of the chain, current block number and it's hash.</p>",
        "operationId": "LtcGetBlockChainInfo",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/LtcInfo" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Litecoin Blockchain Information",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/block/hash/{i}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Litecoin Block hash. Returns hash of the block to get the block detail.</p>",
        "operationId": "LtcGetBlockHash",
        "parameters": [
          {
            "description": "The number of blocks preceding a particular block on a block chain.",
            "in": "path",
            "name": "i",
            "required": true,
            "schema": { "type": "number", "example": 1234314 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "description": "Block hash",
                      "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Litecoin Block hash",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/block/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Litecoin Block detail by block hash or height.</p>",
        "operationId": "LtcGetBlock",
        "parameters": [
          {
            "description": "Block hash or height.",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "1234314" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/LtcBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Block not found.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error404BlockNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Litecoin Block by hash or height",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/transaction/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Litecoin Transaction detail by transaction hash.</p>",
        "operationId": "LtcGetRawTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "d60631d8e5c8b6eb0557b5181cf28564d771c628a08abc414e87ad7c05ff2fc2"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/LtcTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403TxNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Litecoin Transaction by hash",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/mempool": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Litecoin Transaction ids in the mempool.</p>",
        "operationId": "LtcGetMempool",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "TX ID of the transaction in mempool",
                    "example": "4c7846a8ff8415945e96937dea27bdb3144c15d793648d725602784826052586"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403BtcBlockchain" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Mempool Transactions",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/transaction/address/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Litecoin Transaction by address.</p>",
        "operationId": "LtcGetTxByAddress",
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "n4YNG8q5JyxkeWf7zMi1bMyRZbRKK1W7or" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/LtcTx" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Litecoin Transactions by address",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/address/balance/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Litecoin Balance of the address.</p>",
        "operationId": "LtcGetBalanceOfAddress",
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "n4YNG8q5JyxkeWf7zMi1bMyRZbRKK1W7or" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/BtcBasedBalance" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Litecoin Balance of the address",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/utxo/{hash}/{index}": {
      "get": {
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent.</p>\n<p>\"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of LTC that remains at a Litecoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information the UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>.</p>\n<ul>\n<li>If the transaction output is an UTXO, the API returns data about it.</li>\n<li>If the transaction output has been spent and there is no UTXO to return, the API returns an error with the <code>404</code> response code.</li>\n</ul>\n",
        "operationId": "LtcGetUTXO",
        "parameters": [
          {
            "description": "The transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 64,
              "maxLength": 64,
              "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
            }
          },
          {
            "description": "The index of the transaction output that you want to check for the UTXO",
            "in": "path",
            "name": "index",
            "required": true,
            "schema": { "type": "number", "example": 0, "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/LtcUTXO" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcUTXO" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get information about a transaction output (UTXO) in a Litecoin transaction",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/address/{xpub}/{index}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate Litecoin deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "LtcGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Litecoin address",
                      "example": "n36h3pAH7sC3z8KMB47BjbqvW2aJd2oTi7"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Litecoin deposit address from Extended public key",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/wallet/priv": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "LtcGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Litecoin private key",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/transaction": {
      "post": {
        "description": "<p><b>10 credits per API call</b></p>\n<p>Send LTC to blockchain addresses.</p>\n<p>Litecoin transactions are based on UTXOs. \"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of LTC that remains at a Litecoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about the UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>. To check UTXOs in a transaction, see the <a href=\"#operation/LtcGetUTXO\">API for getting information about a transaction output (UTXO) in a Litecoin transaction</a>.</p>\n<p>You can build a LTC transaction by one of the following methods:</p>\n<ul>\n<li><b>Sending LTC from blockchain addresses</b><br/>The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from.<br/> To use this method, use the <code>LtcTransactionAddress</code> or <code>LtcTransactionAddressKMS</code> schema of the request body.</li>\n<li><b>Sending LTC from UTXOs</b><br/>The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send.<br/> To use this method, use the <code>LtcTransactionFromUTXO</code> or <code>LtcTransactionFromUTXOKMS</code> schema of the request body.</li>\n</ul>\n<p>When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 LTC and T2 with 2 LTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 LTC to spend:<br/><code>1 LTC (from T1) + 2 LTC (from T2) = 3 LTC (to spend in total)</code></p>\n<p>You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive.</p>\n<p><b>Paying the gas fee and receiving the change</b><br/>\nWhen the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the <code>fee</code> and <code>changeAddress</code> parameters in the request body, correspondingly).</p>\n<p><b>Signing a transaction</b><br/>\nWhen sending LTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "LtcTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/LtcTransactionAddress" },
                  { "$ref": "#/components/schemas/LtcTransactionAddressKMS" },
                  { "$ref": "#/components/schemas/LtcTransactionUTXO" },
                  { "$ref": "#/components/schemas/LtcTransactionUTXOKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send LTC to Litecoin addresses",
        "tags": ["Litecoin"]
      }
    },
    "/v3/litecoin/broadcast": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to Litecoin blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "LtcBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Litecoin transaction",
        "tags": ["Litecoin"]
      }
    },
    "/v3/dogecoin/wallet": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Dogecoin wallet with derivation path m'/44'/3'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/litecoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/litecoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Dogecoin wallet.</p>\n",
        "operationId": "DogeGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Dogecoin wallet",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/address/{xpub}/{index}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generate Dogecoin deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "DogeGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Dogecoin address",
                      "example": "n36h3pAH7sC3z8KMB47BjbqvW2aJd2oTi7"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Dogecoin deposit address from Extended public key",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/wallet/priv": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "DogeGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Dogecoin private key",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/node": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as an http-based JSON RPC driver to connect directly to the node provided by Tatum.</p>\n",
        "deprecated": true,
        "operationId": "DogeRpcDriver",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid JSON RPC method content body.",
                "properties": {
                  "jsonrpc": {
                    "type": "string",
                    "description": "Version of the JSON RPC.",
                    "example": "1.0"
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the request, could be any arbitrary identifier.",
                    "example": "test"
                  },
                  "method": {
                    "type": "string",
                    "description": "Method to invoke on the node.",
                    "example": "getblockcount"
                  },
                  "params": {
                    "type": "array",
                    "description": "Params to the method call, if required.",
                    "example": []
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid RPC response.",
                  "example": { "jsonrpc": "1.0", "id": "test", "result": 654321 }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "x-codeSamples": [],
        "summary": "JSON RPC HTTP driver",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/info": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Dogecoin Blockchain Information. Obtain basic info like testnet / mainnet version of the chain, current block number and it's hash.</p>",
        "operationId": "DogeGetBlockChainInfo",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DogeInfo" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Dogecoin Blockchain Information",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/block/hash/{i}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Dogecoin Block hash. Returns hash of the block to get the block detail.</p>",
        "operationId": "DogeGetBlockHash",
        "parameters": [
          {
            "description": "The number of blocks preceding a particular block on a block chain.",
            "in": "path",
            "name": "i",
            "required": true,
            "schema": { "type": "number", "example": 1234314 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "description": "Block hash",
                      "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Dogecoin Block hash",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/block/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Dogecoin Block detail by block hash or height.</p>",
        "operationId": "DogeGetBlock",
        "parameters": [
          {
            "description": "Block hash or height.",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "1234314" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DogeBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Block not found.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error404BlockNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Dogecoin Block by hash or height",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/transaction/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Dogecoin Transaction detail by transaction hash.</p>",
        "operationId": "DogeGetRawTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "d60631d8e5c8b6eb0557b5181cf28564d771c628a08abc414e87ad7c05ff2fc2"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DogeTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403TxNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Dogecoin Transaction by hash",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/mempool": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Dogecoin Transaction ids in the mempool.</p>",
        "operationId": "DogeGetMempool",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "TX ID of the transaction in mempool",
                    "example": "4c7846a8ff8415945e96937dea27bdb3144c15d793648d725602784826052586"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403BtcBlockchain" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Mempool Transactions",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/utxo/{hash}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent.</p>\n<p>\"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of DOGE that remains at a Dogecoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about the UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>.</p>\n<ul>\n<li>If the transaction output is an UTXO, the API returns data about it.</li>\n<li>If the transaction output has been spent and there is no UTXO to return, the API returns an error with the <code>404</code> response code.</li>\n</ul>\n",
        "operationId": "DogeGetUTXO",
        "parameters": [
          {
            "description": "The transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 64,
              "maxLength": 64,
              "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
            }
          },
          {
            "description": "The index of the transaction output that you want to check for the UTXO",
            "in": "path",
            "name": "index",
            "required": true,
            "schema": { "type": "number", "example": 0, "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DogeUTXO" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcUTXO" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get information about a transaction output (UTXO) in a Dogecoin transaction",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send DOGE to blockchain addresses.</p>\n<p>Dogecoin transactions are based on UTXOs. \"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of DOGE that remains at a Bitcoin Cash address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information the UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>. To check UTXOs in a transaction, see the <a href=\"#operation/DogeGetUTXO\">API for getting information about a transaction output (UTXO) in a Dogecoin transaction</a></p>\n<p>You build a DOGE transaction by sending DOGE from UTXOs. Each UTXO is included in the transaction.</p>\n<p>When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 DOGE and T2 with 2 DOGE. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 DOGE to spend:<br/><code>1 DOGE (from T1) + 2 DOGE (from T2) = 3 DOGE (to spend in total)</code></p>\n<p>You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive.</p>\n<p><b>Paying the gas fee and receiving the change</b><br/>\nWhen the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the <code>fee</code> and <code>changeAddress</code> parameters in the request body, correspondingly).</p>\n<p><b>Signing a transaction</b><br/>\nWhen sending DOGE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "DogeTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DogeTransactionUTXO" },
                  { "$ref": "#/components/schemas/DogeTransactionUTXOKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send DOGE to Dogecoin addresses",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/dogecoin/broadcast": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to Dogecoin blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "DogeBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Dogecoin transaction",
        "tags": ["Dogecoin"]
      }
    },
    "/v3/flow/wallet": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Dogecoin wallet with derivation path m'/44'/3'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/litecoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/litecoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Dogecoin wallet.</p>\n",
        "operationId": "FlowGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Flow wallet",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/address/{xpub}/{index}": {
      "get": {
        "description": "<h4>1 credit for GET operation + 3000 credits per address.</h4><br/>\n<p>Generate Flow address from Extended public key. This operation internally creates public key and assings it to the newly created address on the blockchain.\nThere is minimal amount, which must be sent to the FLOW address during creation - 0.001 FLOW, which will be used from Tatum service account.<br/>\n<b>This operation is allowed on any Testnet plan and only on Paid Mainnet plans.</b>\nPublic key is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "FlowGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Flow address",
                      "example": "0x4f09d8d43e4967b7"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Flow address from Extended public key",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/pubkey/{xpub}/{index}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generate Flow public key from Extended public key. This key is added to the address on the blockchain and can control the funds there. Public key is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "FlowGeneratePubKey",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "pubKey": {
                      "type": "string",
                      "description": "Flow public key",
                      "example": "968c3ce11e871cb2b7161b282655ee5fcb051f3c04894705d771bf11c6fbebfc6556ab8a0c04f45ea56281312336d0668529077c9d66891a6cad3db877acbe90"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Flow public key from Extended public key",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/wallet/priv": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "FlowGeneratePubKeyPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Flow private key",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/block/current": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Flow current block number.</p>",
        "operationId": "FlowGetBlockChainInfo",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "type": "number", "example": 12345678 } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Flow current block number",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/block/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Flow Block detail by block hash or height.</p>",
        "operationId": "FlowGetBlock",
        "parameters": [
          {
            "description": "Block hash or height.",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "1234314" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FlowBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Block not found.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error404BlockNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Flow Block by hash or height",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/block/events": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Flow events from block.</p>",
        "operationId": "FlowGetBlockEvents",
        "parameters": [
          {
            "description": "Event type to search for",
            "in": "query",
            "name": "type",
            "required": true,
            "schema": { "type": "string", "example": "A.7e60df042a9c0868.FlowToken.TokensWithdrawn" }
          },
          {
            "description": "Block height to start searching",
            "in": "query",
            "name": "from",
            "required": true,
            "schema": { "type": "number", "example": 654321 }
          },
          {
            "description": "Block height to end searching",
            "in": "query",
            "name": "to",
            "required": true,
            "schema": { "type": "number", "example": 654326 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/FlowEvent" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Block not found.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error404BlockNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Flow events from blocks",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/transaction/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Flow Transaction detail by transaction hash.</p>",
        "operationId": "FlowGetRawTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "d60631d8e5c8b6eb0557b5181cf28564d771c628a08abc414e87ad7c05ff2fc2"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FlowTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403TxNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Flow Transaction by hash",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/account/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Flow account details.</p>",
        "operationId": "FlowGetAccount",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x955cd3f17b2fd8ad" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FlowAccount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403BtcBlockchain" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Flow account",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/transaction": {
      "post": {
        "description": "<h4>100 credits per API call.</h4><br/>\n<p>Send Flow or FUSD to blockchain addresses. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.<br/>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic and index - private key is generated based on the index in the mnemonic.</li>\n<li>Using secret - private keys is entered manually.</li>\n</ul><br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "FlowTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/FlowTransactionMnemonic" },
                  { "$ref": "#/components/schemas/FlowTransactionPK" },
                  { "$ref": "#/components/schemas/FlowTransactionKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Flow to blockchain addresses",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/transaction/custom": {
      "post": {
        "description": "<h4>100 credits per API call.</h4><br/>\n<p>Send arbitrary blockchain transaction to FLOW blockchain. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.<br/>\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic and index - private key is generated based on the index in the mnemonic.</li>\n<li>Using secret - private keys is entered manually.</li>\n</ul><br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "FlowTransferCustomBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/FlowCustomTransactionMnemonic" },
                  { "$ref": "#/components/schemas/FlowCustomTransactionPK" },
                  { "$ref": "#/components/schemas/FlowCustomTransactionKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send arbitrary transaction to blockchain",
        "tags": ["Flow"]
      }
    },
    "/v3/flow/account": {
      "post": {
        "description": "<h4>100 credits per API call. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.</h4><br/>\n<p>Create Flow blockchain addresses from public key. This will generate address on the blockchain with public key. Private key for that public key can be used for signing transaction.\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic and index - private key is generated based on the index in the mnemonic.</li>\n<li>Using secret - private keys is entered manually.</li>\n</ul><br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "FlowCreateAddressFromPubKey",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/FlowCreateAddressFromPubKeyMnemonic" },
                  { "$ref": "#/components/schemas/FlowCreateAddressFromPubKeySecret" },
                  { "$ref": "#/components/schemas/FlowCreateAddressFromPubKeyKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/SignatureId" },
                    {
                      "type": "object",
                      "properties": {
                        "txId": {
                          "type": "string",
                          "example": "asd",
                          "description": "Id of the transaction"
                        },
                        "address": {
                          "type": "string",
                          "example": "asd",
                          "description": "Generated blockchain address"
                        }
                      }
                    }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create Flow address from public key",
        "tags": ["Flow"]
      },
      "put": {
        "description": "<h4>100 credits per API call. Tatum covers the fee connected to the transaction costs in subscription credits. This operation can be done on mainnet only for paid plans.</h4><br/>\n<p>Add public key to existing Flow blockchain addresses. Private key for that public key can be used for signing transaction.\nThere are two possibilites how the transaction on the blockchain can be created:\n<ul>\n<li>Using mnemonic and index - private key is generated based on the index in the mnemonic.</li>\n<li>Using secret - private keys is entered manually.</li>\n</ul><br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and losing funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "FlowAddPubKeyToAddress",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/FlowCreateAddressFromPubKeyMnemonic" },
                  { "$ref": "#/components/schemas/FlowCreateAddressFromPubKeySecret" },
                  { "$ref": "#/components/schemas/FlowCreateAddressFromPubKeyKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403Broadcast" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Add public key to Flow address",
        "tags": ["Flow"]
      }
    },
    "/v3/xrp/account": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate XRP account. Tatum does not support HD wallet for XRP, only specific address and private key can be generated.</p>\n",
        "operationId": "XrpWallet",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpWallet" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XrpFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate XRP account",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/info": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XRP Blockchain last closed ledger index and hash.</p>",
        "operationId": "XrpGetLastClosedLedger",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpInfo" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XrpFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XRP Blockchain Information",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/fee": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Get XRP Blockchain fee. Standard fee for the transaction is available in the drops.base_fee section and is 10 XRP drops by default.\nWhen there is a heavy traffic on the blockchain, fees are increasing according to current traffic.</p>\n",
        "operationId": "XrpGetFee",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpFee" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XrpFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get actual Blockchain fee",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/account/tx/{account}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>List all Account transactions.</p>",
        "operationId": "XrpGetAccountTx",
        "parameters": [
          {
            "description": "Address of XRP account.",
            "in": "path",
            "name": "account",
            "required": true,
            "schema": { "type": "string" }
          },
          {
            "description": "Ledger version to start scanning for transactions from.",
            "in": "query",
            "name": "min",
            "required": false,
            "schema": { "type": "number" }
          },
          {
            "description": "Marker from the last paginated request. It is stringified JSON from previous response.",
            "in": "query",
            "name": "marker",
            "required": false,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpAccountTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpCode" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Account transactions",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/ledger/{i}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get ledger by sequence.</p>",
        "operationId": "XrpGetLedger",
        "parameters": [
          {
            "description": "Sequence of XRP ledger.",
            "in": "path",
            "name": "i",
            "required": true,
            "schema": { "type": "number", "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpLedger" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpLedger" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Ledger",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/transaction/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XRP Transaction by transaction hash.</p>",
        "operationId": "XrpGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "example": "1A32A054B04AC9D6814710DDCA416E72C4CD2D78D6C3DFC06CC9369CC4F6B250",
              "type": "string",
              "minLength": 64,
              "maxLength": 64
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpCode" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XRP Transaction by hash",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/account/{account}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XRP Account info.</p>",
        "operationId": "XrpGetAccountInfo",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "account",
            "required": true,
            "schema": { "example": "rDA3DJBUBjA1X3PtLLFAEXxX31oA5nL3QF", "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XrpAccount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpCode" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Account info",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/account/{account}/balance": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XRP Account Balance. Obtain balance of the XRP and other assets on the account.</p>",
        "operationId": "XrpGetAccountBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "account",
            "required": true,
            "schema": { "example": "rDA3DJBUBjA1X3PtLLFAEXxX31oA5nL3QF", "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/XrpAccountBalance" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpCode" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Account Balance",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/transaction": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Send XRP from account to account.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XrpTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferXrpBlockchain" },
                  { "$ref": "#/components/schemas/TransferXrpBlockchainAsset" },
                  { "$ref": "#/components/schemas/TransferXrpBlockchainKMS" },
                  { "$ref": "#/components/schemas/TransferXrpBlockchainAssetKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpBroadcast" },
                    { "$ref": "#/components/schemas/Error403XrpFee" },
                    { "$ref": "#/components/schemas/Error403XrpSign" },
                    { "$ref": "#/components/schemas/Error403XrpCode" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send XRP from address to address",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/trust": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Create / Update / Delete XRP trust line between accounts to transfer private assets.\nBy creating trustline for the first time, the asset is created automatically and can be used in the transactions.<br/>\nAccount setting rippling must be enabled on the issuer account before the trust line creation to asset work correctly.\nCreating a trust line will cause an additional 5 XRP to be blocked on the account.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "XrpTrustLineBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TrustLineXrpBlockchain" },
                  { "$ref": "#/components/schemas/TrustLineXrpBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpBroadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create / Update / Delete XRP trust line",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/account/settings": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Modify XRP account settings. If an XRP account should be an issuer of the custom asset, this accounts should have rippling enabled to true.\nIn order to support off-chain processing, required destination tag should be set on the account.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XrpAccountSettings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/AccountSettingsXrpBlockchain" },
                  { "$ref": "#/components/schemas/AccountSettingsXrpBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XrpFailed" },
                    { "$ref": "#/components/schemas/Error403XrpBroadcast" },
                    { "$ref": "#/components/schemas/Error403XrpMultiple" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Modify XRP account",
        "tags": ["XRP"]
      }
    },
    "/v3/xrp/broadcast": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to XRP blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "XrpBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XrpBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed XRP transaction",
        "tags": ["XRP"]
      }
    },
    "/v3/xlm/account": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate XLM account. Tatum does not support HD wallet for XLM, only specific address and private key can be generated.</p>\n",
        "operationId": "XlmWallet",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XlmWallet" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate XLM account",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/info": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XLM Blockchain last closed ledger.</p>",
        "operationId": "XlmGetLastClosedLedger",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XlmLedger" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XLM Blockchain Information",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/ledger/{sequence}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XLM Blockchain ledger for ledger sequence.</p>",
        "operationId": "XlmGetLedger",
        "parameters": [
          {
            "description": "Sequence of the ledger.",
            "in": "path",
            "name": "sequence",
            "required": true,
            "schema": { "type": "string", "example": "1" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XlmLedger" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XLM Blockchain Ledger by sequence",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/ledger/{sequence}/transaction": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XLM Blockchain transactions in the ledger.</p>",
        "operationId": "XlmGetLedgerTx",
        "parameters": [
          {
            "description": "Sequence of the ledger.",
            "in": "path",
            "name": "sequence",
            "required": true,
            "schema": { "type": "string", "example": "1" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/XlmTx" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XLM Blockchain Transactions in Ledger",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/fee": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XLM Blockchain fee in 1/10000000 of XLM (stroop)</p>",
        "operationId": "XlmGetFee",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "description": "Current fee in 1/10000000 of XLM (stroop)",
                  "example": 100
                }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get actual XLM fee",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/account/tx/{account}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>List all XLM account transactions.</p>",
        "operationId": "XlmGetAccountTx",
        "parameters": [
          {
            "description": "Address of XLM account.",
            "in": "path",
            "name": "account",
            "required": true,
            "schema": {
              "type": "string",
              "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H"
            }
          },
          {
            "description": "Paging token from the last transaction gives you next page",
            "in": "query",
            "name": "pagination",
            "required": false,
            "schema": { "type": "string", "example": "1348087155011584" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/XlmTx" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XLM Account transactions",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/transaction/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XLM Transaction by transaction hash.</p>",
        "operationId": "XlmGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "example": "749e4f8933221b9942ef38a02856803f379789ec8d971f1f60535db70135673e",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XlmTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XLM Transaction by hash",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/account/{account}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get XLM Account detail.</p>",
        "operationId": "XlmGetAccountInfo",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "account",
            "required": true,
            "schema": {
              "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XlmAccount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XLM Account info",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/transaction": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Send XLM from account to account. It is possbile to send native XLM asset, or any other custom asset present on the network.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XlmTransferBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferXlmBlockchain" },
                  { "$ref": "#/components/schemas/TransferXlmBlockchainAsset" },
                  { "$ref": "#/components/schemas/TransferXlmBlockchainKMS" },
                  { "$ref": "#/components/schemas/TransferXlmBlockchainKMSAsset" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XlmFailed" },
                    { "$ref": "#/components/schemas/Error403XlmTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send XLM from address to address",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/trust": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/><p>\n<p>Create / Update / Delete XLM trust line between accounts to transfer private assets.\nBy creating trustline for the first time, the asset is created automatically and can be used in the transactions.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "XlmTrustLineBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TrustLineXlmBlockchain" },
                  { "$ref": "#/components/schemas/TrustLineXlmBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XlmFailed" },
                    { "$ref": "#/components/schemas/Error403XlmTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create / Update / Delete XLM trust line",
        "tags": ["Stellar"]
      }
    },
    "/v3/xlm/broadcast": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to XLM blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "XlmBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XlmFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed XLM transaction",
        "tags": ["Stellar"]
      }
    },
    "/v3/bnb/account": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate BNB account. Tatum does not support HD wallet for BNB, only specific address and private key can be generated.</p>\n",
        "operationId": "BnbGenerateWallet",
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BnbWallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Binance wallet",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/block/current": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Binance current block number.</p>",
        "operationId": "BnbGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BnbFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Binance current block",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/block/{height}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Transactions in block by block height.</p>",
        "operationId": "BnbGetBlock",
        "parameters": [
          {
            "description": "Block height",
            "in": "path",
            "name": "height",
            "required": true,
            "schema": { "type": "number", "example": 6470657 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BnbBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BnbFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Binance Transactions in Block",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/account/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Binance Account Detail by address.</p>",
        "operationId": "BnbGetAccount",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "tbnb185tqzq3j6y7yep85lncaz9qeectjxqe5054cgn" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BnbAccount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BnbFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Binance Account",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/transaction/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Binance Transaction by transaction hash.</p>",
        "operationId": "BnbGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "4B944BBF78F3ADE3A377551B5EA7AD0FEDBDA13165D932F94B106EF7A8E16C1A"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BnbTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BnbFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Binance Transaction",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/account/transaction/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get Binance Transactions by address.</p>",
        "operationId": "BnbGetTxByAccount",
        "parameters": [
          {
            "description": "Account address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "tbnb185tqzq3j6y7yep85lncaz9qeectjxqe5054cgn" }
          },
          {
            "description": "Start time in milliseconds",
            "in": "query",
            "name": "startTime",
            "required": true,
            "schema": { "type": "number", "minimum": 0, "example": 1651831727871 }
          },
          {
            "description": "End time in milliseconds",
            "in": "query",
            "name": "endTime",
            "required": true,
            "schema": { "type": "number", "minimum": 0, "example": 1651831727871 }
          },
          {
            "description": "Items per page.",
            "in": "query",
            "name": "limit",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 }
          },
          {
            "description": "Pagination offset",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 10, "minimum": 0 }
          },
          {
            "description": "Asset name",
            "in": "query",
            "name": "asset",
            "schema": { "type": "string", "example": "BNB" }
          },
          {
            "description": "Address type",
            "in": "query",
            "name": "addressType",
            "schema": { "type": "string", "example": "FROM", "enum": ["FROM", "TO"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/BnbTxInAccount" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BnbFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Binance Transactions By Address",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/transaction": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Send Binance or Binance Token token from account to account.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey.\nPrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\n Alternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "BnbBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferBnbBlockchain" },
                  { "$ref": "#/components/schemas/TransferBnbBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BnbTxFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Binance / Binance Token from account to account",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/bnb/broadcast": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to Binance blockchain. This method is used internally or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "BnbBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Broadcast" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BnbFailed" },
                    { "$ref": "#/components/schemas/Error403BnbBroadcatSigFailed" },
                    { "$ref": "#/components/schemas/Error403BnbTxStateFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed BNB transaction",
        "tags": ["BNB Beacon Chain"]
      }
    },
    "/v3/vet/wallet": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for VeChain wallet with derivation path m'/44'/818'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible VeChain wallet.</p>\n",
        "operationId": "VetGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate VeChain wallet",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/address/{xpub}/{index}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate VeChain account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "VetGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "VeChain addres",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate VeChain account address from Extended public key",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/wallet/priv": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "VetGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate VeChain private key",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/block/current": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get VeChain current block number.</p>",
        "operationId": "VetGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get VeChain current block",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/block/{hash}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get VeChain Block by block hash or block number.</p>",
        "operationId": "VetGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "325324" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VetBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get VeChain Block by hash",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/account/balance/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get VeChain Account balance in VET.</p>",
        "operationId": "VetGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in VET", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get VeChain Account balance",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/account/energy/{address}": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/><p>Get VeChain Account energy in VTHO. VTHO is used for paying for the transaction fee.</p>",
        "operationId": "VetGetEnergy",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "energy": { "type": "string", "description": "Balance in VTHO", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get VeChain Account energy (VTHO)",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/transaction/{hash}": {
      "get": {
        "description": "<h4>10 credits per API call.</h4><br/><p>Get VeChain Transaction by transaction hash.</p>",
        "operationId": "VetGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x24f691abab680972437028af22bc7a43c3fbe8d6d7eefc420dea2daf554758a7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VetTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get VeChain Transaction",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/transaction/{hash}/receipt": {
      "get": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Get VeChain Transaction Receipt by transaction hash. Transaction receipt is available only after transaction is\nincluded in the block and contains information about paid fee or created contract address and much more.</p>\n",
        "operationId": "VetGetTransactionReceipt",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x24f691abab680972437028af22bc7a43c3fbe8d6d7eefc420dea2daf554758a7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VetTxReceipt" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get VeChain Transaction Receipt",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/transaction": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Send VET from account to account. Fee for the transaction is paid in VTHO.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "VetBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferVetBlockchain" },
                  { "$ref": "#/components/schemas/TransferVetBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403VetFailed" },
                    { "$ref": "#/components/schemas/Error403VetGas" },
                    { "$ref": "#/components/schemas/Error403VetTxHash" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send VeChain from account to account",
        "tags": ["VeChain"]
      }
    },
    "/v3/vet/broadcast": {
      "post": {
        "description": "<h4>5 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to VeChain blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "VetBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403VetFailed" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed VeChain transaction",
        "tags": ["VeChain"]
      }
    },
    "/v3/ada/info": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>You can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/><h4>1 credit per API call.</h4><p>Gets Ada blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.</p>",
        "operationId": "AdaGetBlockChainInfo",
        "deprecated": true,
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AdaInfo" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Blockchain information",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/wallet": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>\nYou can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/>\n<h4>1 credit per API call.</h4><p>Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for ADA wallet with derivation path m/1852'/1815'/0'. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Ada wallet.</p>\n",
        "operationId": "AdaGenerateWallet",
        "deprecated": true,
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Ada wallet",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>\nYou can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/>\n<h4>1 credit per API call.</h4>\n<p>Generates a Ada deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "AdaGenerateAddress",
        "deprecated": true,
        "parameters": [
          {
            "description": "Extended public key of a wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "30e96a57be6235c686da968c1860f69d1871a692b29626b7ebb923aff8c6731cb9fef3a26b7eba8a07653483d06427d0c07966c5f81c69a7925d714530bedb1ef9e9103547b54ad0954b3569785ca70e1fd08313f92a3a9d31efa216b2b9adac4678455e66c97b53cd589f9da70a14265cf15cd4c1e0ce914407008f4a65f316",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of the desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 0,
            "schema": { "type": "number", "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Ada address",
                      "example": "addr1qyyxyhaa2e7kxeqcc72w7f747zqlgwwwstlzsg9umuxc40wnhawldxl4nan95rhtlcnju9q2r8j9qz8vslwsmrkj5r4spxhep9"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403AccountIncompatibleXpubBtc" },
                    { "$ref": "#/components/schemas/Error403AccountAddressGeneral" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Ada deposit address from Extended public key",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/wallet/priv": {
      "post": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>\nYou can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/>\n<h4>1 credit per API call.</h4>\n<p>Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic\ncan generate up to 2^32 private keys starting from index 0 until 2^31 - 1.</p>\n",
        "operationId": "AdaGenerateAddressPrivateKey",
        "deprecated": true,
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Ada private key",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/block/{hash}": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>You can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/><h4>1 credit per API call.</h4><p>Gets Ada block detail by block hash or height.</p>",
        "operationId": "AdaGetBlock",
        "deprecated": true,
        "parameters": [
          {
            "description": "Block hash or height.",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "00000000ca231a439a5c0a86a5a5dd6dc1918a8e897b96522fa9499288e70183"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AdaBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "404": {
            "description": "Block not found.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error404BlockNotExists" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Block by hash or height",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/transaction/{hash}": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>You can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/><h4>1 credit per API call.</h4><p>Get Ada Transaction detail by transaction hash.</p>",
        "operationId": "AdaGetRawTransaction",
        "deprecated": true,
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "1451692ebbfbea1a2d2ec6fe6782596b6aa2e46c0589d04c406f491b5b46bc6a"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AdaTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403TxNotFound" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get transaction by hash",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/transaction/address/{address}": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>You can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/><h4>1 credit per API call.</h4><p>Gets a Ada transaction by address.</p>",
        "operationId": "AdaGetTxByAddress",
        "deprecated": true,
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "Ae2tdPwUPEZMmrkRoduJW9w7wRvnTcdeMbw7yyyjwPqo6zuaeJaDEkHUJSz"
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain the next page of data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/AdaTx" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get transactions by address",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/{address}/utxos": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>You can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/><h4>1 credit per API call.</h4><p>Gets a Ada UTXOs by address.</p>",
        "operationId": "AdaGetUTXOByAddress",
        "deprecated": true,
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "Ae2tdPwUPEZMmrkRoduJW9w7wRvnTcdeMbw7yyyjwPqo6zuaeJaDEkHUJSz"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/AdaUTXO" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BtcBlockchain" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get UTXOs by address",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/transaction": {
      "post": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>\nYou can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/>\n<p><b>2 credits per API call</b></p>\n<p>Send ADA to blockchain addresses.</p>\n<p>Cardano transactions are based on UTXOs. \"UTXO\" stands for \"Unspent Transaction Output\". A UTXO is the amount of ADA that remains at a Cardano address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about the UTXO, see the <a href=\"https://developer.bitcoin.org/devguide/transactions.html\" target=\"_blank\">Bitcoin user documentation</a>.</p>\n<p>You can build an ADA transaction by one of the following methods:</p>\n<ul>\n<li><b>Sending ADA from blockchain addresses</b><br/>The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from.<br/> To use this method, use the <code>AdaTransactionFromAddress</code> or <code>AdaTransactionFromAddressKMS</code> schema of the request body.</li>\n<li><b>Sending ADA from UTXOs</b><br/>The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send.<br/> To use this method, use the <code>AdaTransactionFromUTXO</code> or <code>AdaTransactionFromUTXOKMS</code> schema of the request body.</li>\n</ul>\n<p>When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 ADA and T2 with 2 ADA. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 ADA to spend:<br/><code>1 ADA (from T1) + 2 ADA (from T2) = 3 ADA (to spend in total)</code></p>\n<p>You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive.</p>\n<p><b>Paying the gas fee and receiving the change</b><br/>\nWhen the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the <code>fee</code> and <code>changeAddress</code> parameters in the request body, correspondingly).</p>\n<p><b>Signing a transaction</b><br/>\nWhen sending ADA, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "AdaTransferBlockchain",
        "deprecated": true,
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/AdaTransactionFromAddress" },
                  { "$ref": "#/components/schemas/AdaTransactionFromAddressKMS" },
                  { "$ref": "#/components/schemas/AdaTransactionFromUTXO" },
                  { "$ref": "#/components/schemas/AdaTransactionFromUTXOKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcTx" },
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403BtcUTXO" },
                    { "$ref": "#/components/schemas/Error403BtcTxFailed" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send ADA to Cardano addresses",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/broadcast": {
      "post": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>\nYou can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/>\n<h4>2 credits per API call.</h4>\n<p>Broadcasts a signed transaction to the Ada blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries.\nIt is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.</p>\n",
        "operationId": "AdaBroadcast",
        "deprecated": true,
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Ada transaction",
        "tags": ["Cardano"]
      }
    },
    "/v3/ada/account/{address}": {
      "get": {
        "description": "<p><b>Support for Cardano is deprecated.<br/>\nYou can work with Cardano by <a href=\"https://apidoc.tatum.io/tag/Node-RPC#operation/NodeJsonPostRpcDriver\" target=\"_blank\">connecting directly to a blockchain node provided by Tatum</a></b>.</p><br/>\n<h4>2 credits per API call.</h4>\n<p>Gets a Ada account by address.</p>\n",
        "operationId": "AdaGetAccount",
        "deprecated": true,
        "parameters": [
          {
            "description": "Address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "Ae2tdPwUPEZMmrkRoduJW9w7wRvnTcdeMbw7yyyjwPqo6zuaeJaDEkHUJSz"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/AdaAccountBalance" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to perform the required operation due to a logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BtcBlockchain" },
                    { "$ref": "#/components/schemas/Error403Broadcast" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Gets a Ada account by address",
        "tags": ["Cardano"]
      }
    },
    "/v3/tatum/usage": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get information about your credit consumption for the last month (used credits per day).</p>\n",
        "operationId": "getCredits",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "items": { "$ref": "#/components/schemas/Consumption" }, "type": "array" }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get information about your credit consumption for the last month",
        "tags": ["Service utils"]
      }
    },
    "/v3/tatum/rate/{currency}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get currenct exchange rate of the supported FIAT / crypto asset. Base pair is EUR by default. E.g. to obtain exchange rate for the Bitcoin,\nresponse value for the API call will be expressed as 1 BTC = 10,000 EUR.</p>\n",
        "operationId": "getExchangeRate",
        "parameters": [
          {
            "description": "FIAT or crypto asset",
            "in": "path",
            "name": "currency",
            "required": true,
            "schema": {
              "type": "string",
              "example": "BTC",
              "enum": [
                "AED",
                "AFN",
                "ALL",
                "AMD",
                "ANG",
                "AOA",
                "ARS",
                "AUD",
                "AWG",
                "AZN",
                "BAM",
                "BAT",
                "BBD",
                "BCH",
                "BDT",
                "BGN",
                "BHD",
                "BIF",
                "BMD",
                "BNB",
                "BND",
                "BOB",
                "BRL",
                "BSC",
                "MATIC",
                "BSD",
                "BTC",
                "BTN",
                "BUSD",
                "BWP",
                "BYN",
                "BYR",
                "BZD",
                "CAD",
                "CAKE",
                "CDF",
                "CELO",
                "CHF",
                "CLF",
                "CLP",
                "CNY",
                "COP",
                "CRC",
                "CUC",
                "CUP",
                "CVE",
                "CZK",
                "DJF",
                "DKK",
                "DOP",
                "DOGE",
                "DZD",
                "EGLD",
                "EGP",
                "ERN",
                "ETB",
                "ETH",
                "EUR",
                "FJD",
                "FKP",
                "FLOW",
                "FUSD",
                "FREE",
                "GMC",
                "GMC_BSC",
                "RMD",
                "GBP",
                "GEL",
                "GGP",
                "GHS",
                "GIP",
                "GMD",
                "GNF",
                "GTQ",
                "GYD",
                "HKD",
                "HNL",
                "HRK",
                "HTG",
                "HUF",
                "IDR",
                "ILS",
                "IMP",
                "INR",
                "IQD",
                "IRR",
                "ISK",
                "JEP",
                "JMD",
                "JOD",
                "JPY",
                "KES",
                "KGS",
                "KHR",
                "KMF",
                "KPW",
                "KRW",
                "KWD",
                "KYD",
                "KZT",
                "LAK",
                "LBP",
                "LEO",
                "LINK",
                "LKR",
                "LRD",
                "LSL",
                "LTC",
                "LTL",
                "LVL",
                "LYD",
                "MAD",
                "MDL",
                "MGA",
                "MKD",
                "MKR",
                "MMK",
                "MMY",
                "MNT",
                "MOP",
                "MRO",
                "MUR",
                "MVR",
                "MWK",
                "MXN",
                "MYR",
                "MZN",
                "NAD",
                "NGN",
                "NIO",
                "NOK",
                "NPR",
                "NZD",
                "OMR",
                "PAB",
                "PAX",
                "PAXG",
                "PEN",
                "PGK",
                "PHP",
                "PKR",
                "PLN",
                "PYG",
                "QAR",
                "RON",
                "RSD",
                "RUB",
                "RWF",
                "SAR",
                "SBD",
                "SCR",
                "SDG",
                "SEK",
                "SGD",
                "SHP",
                "SLL",
                "SOS",
                "SRD",
                "STD",
                "SVC",
                "SYP",
                "SZL",
                "THB",
                "TJS",
                "TMT",
                "TND",
                "TOP",
                "TRY",
                "TTD",
                "TRON",
                "TUSD",
                "TWD",
                "TZS",
                "UAH",
                "UGX",
                "UNI",
                "USD",
                "USDC",
                "USDT",
                "USDT_TRON",
                "USDT_MATIC",
                "UYU",
                "UZS",
                "VEF",
                "VND",
                "VUV",
                "WST",
                "XAF",
                "XAG",
                "XAU",
                "XCD",
                "WBTC",
                "XCON",
                "XDR",
                "XLM",
                "XOF",
                "XPF",
                "XRP",
                "YER",
                "ZAR",
                "ZMK",
                "ZMW",
                "ZWL"
              ]
            }
          },
          {
            "description": "FIAT to convert as a basePair",
            "in": "query",
            "name": "basePair",
            "schema": {
              "type": "string",
              "example": "USD",
              "enum": [
                "AED",
                "AFN",
                "ALL",
                "AMD",
                "ANG",
                "AOA",
                "ARS",
                "AUD",
                "AWG",
                "AZN",
                "BAM",
                "BBD",
                "BDT",
                "BGN",
                "BHD",
                "BIF",
                "BMD",
                "BND",
                "BOB",
                "BRL",
                "BSD",
                "BTN",
                "BWP",
                "BYN",
                "BYR",
                "BZD",
                "CAD",
                "CDF",
                "CHF",
                "CLF",
                "CLP",
                "CNY",
                "COP",
                "CRC",
                "CUC",
                "CUP",
                "CVE",
                "CZK",
                "DJF",
                "DKK",
                "DOP",
                "DOGE",
                "DZD",
                "EGP",
                "ERN",
                "ETB",
                "ETH",
                "EUR",
                "FJD",
                "FKP",
                "FLOW",
                "FUSD",
                "GBP",
                "GEL",
                "GGP",
                "GHS",
                "GIP",
                "GMD",
                "GNF",
                "GTQ",
                "GYD",
                "HKD",
                "HNL",
                "HRK",
                "HTG",
                "HUF",
                "IDR",
                "ILS",
                "IMP",
                "INR",
                "IQD",
                "IRR",
                "ISK",
                "JEP",
                "JMD",
                "JOD",
                "JPY",
                "KES",
                "KGS",
                "KHR",
                "KMF",
                "KPW",
                "KRW",
                "KWD",
                "KYD",
                "KZT",
                "LAK",
                "LBP",
                "LKR",
                "LRD",
                "LSL",
                "LTL",
                "LVL",
                "LYD",
                "MAD",
                "MDL",
                "MGA",
                "MKD",
                "MMK",
                "MNT",
                "MOP",
                "MRO",
                "MUR",
                "MVR",
                "MWK",
                "MXN",
                "MYR",
                "MZN",
                "NAD",
                "NGN",
                "NIO",
                "NOK",
                "NPR",
                "NZD",
                "OMR",
                "PAB",
                "PEN",
                "PGK",
                "PHP",
                "PKR",
                "PLN",
                "PYG",
                "QAR",
                "RON",
                "RSD",
                "RUB",
                "RWF",
                "SAR",
                "SBD",
                "SCR",
                "SDG",
                "SEK",
                "SGD",
                "SHP",
                "SLL",
                "SOS",
                "SRD",
                "STD",
                "SVC",
                "SYP",
                "SZL",
                "THB",
                "TJS",
                "TMT",
                "TND",
                "TOP",
                "TRY",
                "TTD",
                "TWD",
                "TZS",
                "UAH",
                "UGX",
                "USD",
                "UYU",
                "UZS",
                "VEF",
                "VND",
                "VUV",
                "WST",
                "XAF",
                "XAG",
                "XAU",
                "XCD",
                "XDR",
                "XOF",
                "XPF",
                "YER",
                "ZAR",
                "ZMK",
                "ZMW",
                "ZWL"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/ExchangeRate" } } },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get currenct exchange rate of the supported FIAT / crypto asset",
        "tags": ["Exchange rate"]
      }
    },
    "/v3/tatum/version": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get current version of the API.</p>",
        "operationId": "getVersion",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "version": { "type": "string", "example": "3.0.2" },
                    "status": { "type": "string", "example": "ACTIVE" },
                    "testnet": { "type": "boolean", "example": true },
                    "planName": { "type": "string", "example": "Free" },
                    "planCode": { "type": "string", "example": "FREE" },
                    "price": { "type": "number", "example": 9 },
                    "expiration": { "type": "number", "example": 4113115784397 },
                    "creditLimit": { "type": "number", "example": 1000000000 },
                    "usage": { "type": "number", "example": 25656634 },
                    "rolloverDay": { "type": "number", "example": 4 }
                  }
                }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get API version",
        "tags": ["Service utils"]
      }
    },
    "/v3/tatum/freeze": {
      "put": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Freeze the API Key.\nIt's not possible to perform sensitive operations like send ledger transaction, send off-chain transaction, send blockchain transaction,\nbroadcast blockchain transaction, perform Order book trade or create blockage. Only read operations are permitted.</p>\n",
        "operationId": "freezeApiKey",
        "responses": {
          "204": { "description": "OK" },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Freeze API Key",
        "tags": ["Service utils"]
      },
      "delete": {
        "description": "<h4>2 credits per API call.</h4><br/><p>Unfreeze the API Key.\nIt's possible to perform sensitive operations like send ledger transaction, send off-chain transaction, send blockchain transaction,\nbroadcast blockchain transaction, perform Order book trade or create blockage again.</p>\n",
        "operationId": "unfreezeApiKey",
        "responses": {
          "204": { "description": "OK" },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server while processing the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Unfreeze API Key",
        "tags": ["Service utils"]
      }
    },
    "/v3/custodial/wallet": {
      "post": {
        "description": "<h4>2 credits per API call, 10 credits for each managed wallet every day.</h4><br/>\n<p>Create new managed address for a specific chain. If the address is mainnet or testnet one depends on the API Key - testnet API Key manages testnet addresses, mainnet API Key manages mainnet addresses.\nResult of the operation is address and walletId, which is used for identifying the wallet later on and/or exporting the private key if needed.<br/>\nFree users can manage only 10 addresses per API Key.\n</p>\n",
        "operationId": "CustodialCreateWallet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "chain": {
                    "type": "string",
                    "example": "SOL",
                    "enum": ["BSC", "ETH", "KLAY", "ONE", "CELO", "MATIC", "SOL", "LTC", "BTC", "TRON"]
                  }
                },
                "required": ["chain"]
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/CustodialManagedAddress" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Create managed address",
        "tags": ["Custodial managed wallets"]
      },
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get all managed addresses for an API Key.</p>\n",
        "operationId": "CustodialGetWallets",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "$ref": "#/components/schemas/CustodialManagedAddress" }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get managed addresses",
        "tags": ["Custodial managed wallets"]
      }
    },
    "/v3/custodial/wallet/{id}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get managed address for an API Key. It's possible to export the private key, if query parameter <b>export</b> is set to true.</p>\n",
        "operationId": "CustodialGetWallet",
        "parameters": [
          {
            "in": "path",
            "required": true,
            "description": "WalletID of the managed address",
            "name": "id",
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "3ad54647-4166-4d34-9186-fd46caaba945"
            }
          },
          {
            "in": "query",
            "name": "export",
            "required": false,
            "description": "If set to, export the private key details in the response",
            "schema": { "type": "boolean", "default": false, "enum": [true, false] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "$ref": "#/components/schemas/CustodialManagedAddress" }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get managed address",
        "tags": ["Custodial managed wallets"]
      },
      "delete": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Delete managed address. Once deleted, the address won't be charged in a daily credit usage, but it <b>won't be possible to get the private key</b> for it.</p>\n",
        "operationId": "CustodialDeleteWallet",
        "parameters": [
          {
            "in": "path",
            "required": true,
            "description": "WalletID of the managed address",
            "name": "id",
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "3ad54647-4166-4d34-9186-fd46caaba945"
            }
          }
        ],
        "responses": {
          "204": { "description": "OK" },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Delete managed address",
        "tags": ["Custodial managed wallets"]
      }
    },
    "/v3/custodial/transaction": {
      "post": {
        "description": "<h4>2 credits per API call, additional credits are charged for each gas covered operation.</h4><br/>\n<p>Sign transaction and transfer assets from a custodial managed address.<br/>\nSupported chains:\n<ul>\n<li><b>Solana</b></li>\n</ul>\n<br/>\nLogic for <b>Solana</b><br/>\nIn Solana, it's possible to cover the fees connected to any arbitrary transaction by a third party.\nTatum can cover these fees for any transaction on the Solana blockchain - transfer of SOL, SPL tokens, minting or transferring NFTs or invoking programs.\nIn order to do this, Tatum fee address must be used as a feePayer address during transaction creation:\n<table>\n<tr><td></td><td><b>Mainnet address</b></td><td><b>Devnet address</b></td></tr>\n<tr><td><b>Address</b></td><td>DSpHmb7hLnetoybammcJBJiyqMVR3pDhCuW6hqVg9eBF</td><td>DSpHmb7hLnetoybammcJBJiyqMVR3pDhCuW6hqVg9eBF</td></tr>\n</table>\nOnce transaction is constructed using <a href=\"https://github.com/solana-labs/solana-web3.js/\" target=\"_blank\">Solana SDK</a>, it can be serialized to HEX data string, which is then passed to the API and signed.<br/>\nTransaction could require multiple private keys for signing - fee payer, sender of the SOL assets, minting key during NFT mint operation etc.\nSome of the keys are used in Tatum - fee payer, or, in case of managed wallet holding SOL assets, the key of that managed wallet - those must be referenced in a list of walletIds to be used.\nFor external keys, which are not managed by Tatum, those could either sign the transaction before it's serialization, or could be passed to the API in it's raw form - this is OK only for keys, which could be exposed and there is no harm of loosing assets on them.<br/>\nHow to partially sign the transaction could be found <a href=\"https://solanacookbook.com/references/offline-transactions.html#partial-sign-transaction\" target=\"_blank\">here</a>.<br/>\n<b>Fee payer key is used by default, doesn't have to be mentioned in the list of wallets used for signing.</b><br/><br/>\n<b>Examples of different transaction payloads.</b><br/><br/>\n1. Send SOL from account HrJtQTy2RW9c6y41RvN8x3bEiD6Co74AuhER2MGCpa58 to FZAS4mtPvswgVxbpc117SqfNgCDLTCtk5CoeAtt58FWU\n<pre>\nimport { LAMPORTS_PER_SOL, PublicKey, SystemProgram, Transaction, Connection } from '@solana/web3.js'\n\nconst connection = new Connection('https://api-eu1.tatum.io/v3/blockchain/node/SOL')\nconst from = 'HrJtQTy2RW9c6y41RvN8x3bEiD6Co74AuhER2MGCpa58'\nconst to = 'FZAS4mtPvswgVxbpc117SqfNgCDLTCtk5CoeAtt58FWU'\nconst amount = '0.000001'\nconst devnet_fee_payer = '5zPr5331CtBjgVeLedhmJPEpFaUsorLCnb3aCQPsUc9w'\nconst fromPubkey = new PublicKey(from)\nconst transaction = new Transaction({ feePayer: new PublicKey(devnet_fee_payer) })\ntransaction.add(\n  SystemProgram.transfer({\n    fromPubkey: fromPubkey,\n    toPubkey: new PublicKey(to),\n    lamports: new BigNumber(amount).multipliedBy(LAMPORTS_PER_SOL).toNumber(),\n  }),\n)\nconst { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized')\ntransaction.recentBlockhash = blockhash\ntransaction.lastValidBlockHeight = lastValidBlockHeight\ntransaction.partialSign(...signers)\nreturn transaction.serialize({ requireAllSignatures: false }).toString('hex')\n</pre>\nFor the above example, developer have 2 options how to sign transaction - if the sender address HrJtQTy2RW9c6y41RvN8x3bEiD6Co74AuhER2MGCpa58 is managed using a Tatum managed wallet with id 0b1eae3d-2520-4903-8bbf-5dec3ad2a5d4,\nthe final payload to the custodial/transaction endpoint should look like this:\n<pre>\n{\n  \"chain\": \"SOL\",\n  \"txData\": \"020001044a22af97a838a504e6f7c0b18d779afcea612da50794cc1dac641861fc1ab14afa5cacaf91c298694e64bb5496916c3c68a32affb92d4bcd2736fbb00169d57bd840de2a454960308f688cd3ee308c1fa01ecfa0b03770aaaf3b52d71d46c31d000000000000000000000000000000000000000000000000000000000000000060d38e0da20dc5900b7e902c918eae6a95e2d90af154b53a422f4ab26b050f4f01030201020c02000000e803000000000000\",\n  \"walletIds\": [\n    {\n      \"key\": \"0b1eae3d-2520-4903-8bbf-5dec3ad2a5d4\",\n      \"type\": \"MANAGED\"\n    }\n  ]\n}\n</pre>\nIf the sender address is not managed, the transaction could be signed with the private key of that address before the serialization and the payload will look like this:\n<pre>\n{\n  \"chain\": \"SOL\",\n  \"txData\": \"020001044a22af97a838a504e6f7c0b18d779afcea612da50794cc1dac641861fc1ab14afa5cacaf91c298694e64bb5496916c3c68a32affb92d4bcd2736fbb00169d57bd840de2a454960308f688cd3ee308c1fa01ecfa0b03770aaaf3b52d71d46c31d000000000000000000000000000000000000000000000000000000000000000060d38e0da20dc5900b7e902c918eae6a95e2d90af154b53a422f4ab26b050f4f01030201020c02000000e803000000000000\",\n  \"walletIds\": []\n}\n</pre>\n</p>\n",
        "operationId": "CustodialTransferManagedAddress",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/TransferManagedAddress" } }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Sign and transfer using managed address",
        "tags": ["Custodial managed wallets"]
      }
    },
    "/v3/nft/deploy": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs.<br/>\nSmart contracts are standardized and audited.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p>By default, an NFT smart contract is deployed as a <b>general ERC-721 smart contract compatible with OpenSea royalties</b>. This is a standard ERC-721 contract with <code>AccessControl</code> and <code>Ownable</code>, enhanced with NFT batch minting. NFTs minted in this smart contract are compatible with OpenSea and its royalty structure.<p>\n<p>In addition to the general ERC-721 contract, you can also deploy the following types of NFT smart contracts for the supported blockchains <b>except for Flow and TRON</b>:<p>\n<ul>\n<li><b>Cashback ERC-721 smart contract</b> is an ERC-721 smart contract that forces on-chain royalties to be paid every time an NFT is transferred. The royalties are defined as a fixed value and are <b>not</b> OpenSea-compatible.<br />\nTo deploy an NFT smart contract as a cashback contract, deploy the contract with the <code>cashback</code> parameter set to <code>true</code> in the request body.</li>\n<li><b>Provenance ERC-721 smart contract</b> is an ERC-721 smart contract that forces on-chain royalties to be paid every time an NFT is transferred. The royalties are defined as a percentage of the NFT price and are <b>not</b> OpenSea-compatible.<br />\nTo deploy an NFT smart contract as a provenance contract, deploy the contract with the <code>provenance</code> parameter set to <code>true</code> in the request body.</li>\n</ul>\n<p>You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftAddMinter\" target=\"_blank\">added to the smart contract as NFT minters</a> will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the <code>publicMint</code> parameter set to <code>true</code> in the request body.</p>\n<p>You can review the code of a deployed NFT smart contract <a href=\"https://github.com/tatumio/flow-contracts\" target=\"_blank\">here</a> (if the contract is deployed on Flow) or <a href=\"https://github.com/tatumio/smart-contracts/tree/master/contracts/tatum\" target=\"_blank\">here</a> (if the contract is deployed on any other supported blockchain).</p>\n<p><b>Signing a transaction</b></p>\n<p>When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftDeployErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployNft" },
                  { "$ref": "#/components/schemas/DeployNftCelo" },
                  { "$ref": "#/components/schemas/DeployNftTron" },
                  { "$ref": "#/components/schemas/DeployNftKMS" },
                  { "$ref": "#/components/schemas/DeployNftCeloKMS" },
                  { "$ref": "#/components/schemas/DeployNftTronKMS" },
                  { "$ref": "#/components/schemas/DeployNftFlowPK" },
                  { "$ref": "#/components/schemas/DeployNftFlowMnemonic" },
                  { "$ref": "#/components/schemas/DeployNftFlowKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy an NFT smart contract",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/mint": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>You can mint NFTs using either of the following methods:</p>\n<ul>\n<li><a href=\"#NftExpress\">Using NFT Express</a></li>\n<li><a href=\"#NftNative\">Natively on a blockchain</a></li>\n</ul>\n<h3 id=\"NftExpress\">Minting NFTs using NFT Express</h3>\n<p>NFT Express is Tatum's feature that helps you mint NFTs easier than minting natively on a blockchain.</p>\n<ul>\n<li><b>You do not need to enter your private key or signature ID.</b><br/>NFT Express uses the private key provided by Tatum.</li>\n<li><b>You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions.</b>\n<ul>\n<li>To use NFT Express on the <b>mainnet</b>, you have to have a <a href=\"https://tatum.io/pricing\" target=\"_blank\">paid pricing plan</a>.<br/>Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan.<br/>The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on.</li>\n<li>On the <b>testnet</b>, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan.</li>\n</ul>\n</li>\n</ul>\n<p>With NFT Express, you can choose whether to mint NFTs on the <a href=\"#NftExpressPrebuilt\">pre-built NFT smart contract provided by Tatum</a> or on <a href=\"#NftExpressOwn\">your own smart contract</a>.</p>\n<h4 id=\"NftExpressPrebuilt\">Minting NFTs using the pre-built smart contract provided by Tatum</h4>\n<p>If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum.<br/>The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet.</p>\n<p>You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>Solana</li>\n</ul>\n<p>Depending on what blockchain you use, choose the request body schema to use in the API call.</p>\n<ul>\n<li>To mint NFTs on <b>BNB Smart Chain</b>, <b>Celo</b>, <b>Ethereum</b>, <b>Harmony</b>, <b>Klaytn</b>, or <b>Polygon</b>, use this API with the <code>MintNftExpress</code> schema of the request body.</li>\n<li>To mint NFTs on <b>Algorand</b>, use this API with the <code>MintNftExpressAlgorand</code> schema of the request body.<br/>To be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFTs</a> any time later, specify the address of the manager account in the <code>manager</code> parameter.<br/>An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient's address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed.<br/>This how it works:\n<ol>\n<li>The recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">agrees to receive the NFT</a> to their address.</li>\n<li>You <a href=\"#operation/NftTransferErc721\">transfer the NFT</a> to the recipient's address (use the <code>transferNftAlgoExpress</code> schema of the request body).<br /><b>NOTE:</b> On the <b>mainnet</b>, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the <b>testnet</b>, no credits are deducted from the monthly credit allowance.</li>\n</ol></li>\n<li>To mint NFTs on <b>Solana</b>, use this API with the <code>MintNftExpressSolana</code> schema of the request body.<br/>Solana uses the <a href=\"https://www.metaplex.com/\" target=\"_blank\">Metaplex Protocol</a>, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used.<br/>When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient's account address (the one in the <code>to</code> parameter of the request body). This address is returned in the <code>nftAccountAddress</code> parameter in the response body, is owned by the recipient's address, and has the same private key.<br/>The response body also returns the address of the minted NFT itself, which is held in the <code>nftAddress</code> parameter.<br/>After the NFT is minted, you have to <a href=\"#operation/NftTransferErc721\">transfer it</a> to the recipient's address (use the <code>transferNftSolana</code> or <code>transferNftSolanaKMS</code> schema of the request body). In the request body of the transfer call:\n<ul>\n<li>Set the <code>from</code> parameter to the address that you used in the <code>to</code> parameter in the request body of the minting call.</li>\n<li>Set the <code>to</code> parameter to the recipient's address.</li>\n<li>Set the <code>contractAddress</code> parameter to the address from the <code>nftAddress</code> parameter returned in the response body of the minting call.</li>\n<li>Set the <code>fromPrivateKey</code>/<code>signatureId</code> parameter to the private key/signature ID of the blockchain address that you specified in the <code>from</code> parameter.</li>\n</ul></li></ul>\n<h4 id=\"NftExpressOwn\">Minting NFTs with NFT Express using your own smart contract</h4>\n<p>If you want to mint NFTs using your own smart contract, you are going to use an <b>NTF minter</b>, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan.<br/>\n<p>You can mint NFTs on your own smart contract on the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p>To mint NFTs using your own smart contract, do the following:</p>\n<ol>\n<li>In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet).</li>\n<li><a href=\"#operation/NftAddMinter\">Add the minter address as an NFT minter to your smart contract</a>.</li>\n<li>Use this API with the <code>MintNftMinter</code> schema of the request body.<br />In the request body, enter the following information:\n<ul>\n<li><code>chain</code> is the blockchain that you use.</li>\n<li><code>to</code> is the blockchain address where to send the minted NFT to.</li>\n<li><code>url</code> is the URL of the NFT metadata.</li>\n<li><code>minter</code> is the address of the NFT minter that you found in Step 1.</li>\n<li><code>contractAddress</code> is the address of your NFT smart contract.</li>\n<li><code>tokenId</code> is the the token ID of the NFT.<br />For example:\n<pre>\n{\n  \"chain\": \"CELO\",\n  \"to\": \"0x8ce4e40889a13971681391aad29e88efaf91f784\",\n  \"url\": \"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\",\n  \"contractAddress\": \"0x687422eEA2cB73B5d3e242bA5456b782919AFc85\",\n  \"tokenId\": \"0123\",\n  \"minter\": \"0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\"\n}\n</pre>\nWhen you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:\n<pre>\n{\n  \"chain\": \"CELO\",\n  \"to\": \"0x8ce4e40889a13971681391aad29e88efaf91f784\",\n  \"url\": \"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\",\n  \"contractAddress\": \"0x687422eEA2cB73B5d3e242bA5456b782919AFc85\",\n  \"tokenId\": \"0123\",\n  \"minter\": \"0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\",\n  \"fromPrivateKey\": \"0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\"\n}\n</pre>                               \n</li></ul></li>\n</ol>\n<p>The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains:</p>\n<table>\n  <tr>\n    <th>Blockchain</th>\n    <th>Minter address - testnet*</th>\n    <th>Minter address - mainnet</th>\n  </tr>\n  <tr>\n    <td>BNB Smart Chain</td>\n    <td>0xc16ae5e8c985b906935a0cadf4e24f0400531883</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Celo</td>\n    <td>0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Ethereum</td>\n    <td>0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Harmony</td>\n    <td>0x8906f62d40293ddca77fdf6714c3f63265deddf0</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Klaytn</td>\n    <td>0x80d8bac9a6901698b3749fe336bbd1385c1f98f2</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Polygon</td>\n    <td>0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n</table>\n<p>*If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain.</p>\n<h3 id=\"NftNative\">Minting NFTs natively on a blockchain</h3>\n<p>When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n<p>You can mint NFTs natively on the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>        \n<p>Depending on what blockchain you use, choose the request body schema to use in the API call.</p>\n<ul>\n<li>To mint NFTs natively on <b>Algorand</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftAlgorand</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftAlgorandKMS</code> schema of the request body.<br/><b>NOTE:</b><ul><li>To be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFTs</a> any time later, specify the address of the manager account in the <code>manager</code> parameter.</li><li>An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient's address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the <a href=\"#NftExpressPrebuilt\">pre-built NFT smart contract provided by Tatum</a>.</li></ul></li></ul></li>\n<li>To mint NFTs natively on <b>BNB Smart Chain</b>, <b>Ethereum</b>, <b>Harmony</b>, <b>Klaytn</b>, <b>KuCoin Community Chain</b>, or <b>Polygon</b>, and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNft</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftKMS</code> schema of the request body.</li></ul></li>\n<li>To mint NFTs natively on <b>Celo</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftCelo</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftKMSCelo</code> schema of the request body.</li></ul></li>\n<li>To mint NFTs natively on <b>Flow</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftFlowPK</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftFlowMnemonic</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>wallet mnemonic</b>, use this API the <code>MintNftFlowKMS</code> schema of the request body.</li></ul></li>\n<li>To mint NFTs natively on <b>Solana</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftSolana</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftSolanaKMS</code> schema of the request body.<br/><b>NOTE:</b> When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient's account address. After the NFT is minted, you have to transfer it to the recipient's address. For more information about how it works, see the section about minting NFTs on Solana using the <a href=\"#NftExpressPrebuilt\">pre-built NFT smart contract provided by Tatum</a>.</li></ul></li>\n<li>To mint NFTs natively on <b>TRON</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftTron</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftKMSTron</code> schema of the request body.</li></ul></li>\n</ul>\n",
        "operationId": "NftMintErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/MintNftExpress" },
                  { "$ref": "#/components/schemas/MintNftExpressSolana" },
                  { "$ref": "#/components/schemas/MintNftExpressAlgorand" },
                  { "$ref": "#/components/schemas/MintNftSolana" },
                  { "$ref": "#/components/schemas/MintNftMinter" },
                  { "$ref": "#/components/schemas/MintNft" },
                  { "$ref": "#/components/schemas/MintNftCelo" },
                  { "$ref": "#/components/schemas/MintNftAlgorand" },
                  { "$ref": "#/components/schemas/MintNftFlowPK" },
                  { "$ref": "#/components/schemas/MintNftFlowMnemonic" },
                  { "$ref": "#/components/schemas/MintNftTron" },
                  { "$ref": "#/components/schemas/MintNftKMS" },
                  { "$ref": "#/components/schemas/MintNftSolanaKMS" },
                  { "$ref": "#/components/schemas/MintNftKMSCelo" },
                  { "$ref": "#/components/schemas/MintNftKMSTron" },
                  { "$ref": "#/components/schemas/MintNftAlgorandKMS" },
                  { "$ref": "#/components/schemas/MintNftFlowKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/FlowMintedResult" },
                    { "$ref": "#/components/schemas/SolanaMintedResult" },
                    { "$ref": "#/components/schemas/AlgorandMintedResult" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Mint an NFT",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/transaction": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Transfer an NFT from the smart contract (the <code>contractAddress</code> parameter in the request body) to the specified blockchain address (the <code>to</code> parameter in the request body).</p>\n<p>In one API call, you can transfer only one NFT.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n<p>For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the <code>safeTransfer()</code> method.</p>\n<p><b>Transferring NFTs on Algorand</b></p>\n<ul>\n<li>On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">has agreed to receive the NFT</a> to their address.</li>\n<li>If you want to transfer an NFT that <a href=\"#operation/NftMintErc721\">was minted using NFT Express</a>, use the <code>transferNftAlgoExpress</code> schema of the request body.<br /><b>NOTE:</b> On the <b>mainnet</b>, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the <b>testnet</b>, no credits are deducted from the monthly credit allowance.</li>\n</ul>\n<p><b>Transferring NFTs on Solana</b><br/>\nIf you want to transfer an NFT that <a href=\"#operation/NftMintErc721\">was minted using NFT Express</a>, see the section about minting NFTs on Solana using the <a href=\"#operation/NftMintErc721\">pre-built NFT smart contract provided by Tatum</a> for the information about how to set up the parameters in the request body.</p>\n<p><b>Signing a transaction</b><br/>\nWhen transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n<p><b>NOTE:</b> This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).</p>\n",
        "operationId": "NftTransferErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferNft" },
                  { "$ref": "#/components/schemas/TransferNftCelo" },
                  { "$ref": "#/components/schemas/TransferNftTron" },
                  { "$ref": "#/components/schemas/TransferNftSolana" },
                  { "$ref": "#/components/schemas/TransferNftAlgo" },
                  { "$ref": "#/components/schemas/TransferNftAlgoExpress" },
                  { "$ref": "#/components/schemas/TransferNftFlowPK" },
                  { "$ref": "#/components/schemas/TransferNftFlowMnemonic" },
                  { "$ref": "#/components/schemas/TransferNftKMS" },
                  { "$ref": "#/components/schemas/TransferNftKMSCelo" },
                  { "$ref": "#/components/schemas/TransferNftAlgoKMS" },
                  { "$ref": "#/components/schemas/TransferNftSolanaKMS" },
                  { "$ref": "#/components/schemas/TransferNftFlowKMS" },
                  { "$ref": "#/components/schemas/TransferNftKMSTron" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transfer an NFT",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/mint/batch": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\nThis operation works in two modes.\n\nFirst mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n\nSecond mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don't specify private key or signatureId, only minter address, from which the NFT will be minted.<br/>\nIt means you perform mint multiple NFT request with following body:\n<pre>{\n   \"to\": [\"0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\"],\n   \"url\": [\"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\"],\n   \"tokenId\": [\"9876541124516\"],\n   \"contractAddress\":\"0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\",\n   \"minter\": \"0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\",\n   \"chain\": \"MATIC\"\n}</pre>\nThe blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debitted in form of credits. The credits are debitted only if NFT mint requests are performed with paid API key plan.\nWe transform fee to the credits in accordance to the rates provided by the Tatum.\nIf you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method:\n<pre>mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean</pre>\nYou can use addresses specified in the bellow table to be used as a minter.\n<table>\n  <tr>\n    <th>Chain</th>\n    <th>Testnet address</th>\n    <th>Mainnet Address</th>\n  </tr>\n  <tr>\n    <td>MATIC</td>\n    <td>0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>BSC</td>\n    <td>0xc16ae5e8c985b906935a0cadf4e24f0400531883</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>ONE</td>\n    <td>0x8906f62d40293ddca77fdf6714c3f63265deddf0</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>ETH</td>\n    <td>0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>CELO</td>\n    <td>0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>KLAY</td>\n    <td>0x80d8bac9a6901698b3749fe336bbd1385c1f98f2</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n</table>\nIf there are not enough coins on any testnet address, feel free to send coins there.</p>\n",
        "operationId": "NftMintMultipleErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/MintMultipleNftMinter" },
                  { "$ref": "#/components/schemas/MintMultipleNft" },
                  { "$ref": "#/components/schemas/MintMultipleNftCelo" },
                  { "$ref": "#/components/schemas/MintMultipleNftTron" },
                  { "$ref": "#/components/schemas/MintMultipleNftFlowPK" },
                  { "$ref": "#/components/schemas/MintMultipleNftFlowMnemonic" },
                  { "$ref": "#/components/schemas/MintMultipleNftKMS" },
                  { "$ref": "#/components/schemas/MintMultipleNftKMSCelo" },
                  { "$ref": "#/components/schemas/MintMultipleNftKMSTron" },
                  { "$ref": "#/components/schemas/MintMultipleNftFlowKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/FlowMintedMultipleResult" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Mint multiple NFTs",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/burn": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p><b>Burning NFTs on Algorand</b><br/>\nYou can burn only the NFTs that were minted with the address of the manager account specified in the <code>manager</code> parameter in the <a href=\"#operation/NftMintErc721\">minting call</a> (see the <code>MintNftExpressAlgorand</code>, <code>MintNftAlgorand</code>, and <code>MintNftAlgorandKMS</code> schemas of the request body).</p>\n<p><b>Signing a transaction</b><br/>\nWhen burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftBurnErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BurnNft" },
                  { "$ref": "#/components/schemas/BurnNftCelo" },
                  { "$ref": "#/components/schemas/BurnNftAlgo" },
                  { "$ref": "#/components/schemas/BurnNftKMSCelo" },
                  { "$ref": "#/components/schemas/BurnNftTron" },
                  { "$ref": "#/components/schemas/BurnNftKMSTron" },
                  { "$ref": "#/components/schemas/BurnNftKMS" },
                  { "$ref": "#/components/schemas/BurnNftFlowPK" },
                  { "$ref": "#/components/schemas/BurnNftFlowMnemonic" },
                  { "$ref": "#/components/schemas/BurnNftFlowKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Burn an NFT",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/mint/add": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Add new minter of NFT Tokens. This method adds minter permission to new minter address.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftAddMinter",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/AddNftMinter" },
                  { "$ref": "#/components/schemas/AddNftMinterKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Add an NFT minter",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/verify": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Verify an NFT in an NFT collection on Solana. Verifying an NFT sets the <code>Verified</code> parameter to <code>true</code> for the NFT, which means that the NFT is really a part of the collection. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>.</p>\n<p>The collection must be a sized collection that was introduced in <a href=\"https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\" target=\"_blank\">Version 1.3</a> of the Metaplex Token Metadata program. The NFT must have been <a href=\"#operation/NftMintErc721\">minted in this collection</a>.</p>\n<p>This API is supported only for Solana.</p>\n<p><b>Signing a transaction</b></p>\n<p>When verifying an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftVerifyInCollection",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/VerifySolanaNFT" },
                  { "$ref": "#/components/schemas/VerifySolanaNFTKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Verify an NFT in an NFT collection on Solana",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/royalty": {
      "put": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Update royalty cashback value for one NFT Token. This method updates the first royalty value of specific author for 1 token.\nIf royalty value is set to 0, it will disable the royalty system for the token. Only from author's address of the royalty can change it's royalty value, not the owner of the token.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftUpdateCashbackErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNft" },
                  { "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftCelo" },
                  { "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftTron" },
                  { "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftKMS" },
                  { "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftKMSCelo" },
                  { "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftKMSTron" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Update NFT royalty",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/transaction/{chain}/{address}/{tokenAddress}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get incoming and outgoing NFT transactions on a blockchain address.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "NftGetTransactionByAddress",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["CELO", "ETH", "MATIC"], "example": "CELO" }
          },
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x1ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 0, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 0, "example": 1087823 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "oneOf": [{ "$ref": "#/components/schemas/NftTx" }] }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT transactions on a blockchain address",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/transaction/tokenId/{chain}/{tokenAddress}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p> <p>Get NFT transactions by token. This includes incoming and outgoing transactions for the token.</p> <p>This API is supported for the following blockchains:</p> <ul> <li>Celo</li> <li>Ethereum</li> <li>Polygon</li> </ul>",
        "operationId": "NftGetTransactionByToken",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["CELO", "ETH", "MATIC"], "example": "CELO" }
          },
          {
            "description": "NFT Token ID",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": { "type": "integer", "minimum": 0, "example": 1 }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x1ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 0, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 0, "example": 1087823 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "oneOf": [{ "$ref": "#/components/schemas/NftTx" }] }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT transactions for an NFT",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/transaction/{chain}/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get NFT transaction by transaction hash.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetTransactErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "CELO", "TRON", "FLOW", "BSC"]
            }
          },
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/CeloTx" },
                    { "$ref": "#/components/schemas/EthTx" },
                    { "$ref": "#/components/schemas/FlowTx" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get an NFT transaction by its hash",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/address/balance/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call + 5 credits for each owned NFT</b></p>\n<p>Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n<li>Solana</li>\n</ul>\n<p>On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT's metadata. If the metadata is not returned, you can obtain it using the <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)/#operation/NftGetMetadataErc721\">API for getting NFT metadata</a>.</p>\n",
        "operationId": "NftGetTokensByAddressErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "example": "SOL", "enum": ["ALGO", "CELO", "ETH", "MATIC", "SOL"] }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["contractAddress", "balances"],
                    "properties": {
                      "contractAddress": {
                        "type": "string",
                        "example": "43821281",
                        "description": "On Algorand, this is the asset ID (the ID of the NFT); on the other blockchains, this is the address of the NFT smart contract"
                      },
                      "balances": {
                        "type": "array",
                        "description": "On Algorand, this is an array of <code>1</code> to indicate that the NFTs with the specified IDs exist; on the other blockchains, this is an array of the IDs of the NFTs",
                        "items": { "type": "string", "example": "1" }
                      },
                      "metadata": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "tokenId": {
                              "description": "(EVM-based blockchains only) The ID of the NFT owned by this address",
                              "example": "1",
                              "type": "string"
                            },
                            "url": {
                              "description": "The URL pointing to the NFT metadata; the URL may not be present, and if it is not returned, you can get it by calling the NFT Contract.tokenURI() method",
                              "example": "ipfs://QmXFpaS3S7CkLZvihLFA9JbawKdqhjg8dJeDkPntmkD2Pc",
                              "type": "string"
                            },
                            "metadata": {
                              "type": "object",
                              "description": "The metadata scheme obtained from the metadata URL; the scheme may not be present, and if it is not returned, you can get it using the <a href=\"#operation/NftGetMetadataErc721\">NFT metadata API</a>",
                              "example": {
                                "name": "Example NFT name",
                                "description": "Example NFT description",
                                "image": "ipfs://QmP4R7ACZ7JRQ6sLdmnPHqjWEXxzdnPvhAV2f6RnQ8uxJ6"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get all NFTs that a blockchain address holds",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/collection/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call + 5 credits for each listed NFT</b></p>\n<p>Get all minted NFTs in the collection. Returns all NFTs this contract minted.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "NftGetTokensByCollectionErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "example": "ETH", "enum": ["CELO", "MATIC", "ETH"] }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Collection address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x80d8bac9a6901698b3749fe336bbd1385c1f98f2" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["tokenId", "metadata"],
                    "properties": {
                      "tokenId": {
                        "type": "string",
                        "example": "43821281",
                        "description": "ID of the token."
                      },
                      "metadata": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["tokenID"],
                          "properties": {
                            "tokenId": {
                              "description": "TokenID of the NFT token owned by this address.",
                              "example": "1",
                              "type": "string"
                            },
                            "url": {
                              "description": "Metadata URL of the TokenID. This data don't have to be present, safest way (if not present) is to obtain them from the NFT Contract.tokenURI() method call.",
                              "example": "ipfs://QmXFpaS3S7CkLZvihLFA9JbawKdqhjg8dJeDkPntmkD2Pc",
                              "type": "string"
                            },
                            "metadata": {
                              "type": "object",
                              "description": "Metadata scheme obtained from the url. This data don't have to be present, safest way (if not present) is to obtain them from the NFT Contract.tokenURI() method call.",
                              "example": {
                                "name": "Example NFT name",
                                "description": "Example NFT description",
                                "image": "ipfs://QmP4R7ACZ7JRQ6sLdmnPHqjWEXxzdnPvhAV2f6RnQ8uxJ6"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFTs from a collection",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/balance/{chain}/{contractAddress}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the NFTs minted on a specific smart contract (the <code>contractAddress</code> path parameter in the request endpoint URL) that a blockchain address holds.</p>\n<p><b>NOTE:</b> This API works only for the NFT smart contracts deployed using the <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftDeployErc721\" target=\"_blank\">Tatum smart contract API</a>.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Elrond</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetBalanceErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ETH",
                "MATIC",
                "KCS",
                "ONE",
                "KLAY",
                "CELO",
                "TRON",
                "FLOW",
                "BSC",
                "SOL",
                "ALGO",
                "EGLD"
              ]
            }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          },
          {
            "description": "The address of the NFT smart contract",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/NftGetBalanceScAlgo" },
                    { "$ref": "#/components/schemas/NftGetBalanceSc" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the NFTs from a specific smart contract that a blockchain address holds",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/provenance/{chain}/{contractAddress}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get NFT token provenance data, valid only for provenance contract.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "NftGetProvenanceDataErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "CELO", "BSC"] }
          },
          {
            "description": "Token ID",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": { "type": "string", "example": "1", "maxLength": 32 }
          },
          {
            "description": "NFT contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "provenanceData": {
                        "type": "string",
                        "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
                      },
                      "tokenPrice": { "type": "string", "example": "123" }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT provenance data",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/metadata/{chain}/{contractAddress}/{token}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get NFT token metadata.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetMetadataErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["ETH", "MATIC", "KCS", "SOL", "ONE", "KLAY", "CELO", "TRON", "FLOW", "BSC"]
            }
          },
          {
            "description": "NFT contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Token ID, required for all except SOL",
            "in": "path",
            "name": "token",
            "required": false,
            "schema": { "type": "string", "example": "1", "maxLength": 32 }
          },
          {
            "description": "Account holding this token. FLOW only.",
            "in": "query",
            "required": false,
            "name": "account",
            "schema": { "type": "string", "example": "0xc1b45bc27b9c61c3" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "string",
                      "description": "Metadata associated with token.",
                      "example": "https://my_token_data.com"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT metadata",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/royalty/{chain}/{contractAddress}/{token}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get NFT token royalty.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetRoyaltyErc721",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["ETH", "MATIC", "KCS", "SOL", "ONE", "KLAY", "CELO", "TRON", "BSC"]
            }
          },
          {
            "description": "NFT contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Token ID, required for all except SOL",
            "in": "path",
            "name": "token",
            "required": false,
            "schema": { "type": "string", "example": "1", "maxLength": 32 }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "addresses": {
                      "type": "array",
                      "description": "Addresses of the authors where cashback will be paid.",
                      "items": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
                    },
                    "values": {
                      "type": "array",
                      "description": "Values of the royalties, which will be paid to the authors with every token transfer.\nAmount is in native asset of the blockchain or in percents for SOL NFTs.\n",
                      "items": { "type": "string", "example": "0.2" }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get NFT royalty information",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/nft/address/{chain}/{hash}": {
      "get": {
        "description": "<p><p>This endpoint is deprecated. Do not use it.<br/>\nInstead, use <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">this API</a>.</b></p><br/>\n<p><b>1 credit per API call</b></p>\n<p>Get NFT contract address from deploy transaction.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "deprecated": true,
        "operationId": "NftGetContractAddress",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["ETH", "ONE", "KLAY", "CELO", "TRON", "FLOW", "MATIC", "KCS", "BSC"]
            }
          },
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "Address of the NFT token.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the address of an NFT smart contract by its transaction hash",
        "tags": ["NFT (ERC-721 or compatible)"]
      }
    },
    "/v3/blockchain/token/deploy": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the <code>supply</code> parameter in the request body) will be transferred to the specified blockchain address (the <code>address</code> parameter in the request body).<br/>\nSmart contracts are standardized and audited.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>Algorand</li>\n<li>XinFin</li>\n</ul>\n<p>You can review the code of a deployed smart contract <a href=\"https://github.com/tatumio/tatum-middleware/blob/master/src/contracts/token.sol\" target=\"_blank\">here</a>.</p>\n<p><b>Signing a transaction</b></p>\n<p>When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "Erc20Deploy",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ChainDeployErc20" },
                  { "$ref": "#/components/schemas/ChainDeploySolanaSpl" },
                  { "$ref": "#/components/schemas/ChainDeployCeloErc20" },
                  { "$ref": "#/components/schemas/ChainDeployKcsErc20" },
                  { "$ref": "#/components/schemas/ChainDeployAlgoErc20" },
                  { "$ref": "#/components/schemas/ChainDeployErc20KMS" },
                  { "$ref": "#/components/schemas/ChainDeploySolanaSplKMS" },
                  { "$ref": "#/components/schemas/ChainDeployCeloErc20KMS" },
                  { "$ref": "#/components/schemas/ChainDeployKcsErc20KMS" },
                  { "$ref": "#/components/schemas/ChainDeployAlgoErc20KMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a fungible token smart contract",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/mint": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Create new fungible tokens in the smart contract (the <code>contractAddress</code> parameter in the request body) and transfer them to the specified blockchain address (the <code>to</code> parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>XinFin</li>\n<li>Algorand</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "operationId": "Erc20Mint",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ChainMintErc20" },
                  { "$ref": "#/components/schemas/ChainMintErc20KMS" },
                  { "$ref": "#/components/schemas/ChainMintKcsErc20" },
                  { "$ref": "#/components/schemas/ChainMintKcsErc20KMS" },
                  { "$ref": "#/components/schemas/ChainMintCeloErc20" },
                  { "$ref": "#/components/schemas/ChainMintCeloErc20KMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Mint fungible tokens",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/burn": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the <code>amount</code> parameter in the request body) from the smart contract (the <code>contractAddress</code> parameter in the request body).</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>XinFin</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "operationId": "Erc20Burn",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ChainBurnErc20" },
                  { "$ref": "#/components/schemas/ChainBurnErc20KMS" },
                  { "$ref": "#/components/schemas/ChainBurnKcsErc20" },
                  { "$ref": "#/components/schemas/ChainBurnKcsErc20KMS" },
                  { "$ref": "#/components/schemas/ChainBurnCeloErc20" },
                  { "$ref": "#/components/schemas/ChainBurnCeloErc20KMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Burn fungible tokens",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/approve": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Allow another blockchain address (the <code>spender</code> parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "operationId": "Erc20Approve",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ApproveErc20" },
                  { "$ref": "#/components/schemas/ApproveErc20KMS" },
                  { "$ref": "#/components/schemas/ApproveCeloErc20" },
                  { "$ref": "#/components/schemas/ApproveCeloErc20KMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Approve spending of fungible tokens",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Transfer a supply of fungible tokens existing in the smart contract (the <code>contractAddress</code> parameter in the request body) to the specified blockchain address (the <code>to</code> parameter in the request body).<br/>\nTransferring fungible tokens invokes the <code>transfer()</code> method.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>XinFin</li>\n</ul>\n<p><b>Transferring fungible tokens on Algorand</b></p>\n<p>On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">has agreed to receive the NFT</a> to their address.</p>\n<p><b>Signing a transaction</b></p>\n<p>When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "operationId": "Erc20Transfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ChainTransferEthErc20" },
                  { "$ref": "#/components/schemas/ChainTransferSolanaSpl" },
                  { "$ref": "#/components/schemas/ChainTransferBscBep20" },
                  { "$ref": "#/components/schemas/ChainTransferCeloErc20Token" },
                  { "$ref": "#/components/schemas/ChainTransferAlgoErc20" },
                  { "$ref": "#/components/schemas/ChainTransferKcsEthErc20" },
                  { "$ref": "#/components/schemas/ChainTransferEthErc20KMS" },
                  { "$ref": "#/components/schemas/ChainTransferSolanaSplKMS" },
                  { "$ref": "#/components/schemas/ChainTransferBscBep20KMS" },
                  { "$ref": "#/components/schemas/ChainTransferCeloErc20TokenKMS" },
                  { "$ref": "#/components/schemas/ChainTransferAlgoErc20KMS" },
                  { "$ref": "#/components/schemas/ChainTransferKcsEthErc20KMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transfer fungible tokens",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/transaction/{chain}/{address}/{tokenAddress}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get incoming and outgoing transactions related to fungible tokens on a blockchain address.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "Erc20GetTransactionByAddress",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["CELO", "ALGO", "MATIC", "ETH"], "example": "CELO" }
          },
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x1ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 0, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 0, "example": 1087823 }
          },
          {
            "description": "Sorting of the data. ASC - oldest first, DESC - newest first.",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "default": "DESC", "example": "ASC", "enum": ["ASC", "DESC"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/FungibleTx" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get fungible token transactions on a blockchain address",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/balance/{chain}/{contractAddress}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the number of the fungible tokens minted on a specific smart contract (the <code>contractAddress</code> path parameter in the request endpoint URL) that a blockchain address holds.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Elrond</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>XinFin</li>\n</ul>\n",
        "operationId": "Erc20GetBalance",
        "parameters": [
          {
            "description": "Network name",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["CELO", "ALGO", "MATIC", "ETH", "BSC", "XDC", "KLAY", "ONE", "EGLD", "KCS"],
              "example": "CELO"
            }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          },
          {
            "description": "The address of the fungible token smart contract",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": {
                      "type": "string",
                      "description": "The number of fungible tokens in the smallest token unit (for example, if the token has 10 decimal places, the number is returned as 9*10^10)",
                      "example": "10"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the number of fungible tokens from a specific smart contract that a blockchain address holds",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/blockchain/token/address/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n<li>Solana</li>\n</ul>\n",
        "operationId": "Erc20GetBalanceAddress",
        "parameters": [
          {
            "description": "Network name",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "example": "CELO", "enum": ["CELO", "ETH", "MATIC", "SOL", "ALGO"] }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "contractAddress": {
                        "type": "string",
                        "description": "The address of the smart contract that the fungible tokens were minted on"
                      },
                      "balance": {
                        "type": "string",
                        "description": "The number of the fungible tokens",
                        "example": "10"
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the number of fungible tokens that a blockchain address holds across a blockchain",
        "tags": ["Fungible Tokens (ERC-20 or compatible)"]
      }
    },
    "/v3/multitoken/deploy": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited.\nIt is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "DeployMultiToken",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/DeployMultiToken" },
                  { "$ref": "#/components/schemas/DeployMultiTokenKMS" },
                  { "$ref": "#/components/schemas/DeployMultiTokenCelo" },
                  { "$ref": "#/components/schemas/DeployMultiTokenCeloKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Deploy a Multi Token smart contract",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/mint": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "MintMultiToken",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/MintMultiToken" },
                  { "$ref": "#/components/schemas/MintMultiTokenKMS" },
                  { "$ref": "#/components/schemas/MintMultiTokenCelo" },
                  { "$ref": "#/components/schemas/MintMultiTokenKMSCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Mint a Multi Token",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/mint/batch": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "MintMultiTokenBatch",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/MintMultiTokenBatch" },
                  { "$ref": "#/components/schemas/MintMultiTokenBatchKMS" },
                  { "$ref": "#/components/schemas/MintMultiTokenBatchCelo" },
                  { "$ref": "#/components/schemas/MintMultiTokenBatchKMSCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Mint multiple Multi Tokens",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/burn": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BurnMultiToken",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BurnMultiToken" },
                  { "$ref": "#/components/schemas/BurnMultiTokenKMS" },
                  { "$ref": "#/components/schemas/BurnMultiTokenCelo" },
                  { "$ref": "#/components/schemas/BurnMultiTokenKMSCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Burn a Multi Token",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/burn/batch": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BurnMultiTokenBatch",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/BurnMultiTokenBatch" },
                  { "$ref": "#/components/schemas/BurnMultiTokenBatchKMS" },
                  { "$ref": "#/components/schemas/BurnMultiTokenBatchCelo" },
                  { "$ref": "#/components/schemas/BurnMultiTokenBatchKMSCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Burn multiple Multi Tokens",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress.</p>\n<p>Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TransferMultiToken",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferMultiToken" },
                  { "$ref": "#/components/schemas/TransferMultiTokenCelo" },
                  { "$ref": "#/components/schemas/TransferMultiTokenKMS" },
                  { "$ref": "#/components/schemas/TransferMultiTokenKMSCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transfer a Multi Token",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/transaction/batch": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress.</p>\n<p>Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC.</b>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TransferMultiTokenBatch",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferMultiTokenBatch" },
                  { "$ref": "#/components/schemas/TransferMultiTokenBatchKMS" },
                  { "$ref": "#/components/schemas/TransferMultiTokenBatchCelo" },
                  { "$ref": "#/components/schemas/TransferMultiTokenBatchKMSCelo" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transfer multiple Multi Tokens",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/mint/add": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Add Multi Token minter.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b></p>\n<p>When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "AddMultiTokenMinter",
        "parameters": [
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/AddMultiTokenMinter" },
                  { "$ref": "#/components/schemas/AddMultiTokenMinterKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Add a Multi Token minter",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/transaction/{chain}/{address}/{tokenAddress}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get incoming and outgoing Multi Token transactions on a blockchain address.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "MultiTokenGetTransactionByAddress",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["CELO", "ETH", "MATIC"], "example": "CELO" }
          },
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x1ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 0, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 0, "example": 1087823 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "oneOf": [{ "$ref": "#/components/schemas/MultiTx" }] }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Multi Token transactions on a blockchain address",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/transaction/{chain}/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Multi Token transaction by transaction hash.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "MultiTokenGetTransaction",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "KCS", "KLAY", "ONE", "CELO", "BSC"] }
          },
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/CeloTx" },
                    { "$ref": "#/components/schemas/EthTx" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get a Multi Token transaction by its hash",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/address/balance/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get all Multi Tokens that a blockchain address holds. The Multi Tokens are returned grouped by the smart contracts they were minted on.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "MultiTokenGetAddressBalance",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "CELO"], "example": "ETH" }
          },
          {
            "description": "Blockchain address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          },
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "contractAddress": {
                        "type": "string",
                        "example": "0x771987a5add0ef1ce303aa069df82dd7f8fbb33b",
                        "description": "Contract address of the Multi Token"
                      },
                      "balances": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "tokenId": { "type": "string", "description": "Token ID.", "example": "10" },
                            "amount": {
                              "type": "string",
                              "description": "Number of tokens held by the address.",
                              "example": "17"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get all Multi Tokens that a blockchain address holds",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/balance/{chain}/{contractAddress}/{address}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the amount of a specific Multi Token (minted on the smart contract specified by the <code>contractAddress</code> path parameter in the request endpoint URL) that a blockchain address holds.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "MultiTokenGetBalance",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "KCS", "KLAY", "ONE", "CELO", "BSC"] }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          },
          {
            "description": "The address of the Multi Token smart contract",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "The ID of the Multi Token",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": { "type": "string", "example": "100" }
          },
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "string",
                      "description": "The amount of the specified Multi Token",
                      "example": "10"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the amount of a specific MultiToken that a blockchain address holds",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/balance/batch/{chain}/{contractAddress}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the <code>contractAddress</code> path parameter in the request endpoint URL) that those addresses hold.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "MultiTokenGetBalanceBatch",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "KCS", "KLAY", "ONE", "CELO", "BSC"] }
          },
          {
            "description": "The address of the Multi Token smart contract",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Comma-separated IDs of the Multi Tokens to get the amounts for",
            "in": "query",
            "name": "tokenId",
            "required": true,
            "schema": { "type": "string", "example": "1,2,3" }
          },
          {
            "description": "Comma-separated blockchain addresses to get the token balance for",
            "in": "query",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B,0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B,0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B"
            }
          },
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "example": ["10", "20"],
                  "items": { "type": "string", "description": "Token ID." }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the amount of one or multiple Multi Tokens for multiple blockchain addresses",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/metadata/{chain}/{contractAddress}/{token}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Multi Token metadata.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "MultiTokenGetMetadata",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "KCS", "KLAY", "ONE", "CELO", "BSC"] }
          },
          {
            "description": "Token ID",
            "in": "path",
            "name": "token",
            "required": true,
            "schema": { "type": "string", "example": "1", "maxLength": 32 }
          },
          {
            "description": "Multi Token contract address",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": { "type": "string", "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326" }
          },
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "string",
                      "description": "Metadata associated with token.",
                      "example": "https://my_token_data.com"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Multi Token metadata",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/multitoken/address/{chain}/{hash}": {
      "get": {
        "description": "<p><p>This endpoint is deprecated. Do not use it.<br/>\nInstead, use <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">this API</a>.</b></p><br/>\n<p><b>1 credit per API call</b></p>\n<p>Get Multi Token contract address from deploy transaction.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "deprecated": true,
        "operationId": "MultiTokenGetContractAddress",
        "parameters": [
          {
            "description": "Blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": { "type": "string", "enum": ["ETH", "MATIC", "KCS", "KLAY", "ONE", "CELO", "BSC"] }
          },
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of testnet. Defaults to Sepolia. Valid only for ETH invocations.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": { "default": "ethereum-sepolia", "type": "string", "enum": ["ethereum-sepolia"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "Address of the Multi Token token.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get the address of a Multi Token smart contract by its transaction hash",
        "tags": ["Multi Tokens (ERC-1155 or compatible)"]
      }
    },
    "/v3/solana/wallet": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generate Solana private key and account address.</p>\n",
        "operationId": "SolanaGenerateWallet",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "description": "Generated account address.",
                      "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
                      "type": "string"
                    },
                    "privateKey": {
                      "description": "Generated private key for account.",
                      "example": "zgsAKfjuXrAxEyuYRxbbxPM3rdsPbJPnGreaGMbcdUApJ6wHnCqQnf9b1RNPdeZxsRMkezh4VgXQ7YrbpndGtEv",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Solana wallet",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based JSON RPC driver to connect directly to the Solana node provided by Tatum.\nTo learn more about Solana JSON RPC, visit the <a href=\"https://docs.solana.com/developing/clients/jsonrpc-api\" target=\"_blank\">Solana developer's guide</a>.</p>\n",
        "operationId": "SolanaWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid JSON RPC method content body.",
                "example": { "jsonrpc": "2.0", "method": "getVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid JSON RPC response.",
                  "example": { "jsonrpc": "2.0", "result": { "solana-core": "1.8.5" }, "id": 1 }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "JSON RPC HTTP driver",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/block/current": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Solana current block number. This is the number of the latest block in the blockchain.</p>",
        "operationId": "SolanaGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/block/{height}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get Solana block by block hash or block number. <br/>\nYou can find full data description here - <a target=\"blank\" href=\"https://docs.solana.com/developing/clients/jsonrpc-api#getblock\">https://docs.solana.com/developing/clients/jsonrpc-api#getblock</a>\n</p>\n",
        "operationId": "SolanaGetBlock",
        "parameters": [
          {
            "description": "Block number",
            "in": "path",
            "name": "height",
            "required": true,
            "schema": { "type": "number", "example": 6470657 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SolanaBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Solana block by number",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/account/balance/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Solana account balance in SOL. This method does not prints any balance of the SPL or NFT tokens on the account.</p>",
        "operationId": "SolanaGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in SOL", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Solana Account balance",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/transaction/{hash}": {
      "get": {
        "description": "<h4>2 credit per API call.</h4><br/><p>Get Solana transaction by transaction hash.<br/>\nYou can find full data description here - <a target=\"blank\" href=\"https://docs.solana.com/developing/clients/jsonrpc-api#gettransaction\">https://docs.solana.com/developing/clients/jsonrpc-api#gettransaction</a>\n</p>\n",
        "operationId": "SolanaGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "5oSXZkPregqGhHrTcbWhgHQJETvBHtBYssuuCMJ3qroAgHsHndsr8fyY8kY76AgwmMaZBZW8ThHAXwjDaUSweApS"
            }
          },
          {
            "description": "Commitment of the transaction. If not defined, all transactions are being scanned.",
            "in": "query",
            "name": "commitment",
            "required": false,
            "schema": { "type": "string", "enum": ["finalized", "confirmed"] }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SolanaTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Solana Transaction",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/transaction": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Send SOL from account to account.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "SolanaBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferSolanaBlockchain" },
                  { "$ref": "#/components/schemas/TransferSolanaBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403SolanaBroadcast" },
                    { "$ref": "#/components/schemas/Error403SolanaTxBody" },
                    { "$ref": "#/components/schemas/Error403SolanaTxHash" },
                    { "$ref": "#/components/schemas/Error403SolanaTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send SOL from account to account",
        "tags": ["Solana"]
      }
    },
    "/v3/solana/broadcast/confirm": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Broadcast signed custom transactions to Solana blockchain and waits for transaction confirmation depending on the commitment given. More information about commitment levels <a target=\"_blank\" href=\"https://docs.solana.com/ru/developing/clients/jsonrpc-api#configuring-state-commitment\">here</a></p>\n",
        "operationId": "SolanaBroadcastConfirm",
        "requestBody": {
          "content": {
            "application/json": { "schema": { "$ref": "#/components/schemas/SolanaBroadcastConfirm" } }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/SolanaTransactionHashWithConfirm" }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403SolanaBroadcastConfirm" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast and confirm signed Solana transaction",
        "tags": ["Solana"]
      }
    },
    "/v3/bsc/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for BSC wallet with derivation path m'/44'/60'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible BSC wallet.</p>\n",
        "operationId": "BscGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate BSC wallet",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "BscGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 1,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "BSC address",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate BSC account address from Extended public key",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "BscGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate BSC private key",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/web3/{xApiKey}": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the BSC node provided by Tatum.\nTo learn more about BSC Web3, visit the <a href=\"https://bsc.org/en/developers/\" target=\"_blank\">BSC developer's guide.</a></p>\n",
        "operationId": "BscWeb3Driver",
        "deprecated": true,
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/block/current": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get BSC current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "BscGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get BSC block by block hash or block number.</p>\n",
        "operationId": "BscGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get BSC block by hash",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/account/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.</p>\n",
        "operationId": "BscGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in BNB", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get BSC Account balance",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/transaction/{hash}": {
      "get": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Get BSC transaction by transaction hash.</p>\n",
        "operationId": "BscGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BscTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get BSC Transaction",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/transaction/count/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "BscGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing BSC transactions",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send BNB or Tatum supported BEP20 token from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BscBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferBscBlockchain" },
                  { "$ref": "#/components/schemas/TransferBscBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BscBroadcast" },
                    { "$ref": "#/components/schemas/Error403BscGasPrice" },
                    { "$ref": "#/components/schemas/Error403BscTxBody" },
                    { "$ref": "#/components/schemas/Error403BscGasCalculation" },
                    { "$ref": "#/components/schemas/Error403BscTxHash" },
                    { "$ref": "#/components/schemas/Error403BscTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send BSC / BEP20 from account to account",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on BNB Smart Chain.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "BscBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallBscSmartContractReadMethod" },
                  { "$ref": "#/components/schemas/CallBscSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallBscSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403BscBroadcast" },
                    { "$ref": "#/components/schemas/Error403BscGasPrice" },
                    { "$ref": "#/components/schemas/Error403BscScBody" },
                    { "$ref": "#/components/schemas/Error403BscGasCalculation" },
                    { "$ref": "#/components/schemas/Error403BscTxHash" },
                    { "$ref": "#/components/schemas/Error403BscTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on BNB Smart Chain",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/bsc/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "BscBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403BscBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed BSC transaction",
        "tags": ["BNB Smart Chain"]
      }
    },
    "/v3/polygon/wallet": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m'/44'/966'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Polygon wallet.</p>\n",
        "operationId": "PolygonGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Polygon wallet",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/address/{xpub}/{index}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "PolygonGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 1,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Polygon address",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Polygon account address from Extended public key",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/wallet/priv": {
      "post": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "PolygonGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Polygon private key",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the Polygon node provided by Tatum.\nTo learn more about Polygon Web3, visit the <a href=\"https://docs.matic.network/\" target=\"_blank\">Polygon developer's guide</a>.</p>\n",
        "operationId": "PolygonWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/block/current": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "PolygonGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/block/{hash}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon block by block hash or block number.</p>\n",
        "operationId": "PolygonGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Polygon block by hash",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/account/balance/{address}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.</p>\n",
        "operationId": "PolygonGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in MATIC", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Polygon Account balance",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/transaction/{hash}": {
      "get": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Get Polygon transaction by transaction hash.</p>\n",
        "operationId": "PolygonGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PolygonTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Polygon Transaction",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/account/transaction/{address}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.</p>\n",
        "operationId": "PolygonGetTransactionByAddress",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwords will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 0, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 0, "example": 1087823 }
          },
          {
            "description": "Sorting of the data. ASC - oldest first, DESC - newest first.",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "default": "DESC", "example": "ASC", "enum": ["ASC", "DESC"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/PolygonTx" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Polygon transactions by address",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/transaction/count/{address}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "PolygonGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing Polygon transactions",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/transaction": {
      "post": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Send MATIC from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "PolygonBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferPolygonBlockchain" },
                  { "$ref": "#/components/schemas/TransferPolygonBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403PolygonBroadcast" },
                    { "$ref": "#/components/schemas/Error403PolygonGasPrice" },
                    { "$ref": "#/components/schemas/Error403PolygonTxBody" },
                    { "$ref": "#/components/schemas/Error403PolygonGasCalculation" },
                    { "$ref": "#/components/schemas/Error403PolygonTxHash" },
                    { "$ref": "#/components/schemas/Error403PolygonTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send MATIC from account to account",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/smartcontract": {
      "post": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Invoke a method in an existing smart contract on Polygon.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>If <b>caller</b> field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "PolygonBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallPolygonSmartContractReadMethod" },
                  { "$ref": "#/components/schemas/CallPolygonSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallPolygonSmartContractMethodCaller" },
                  { "$ref": "#/components/schemas/CallPolygonSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403PolygonBroadcast" },
                    { "$ref": "#/components/schemas/Error403PolygonGasPrice" },
                    { "$ref": "#/components/schemas/Error403PolygonScBody" },
                    { "$ref": "#/components/schemas/Error403PolygonGasCalculation" },
                    { "$ref": "#/components/schemas/Error403PolygonTxHash" },
                    { "$ref": "#/components/schemas/Error403PolygonTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on Polygon",
        "tags": ["Polygon"]
      }
    },
    "/v3/polygon/broadcast": {
      "post": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "PolygonBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403PolygonBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Polygon transaction",
        "tags": ["Polygon"]
      }
    },
    "/v3/celo/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Celo wallet with derivation path m'/44'/52752'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Celo wallet.</p>\n",
        "operationId": "CeloGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Celo wallet",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate Celo account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "CeloGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "example": 1,
            "required": true,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Celo address",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Celo account address from Extended public key",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "CeloGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Celo private key",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/web3/{xApiKey}": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the Celo node provided by Tatum.\nTo learn more about Celo Web3, visit the <a href=\"https://explorer.celo.org/api-docs\" target=\"_blank\">Celo developer's guide</a>.</p>\n",
        "operationId": "CeloWeb3Driver",
        "deprecated": true,
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/block/current": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Celo current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "CeloGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Celo block by block hash or block number.</p>\n",
        "operationId": "CeloGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CeloBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Celo block by hash",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/account/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Celo account balance in ETH. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.</p>\n",
        "operationId": "CeloGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "celo": { "type": "string", "description": "Balance of Celo", "example": "10.52" },
                    "cUsd": { "type": "string", "description": "Balance of cUSD", "example": "11.53" },
                    "cEur": { "type": "string", "description": "Balance of cEUR", "example": "11.53" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Celo Account balance",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/account/transaction/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Celo transactions by address. This includes incoming and outgoing transactions for the address.</p>\n",
        "operationId": "CeloGetTransactionByAddress",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x8ce4e40889a13971681391aad29e88efaf91f784" }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": { "type": "number", "example": 10, "maximum": 50, "minimum": 1 },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": { "type": "number", "example": 0 }
          },
          {
            "description": "Transactions from this block onwords will be included.",
            "in": "query",
            "name": "from",
            "schema": { "type": "number", "minimum": 0, "example": 1087623 }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": { "type": "number", "minimum": 0, "example": 1087823 }
          },
          {
            "description": "Sorting of the data. ASC - oldest first, DESC - newest first.",
            "in": "query",
            "name": "sort",
            "schema": { "type": "string", "default": "DESC", "example": "ASC", "enum": ["ASC", "DESC"] }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/CeloTx" } }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Celo transactions by address",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/transaction/{hash}": {
      "get": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Get Celo transaction by transaction hash.</p>\n",
        "operationId": "CeloGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/CeloTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Celo Transaction",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/transaction/count/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get a number of outgoing Celo transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "CeloGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing Celo transactions",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send Celo, cUSD or Tatum supported ERC20 token from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending CELO, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "CeloBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferCeloBlockchain" },
                  { "$ref": "#/components/schemas/TransferCeloBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403Celo" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Celo / ERC20 from account to account",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on Celo.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "CeloBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallCeloReadSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallCeloSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallCeloSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EthBroadcast" },
                    { "$ref": "#/components/schemas/Error403EthGasPrice" },
                    { "$ref": "#/components/schemas/Error403EthScBody" },
                    { "$ref": "#/components/schemas/Error403EthGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EthTxHash" },
                    { "$ref": "#/components/schemas/Error403EthTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on Celo",
        "tags": ["Celo"]
      }
    },
    "/v3/celo/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to Celo blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "CeloBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Celo" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Celo transaction",
        "tags": ["Celo"]
      }
    },
    "/v3/egld/wallet": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>The Elrond Address format is bech32, specified by the BIP 0173. The address always starts with an erd1. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase.\nMnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.\n<br/>\nEach address is identified by 3 main values:\n<ul><li>Private Key - your secret value, which should never be revealed</li>\n<li>Public Key - public address to be published</li>\n<li>Derivation index - index of generated address</li></ul>\n</p>\n<p>Tatum follows BIP44 specification and generates for EGLD wallet with derivation path m'/44'/508'/0'/0'.\nMore about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible EGLD wallet.</p>\n",
        "operationId": "EgldGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of private key.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mnemonic": {
                      "type": "string",
                      "description": "Mnemonic to use for generation of private key",
                      "example": "quantum tobacco key they maid mean crime youth chief jungle mind design broken tilt bus shoulder leaf good forward erupt split divert bread kitten"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate EGLD wallet",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/address/{mnemonic}/{index}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generate EGLD account deposit address from mnemonic phrase. Deposit address is generated for the specific\nindex - each mnemonic phrase can generate up to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "EgldGenerateAddress",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of address.",
            "in": "path",
            "name": "mnemonic",
            "required": true,
            "schema": {
              "type": "string",
              "example": "quantum tobacco key they maid mean crime youth chief jungle mind design broken tilt bus shoulder leaf good forward erupt split divert bread kitten"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 1,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "EGLD address",
                      "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate EGLD account address from mnemonic",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/wallet/priv": {
      "post": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "EgldGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate EGLD private key",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/node/{xApiKey}/*": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based driver to connect directly to the EGLD node provided by Tatum.\nTo learn more about EGLD, visit the <a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/nodes/\" target=\"_blank\">EGLD developer's guide</a>.</p>\n",
        "operationId": "EgldNodePost",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": {
              "type": "string",
              "example": "/v3/egld/node/asdlkfjnqunalkwjf124387ad/transaction/cost"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid method content body.",
                "example": {
                  "version": 1,
                  "chainId": "D",
                  "nonce": 42,
                  "value": "100000000000000000",
                  "receiver": "erd1cux02zersde0l7hhklzhywcxk4u9n4py5tdxyx7vrvhnza2r4gmq4vw35r",
                  "sender": "erd1njqj2zggfup4nl83x0nfgqjkjserm7mjyxdx5vzkm8k0gkh40ezqtfz9lg",
                  "gasPrice": 1000000000,
                  "gasLimit": 70000,
                  "data": "food for cats",
                  "signature": "93207c579bf57be03add632b0e1624a73576eeda8a1687e0fa286f03eb1a17ffb125ccdb008a264c402f074a360442c7a034e237679322f62268b614e926d10f"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "type": "object", "description": "Any valid response." } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Node HTTP driver",
        "tags": ["Elrond"]
      },
      "get": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based driver to connect directly to the EGLD node provided by Tatum.\nTo learn more about EGLD, visit the <a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/nodes/\" target=\"_blank\">EGLD developer's guide</a>.</p>\n",
        "operationId": "EgldNodeGet",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": {
              "type": "string",
              "example": "/v3/egld/node/asdlkfjnqunalkwjf12341kljl/network/config"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid response.",
                  "example": {
                    "config": {
                      "erd_chain_id": "1",
                      "erd_denomination": 18,
                      "erd_gas_per_data_byte": 1500,
                      "erd_latest_tag_software_version": "v1.1.0.0",
                      "erd_meta_consensus_group_size": 400,
                      "erd_min_gas_limit": 50000,
                      "erd_min_gas_price": 1000000000,
                      "erd_min_transaction_version": 1,
                      "erd_num_metachain_nodes": 400,
                      "erd_num_nodes_in_shard": 400,
                      "erd_num_shards_without_meta": 3,
                      "erd_round_duration": 6000,
                      "erd_shard_consensus_group_size": 63,
                      "erd_start_time": 1596117600
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Node HTTP driver",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/block/current": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/> <p>Get EGLD current block number. This is the number of the latest block in the blockchain.</p>",
        "operationId": "EGldGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 649127 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/block/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/> <p>Get EGLD block by block hash or block number. <a href='https://docs.elrond.com/sdk-and-tools/rest-api/blocks/' target='_blank'> EGLD docs </a></p>",
        "operationId": "EgldGetBlock",
        "parameters": [
          {
            "description": "Block hash or nonce",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "a6f2ac15a6b1bafdde9afff2297cef49c4c523c516f8ee12fed54be070e9512b"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EgldBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get EGLD block by hash",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/account/balance/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/> <p>Get account balance in EGLD.</p>",
        "operationId": "EgldGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in EGLD", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get EGLD Account balance",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/transaction/{hash}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/> <p>Get EGLD transaction by transaction hash. Detail result please find here <a href='https://docs.elrond.com/sdk-and-tools/rest-api/transactions/#get-transaction' target='_blank'> EGLD docs </a></p>",
        "operationId": "EgldGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "99996224823736c1e9b8484ed74c1573049478f871d6f94b86811fb1c7b2addd"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EgldTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EgldBroadcast" },
                    { "$ref": "#/components/schemas/Error403EgldGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EgldTxHash" },
                    { "$ref": "#/components/schemas/Error403EgldTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get EGLD Transaction",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/transaction/address/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>This endpoint allows one to retrieve the latest 20 transactions sent from an address.</p>\n",
        "operationId": "EgldGetTransactionAddress",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 62,
              "minLength": 62,
              "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "description": "List of transactions sent from an address.",
                  "items": { "type": "object" }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing EGLD transactions",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/transaction/count/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get a number of outgoing EGLD transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "EgldGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 62,
              "minLength": 62,
              "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing EGLD transactions",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/transaction": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Send EGLD from account to account.<br/><br/>\nThis operation needs the private key of the blockchain address. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on devnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "EgldBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferEgldBlockchain" },
                  { "$ref": "#/components/schemas/TransferEgldBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403EgldBroadcast" },
                    { "$ref": "#/components/schemas/Error403EgldGasCalculation" },
                    { "$ref": "#/components/schemas/Error403EgldTxHash" },
                    { "$ref": "#/components/schemas/Error403EgldTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send EGLD from account to account",
        "tags": ["Elrond"]
      }
    },
    "/v3/egld/broadcast": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to EGLD blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "EgldBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403EgldBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed EGLD transaction",
        "tags": ["Elrond"]
      }
    },
    "/v3/algorand/wallet": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Tatum supports Algorand wallets.</p>\n",
        "operationId": "AlgorandGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AlgoWallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Algorand wallet",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/address/{priv}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Generate Algorand account deposit address from private key.</p>\n",
        "operationId": "AlgorandGenerateAddress",
        "parameters": [
          {
            "description": "private key of wallet.",
            "in": "path",
            "name": "priv",
            "required": true,
            "schema": {
              "type": "string",
              "example": "NBYMCVEEDFYV3TPWVRE6APE7PKHUJD4XAKXCKNCLKGUXOC3LFNJGZQCJCRA53HB7ZAHF6NFJH2QIVQ5USQNWG35QCJLD4KZ5IWMB24Q"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Algorand address",
                      "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Algorand account address from private key",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/node/indexer/{xApiKey}/{indexerPath}": {
      "get": {
        "deprecated": true,
        "description": "<p><b>1 credit per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based url to connect directly to the Algorand node provided by Tatum.\nYou can check all available APIs here - <a href=\"https://developer.algorand.org/docs/rest-apis/indexer/\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/indexer/</a>.\n<br/>\nExample call for Get Tx By ID is described in the response. <a href=\"https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid</a>.\n<br/>\nURL used for this call would be <pre>https://api-eu1.tatum.io/v3/algorand/node/indexer/YOUR_API_KEY/v2/transactions/HNIQ76UTJYPOLZP5FWODYABBJPYPGJNEM2QEJSMDMQRWEKHEYJHQ</pre></p>\n",
        "operationId": "AlgoNodeIndexerGetDriver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          },
          {
            "description": "`**` path of indexer.",
            "in": "path",
            "name": "indexerPath",
            "required": true,
            "schema": { "type": "string", "example": "v2/accounts" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AlgoTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Access Algorand Indexer GET node endpoints",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/node/algod/{xApiKey}/{algodPath}": {
      "get": {
        "deprecated": true,
        "description": "<p><b>1 credit per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based url to connect directly to the Algorand node provided by Tatum.\nYou can check al available APIs here - <a href=\"https://developer.algorand.org/docs/rest-apis/algod/v2/\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/algod/v2/</a>.\n<br/>\nExample call for Get Block is described in the response. <a href=\"https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksround\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksround</a>.\n<br/>\nURL used for this call would be <pre>https://api-eu1.tatum.io/v3/algorand/node/algod/YOUR_API_KEY/v2/blocks/16775567</pre>\n</p>\n",
        "operationId": "AlgoNodeGetDriver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          },
          {
            "description": "`**` path of algod.",
            "in": "path",
            "name": "algodPath",
            "required": true,
            "schema": { "type": "string", "example": "v2/accounts" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AlgoBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Access Algorand Algod GET node endpoints",
        "tags": ["Algorand"]
      },
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based url to connect directly to the Algorand node provided by Tatum.\n You can check al available APIs here - <a href=\"https://developer.algorand.org/docs/rest-apis/algod/v2/\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/algod/v2/</a>.\n <br/>\n Example call for Broadcast a raw transaction is described in the response. <a href=\"https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2transactions\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2transactions</a>.\n <br/>\n URL used for this call would be <pre>https://api-eu1.tatum.io/v3/algorand/node/algod/YOUR_API_KEY/v2/transactions</pre>\n </p>\n",
        "operationId": "AlgoNodePostDriver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          },
          {
            "description": "`**` path of algod.",
            "in": "path",
            "name": "algodPath",
            "required": true,
            "schema": { "type": "string", "example": "v2/accounts" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "rawtxn": {
                    "type": "string",
                    "description": "Check here - <a href=\"https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2transactions\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2transactions</a>"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "txId": {
                      "type": "string",
                      "description": "Check here - <a href=\"https://developer.algorand.org/docs/rest-apis/algod/v2/#rawtransaction-response-200\" target=\"_blank\">https://developer.algorand.org/docs/rest-apis/algod/v2/#rawtransaction-response-200</a>",
                      "example": "X4VI2Q3SHG4RC3T2RNDCFHNPUL6WYX2ONWHJGLKNMBA4SVE5M4KQ"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Access Algorand Algod POST node endpoints",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/account/balance/{address}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/>\n<p>Get Algorand account balance in ALGO.</p>\n",
        "operationId": "AlgorandGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "assets": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "amount": {
                            "type": "number",
                            "description": "Balance in asset unit",
                            "example": 1000
                          },
                          "assetIndex": {
                            "type": "number",
                            "description": "Asset Index of ASA",
                            "example": 87748168
                          }
                        }
                      }
                    },
                    "balance": { "type": "number", "description": "Balance in ALGO", "example": 1000 }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Algorand Account balance",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/block/current": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Algorand current block number. This is the number of the latest block in the blockchain.</p>",
        "operationId": "AlgorandGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 16775567 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/block/{roundNumber}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Algorand block by block round number.</p>",
        "operationId": "AlgorandGetBlock",
        "parameters": [
          {
            "description": "Block round number",
            "in": "path",
            "name": "roundNumber",
            "required": true,
            "schema": { "type": "number", "example": 16775567 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AlgoBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Algorand block by block round number",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send Algos from one Algorand address to the other one.</p>\n<p><b>Signing a transaction</b></p>\n<p>When sending Algos, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "AlgorandBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferAlgorandBlockchain" },
                  { "$ref": "#/components/schemas/TransferAlgorandBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send Algos to an Algorand account",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/asset/receive": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Enable accepting Algorand asset on the sender account.<br/><br/>\nThis operation needs the private key of the blockchain address.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n</p>\n",
        "operationId": "AlgorandBlockchainReceiveAsset",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/ReceiveAlgorandAsset" },
                  { "$ref": "#/components/schemas/ReceiveAlgorandAssetKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Enable receiving asset on account",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/transaction/{txid}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Algorand transaction by transaction id.</p>",
        "operationId": "AlgorandGetTransaction",
        "parameters": [
          {
            "description": "Transaction id",
            "in": "path",
            "name": "txid",
            "required": true,
            "schema": { "type": "string", "example": "LXEBXIBDAIF72NRI76SU252QSOGFCKEHTG7AI4P6W25V35PETU3Q" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/AlgoTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Algorand Transaction",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/transactions/{from}/{to}": {
      "get": {
        "description": "<h4>1 credit per API call.</h4><br/><p>Get Algorand transaction by specified period of time.</p>",
        "operationId": "AlgorandGetPayTransactionsByFromTo",
        "parameters": [
          {
            "description": "Start timestamp in specified period of time",
            "in": "path",
            "name": "from",
            "required": true,
            "schema": { "type": "string", "example": "2021-05-01T20:44:39Z" }
          },
          {
            "description": "End timestamp in specified period of time",
            "in": "path",
            "name": "to",
            "required": true,
            "schema": { "type": "string", "example": "2021-06-01T20:44:39Z" }
          },
          {
            "description": "page size for pagination",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": { "type": "string", "example": "5" }
          },
          {
            "description": "Algorand Next Token for getting the next page results",
            "in": "query",
            "name": "next",
            "required": false,
            "schema": { "type": "string", "example": "ywAAAAAAAAAAAAAA" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/AlgoTxsWithPagination" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Algorand Transactions between from and to",
        "tags": ["Algorand"]
      }
    },
    "/v3/algorand/broadcast": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Broadcast signed transaction to Algorand blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "AlgoandBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/AlgoTransactionHashKMS" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Algorand transaction",
        "tags": ["Algorand"]
      }
    },
    "/v3/tron/wallet": {
      "get": {
        "summary": "Generate a TRON wallet",
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m'/44'/195'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/tron/bips/blob/master/bip-0044.mediawiki</a>.\n        Generate BIP44 compatible Tron wallet.</p>\n",
        "operationId": "GenerateTronwallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TronWallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403" }] } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "tags": ["Tron"]
      }
    },
    "/v3/tron/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>5 credits per API call</b></p>\n<p>Generate a TRON address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31.</p>\n",
        "operationId": "TronGenerateAddress",
        "parameters": [
          {
            "description": "The extended public key of the wallet; can be in the base58 format (111 characters) or the hexadecimal format (130 characters)",
            "in": "path",
            "name": "xpub",
            "required": true,
            "example": "0244b3f40c6e570ae0032f6d7be87737a6c4e5314a4a1a82e22d0460a0d0cd794936c61f0c80dc74ace4cd04690d4eeb1aa6555883be006e1748306faa7ed3a26a",
            "schema": { "type": "string" }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 1,
            "schema": { "type": "number", "minimum": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Tron address",
                      "example": "TFFBpkRNro4Pe4154ayGWx7C6Ev7BvQZ6t"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403AccountAddressGeneral" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate a TRON address from the wallet's extended public key",
        "tags": ["Tron"]
      }
    },
    "/v3/tron/wallet/priv": {
      "post": {
        "description": "<p><b>10 credits per API call</b></p>\n<p>Generate private key for address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "TronGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error403BlockchainPrivateFailed" }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate the private key for a TRON address",
        "tags": ["Tron"]
      }
    },
    "/v3/tron/info": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get the current TRON block",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get current Tron block.</p>\n",
        "operationId": "TronGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "blockNumber": { "description": "Block height.", "type": "number", "example": 26585295 },
                    "hash": {
                      "description": "Block hash.",
                      "type": "string",
                      "example": "000000000195a8cfe2ea4ca60ce921b30e95980a96c6bb1da4a35aa03da9c5a8"
                    },
                    "testnet": {
                      "description": "Wether the block is from mainnet of Shasta testnet",
                      "type": "boolean",
                      "example": false
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/block/{hash}": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get a TRON block by its hash or height",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get Tron block by hash or height.</p>\n",
        "operationId": "TronGetBlock",
        "parameters": [
          {
            "in": "path",
            "name": "hash",
            "required": true,
            "description": "Block hash or height.",
            "schema": {
              "type": "string",
              "example": "000000000195a8cfe2ea4ca60ce921b30e95980a96c6bb1da4a35aa03da9c5a8"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TronBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/account/{address}": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get the TRON account by its address",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get Tron account by address.</p>\n",
        "operationId": "TronGetAccount",
        "parameters": [
          {
            "in": "path",
            "name": "address",
            "required": true,
            "description": "Account address.",
            "schema": { "type": "string", "example": "TGDqQAP5bduoPKVgdbk7fGyW4DwEt3RRn8" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TronAccount" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/freezeBalance": {
      "post": {
        "tags": ["Tron"],
        "summary": "Freeze the balance of a TRON account",
        "description": "<p><b>10 credits per API call</b></p>\n<p>Freeze Tron assets on the address. By freezing assets, you can obtain energy or bandwidth to perform transactions.</p>\n<p><b>Signing a transaction</b></p>\n<p>When freezing the balance, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TronFreeze",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/FreezeTron" },
                  { "$ref": "#/components/schemas/FreezeTronKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/transaction/account/{address}": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get all transactions for a TRON account",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get all transactions for a TRON account.</p>\n<p>This API returns up to 200 transactions in one API call. If there are more than 200 transactions for the TRON account, the response body will contain the <code>next</code> parameter with the ID of the transaction that follows the last (200<sup>th</sup>) transaction in the returned list.</p>\n<p>To get the next 200 transactions, make another call using this API, but this time add the <code>next</code> parameter the endpoint URL and set it to the transaction ID from the <code>next</code> parameter in the response, for example:</p>\n<p><code>https://{region}.tatum.io/v3/tron/transaction/account/{address}?next=81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991</code></p>\n",
        "operationId": "TronAccountTx",
        "parameters": [
          {
            "in": "path",
            "name": "address",
            "description": "The address of the TRON account to get all transactions for",
            "required": true,
            "schema": { "type": "string", "example": "TGDqQAP5bduoPKVgdbk7fGyW4DwEt3RRn8" }
          },
          {
            "in": "query",
            "name": "next",
            "description": "The ID of the transaction that follows the last (200<sup>th</sup>) transaction in the returned list of transactions. Use it to get the next 200 transactions for the specified account (for more information, see the description of this API).",
            "required": false,
            "schema": {
              "type": "string",
              "example": "81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["transactions"],
                  "properties": {
                    "next": {
                      "type": "string",
                      "description": "If present, there are more transactions for the TRON account than the 200 transactions returned in the response, and this parameter specifies the ID of the transaction that follows the last (200<sup>th</sup>) transaction in the returned list of transactions. Use it to get the next 200 transactions for the specified account (for more information, see the description of this API).",
                      "example": "81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991"
                    },
                    "transactions": {
                      "type": "array",
                      "description": "The list of transactions for the specified TRON account",
                      "items": { "$ref": "#/components/schemas/TronTx" }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/transaction/account/{address}/trc20": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get TRC-20 transactions for a TRON account",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get TRC-20 transactions for a TRON account.</p>\n<p>This API returns up to 200 transactions in one API call. If there are more than 200 transactions for the TRON account, the response body will contain the <code>next</code> parameter with the ID of the transaction that follows the last (200<sup>th</sup>) transaction in the returned list.</p>\n<p>To get the next 200 transactions, make another call using this API, but this time add the <code>next</code> parameter the endpoint URL and set it to the transaction ID from the <code>next</code> parameter in the response, for example:</p>\n<p><code>https://{region}.tatum.io/v3/tron/transaction/account/{address}/trc20?next=81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991</code></p>\n",
        "operationId": "TronAccountTx20",
        "parameters": [
          {
            "in": "path",
            "name": "address",
            "description": "The address of the TRON account to get TRC-20 transactions for",
            "required": true,
            "schema": { "type": "string", "example": "TGDqQAP5bduoPKVgdbk7fGyW4DwEt3RRn8" }
          },
          {
            "in": "query",
            "name": "next",
            "description": "The ID of the transaction that follows the last (200<sup>th</sup>) transaction in the returned list of transactions. Use it to get the next 200 transactions for the specified account (for more information, see the description of this API).",
            "required": false,
            "schema": {
              "type": "string",
              "example": "81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["transactions"],
                  "properties": {
                    "next": {
                      "type": "string",
                      "description": "If present, there are more transactions for the TRON account than the 200 transactions returned in the response, and this parameter specifies the ID of the transaction that follows the last (200<sup>th</sup>) transaction in the returned list of transactions. Use it to get the next 200 transactions for the specified account (for more information, see the description of this API).",
                      "example": "81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991"
                    },
                    "transactions": {
                      "type": "array",
                      "description": "The list of transactions for the specified TRON account",
                      "items": { "$ref": "#/components/schemas/TronTx20" }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/transaction": {
      "post": {
        "tags": ["Tron"],
        "summary": "Send TRX to a TRON account",
        "description": "<p><b>10 credits per API call</b></p>\n<p>Send an amount in TRX from address to address.</p>\n<p><b>Signing a transaction</b></p>\n<p>When sending TRX to a TRON account, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TronTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferTronBlockchain" },
                  { "$ref": "#/components/schemas/TransferTronBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/trc10/transaction": {
      "post": {
        "tags": ["Tron"],
        "summary": "Send TRC-10 tokens to a TRON account",
        "description": "<p><b>10 credits per API call</b></p>\n<p>Send TRC-10 tokens from address to address.</p>\n<p><b>Signing a transaction</b></p>\n<p>When sending TRC-10 tokens to a TRON account, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TronTransferTrc10",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferTronTrc10Blockchain" },
                  { "$ref": "#/components/schemas/TransferTronTrc10BlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/trc20/transaction": {
      "post": {
        "tags": ["Tron"],
        "summary": "Send TRC-20 tokens to a TRON account",
        "description": "<p><b>10 credits per API call</b></p>\n<p>Send TRC-20 tokens from address to address.</p>\n<p><b>Signing a transaction</b></p>\n<p>When sending TRC-20 tokens to a TRON account, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TronTransferTrc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferTronTrc20Blockchain" },
                  { "$ref": "#/components/schemas/TransferTronTrc20BlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/trc10/deploy": {
      "post": {
        "tags": ["Tron"],
        "summary": "Create a TRC-10 token",
        "description": "<p><b>10 credits per API call</b></p>\n<p>Create Tron TRC10 token. 1 account can create only 1 token. All supply of the tokens are transferred to the issuer account 100 seconds after the creation.</p>\n<p><b>Signing a transaction</b></p>\n<p>When creating a TRC-10 token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TronCreateTrc10",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CreateTronTrc10Blockchain" },
                  { "$ref": "#/components/schemas/CreateTronTrc10BlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/trc10/detail/{idOrOwnerAddress}": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get information about a TRC-10 token",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get information about a TRON TRC-10 token.</p>\n",
        "operationId": "TronTrc10Detail",
        "parameters": [
          {
            "in": "path",
            "name": "idOrOwnerAddress",
            "required": true,
            "description": "The ID of the TRC-10 token or the address of the token's owner",
            "schema": { "type": "string", "example": "1000540" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TronTrc10Detail" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/trc20/deploy": {
      "post": {
        "tags": ["Tron"],
        "summary": "Create a TRC-20 token",
        "description": "<p><b>10 credits per API call</b></p>\n<p>Create Tron TRC20 token. 1 account can create only 1 token. All supply of the tokens are transfered to the issuer account 100 seconds after the creation.</p>\n<p><b>Signing a transaction</b></p>\n<p>When creating a TRC-20 token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "TronCreateTrc20",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CreateTronTrc20Blockchain" },
                  { "$ref": "#/components/schemas/CreateTronTrc20BlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/transaction/{hash}": {
      "get": {
        "tags": ["Tron"],
        "summary": "Get a TRON transaction by its hash",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Get Tron transaction by hash.</p>\n",
        "operationId": "TronGetTransaction",
        "parameters": [
          {
            "in": "path",
            "name": "hash",
            "required": true,
            "description": "Transaction hash.",
            "schema": {
              "type": "string",
              "example": "81d0524acf5967f3b361e03fd7d141ab511791cd7aad7ae406c4c8d408290991"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TronTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/tron/broadcast": {
      "post": {
        "tags": ["Tron"],
        "summary": "Broadcast a TRON transaction",
        "description": "<p><b>5 credits per API call</b></p>\n<p>Broadcast Tron transaction. This method is used internally from Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "TronBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TronBroadcast" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error403Tron" } } }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": []
      }
    },
    "/v3/klaytn/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Klaytn wallet with derivation path m'/44'/966'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Klaytn wallet.</p>\n",
        "operationId": "KlaytnGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Klaytn wallet",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate Klaytn account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "KlaytnGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 1,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Klaytn address",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Klaytn account address from Extended public key",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "KlaytnGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Klaytn private key",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the Klaytn node provided by Tatum.\nTo learn more about Klaytn Web3, visit the <a href=\"https://docs.klaytn.foundation/dapp/json-rpc\" target=\"_blank\">Klaytn developer's guide</a>.</p>\n",
        "operationId": "KlaytnWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/block/current": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Klaytn current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "KlaytnGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Klaytn block by block hash or block number.</p>\n",
        "operationId": "KlaytnGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/KlaytnBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Klaytn block by hash",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/account/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Klaytn account balance in KLAY. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.</p>\n",
        "operationId": "KlaytnGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in KLAY", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Klaytn Account balance",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/transaction/{hash}": {
      "get": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Get Klaytn transaction by transaction hash.</p>\n",
        "operationId": "KlaytnGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/KlaytnTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Klaytn Transaction",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/transaction/count/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get a number of outgoing Klaytn transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "KlaytnGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing Klaytn transactions",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send KLAY from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending KLAY, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "KlaytnBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferKlaytnBlockchain" },
                  { "$ref": "#/components/schemas/TransferKlaytnBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KlaytnBroadcast" },
                    { "$ref": "#/components/schemas/Error403KlaytnGasPrice" },
                    { "$ref": "#/components/schemas/Error403KlaytnTxBody" },
                    { "$ref": "#/components/schemas/Error403KlaytnGasCalculation" },
                    { "$ref": "#/components/schemas/Error403KlaytnTxHash" },
                    { "$ref": "#/components/schemas/Error403KlaytnTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send KLAY from account to account",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on Klaytn.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "KlaytnBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallKlaytnSmartContractReadMethod" },
                  { "$ref": "#/components/schemas/CallKlaytnSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallKlaytnSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KlaytnBroadcast" },
                    { "$ref": "#/components/schemas/Error403KlaytnGasPrice" },
                    { "$ref": "#/components/schemas/Error403KlaytnScBody" },
                    { "$ref": "#/components/schemas/Error403KlaytnGasCalculation" },
                    { "$ref": "#/components/schemas/Error403KlaytnTxHash" },
                    { "$ref": "#/components/schemas/Error403KlaytnTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on Klaytn",
        "tags": ["Klaytn"]
      }
    },
    "/v3/klaytn/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to Klaytn blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "KlaytnBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403KlaytnBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Klaytn transaction",
        "tags": ["Klaytn"]
      }
    },
    "/v3/one/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for ONE wallet with derivation path m'/44'/60'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible ONE wallet.</p>\n",
        "operationId": "OneGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate ONE wallet",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "OneGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "example": 1,
            "required": true,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "ONE address",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate ONE account address from Extended public key",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/address/format/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Transform HEX address to Bech32 format with one prefix.</p>\n",
        "operationId": "OneFormatAddress",
        "parameters": [
          {
            "description": "Address in HEX (ETH compatible) format.",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "ONE address",
                      "example": "one15annzcwtlcq3dfx7nc6plpr9jsxzyyw5xc8pjn"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Transform HEX address to Bech32 ONE address format",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "OneGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate ONE private key",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the ONE node provided by Tatum.\nTo learn more about ONE Web3, visit the <a href=\"https://docs.harmony.one/home/developers/api\" target=\"_blank\">ONE developer's guide</a>.</p>\n",
        "operationId": "OneWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          },
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/block/current": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get ONE current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "OneGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "shardID": { "type": "number", "description": "Shard ID", "example": 0 },
                      "blockNumber": {
                        "type": "number",
                        "description": "Current block number in this shard",
                        "example": 6491272
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get ONE block by block hash or block number.</p>\n",
        "operationId": "OneGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          },
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get ONE block by hash",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/account/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.</p>\n",
        "operationId": "OneGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          },
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in ONE", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get ONE Account balance",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/transaction/{hash}": {
      "get": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Get ONE transaction by transaction hash.</p>\n",
        "operationId": "OneGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/OneTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get ONE Transaction",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/transaction/count/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "OneGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          },
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing ONE transactions",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send ONE or Tatum supported HRM20 token from account to account.<br/><br/>\nDefault shard 0 is used for sender and recipient.<br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "OneBlockchainTransfer",
        "parameters": [
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferOneBlockchain" },
                  { "$ref": "#/components/schemas/TransferOneBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403OneBroadcast" },
                    { "$ref": "#/components/schemas/Error403OneGasPrice" },
                    { "$ref": "#/components/schemas/Error403OneTxBody" },
                    { "$ref": "#/components/schemas/Error403OneGasCalculation" },
                    { "$ref": "#/components/schemas/Error403OneTxHash" },
                    { "$ref": "#/components/schemas/Error403OneTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send ONE / HRM20 from account to account",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on Harmony.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "OneBlockchainSmartContractInvocation",
        "parameters": [
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallOneReadSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallOneSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallOneSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403OneBroadcast" },
                    { "$ref": "#/components/schemas/Error403OneGasPrice" },
                    { "$ref": "#/components/schemas/Error403OneScBody" },
                    { "$ref": "#/components/schemas/Error403OneGasCalculation" },
                    { "$ref": "#/components/schemas/Error403OneTxHash" },
                    { "$ref": "#/components/schemas/Error403OneTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on Harmony",
        "tags": ["Harmony"]
      }
    },
    "/v3/one/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "OneBroadcast",
        "parameters": [
          {
            "description": "Shard to read data from",
            "in": "query",
            "name": "shardID",
            "required": false,
            "schema": { "default": 0, "type": "number", "example": 0 }
          }
        ],
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403OneBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed ONE transaction",
        "tags": ["Harmony"]
      }
    },
    "/v3/xdc/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase.\nMnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.\n<br/>\nEach address is identified by 3 main values:\n<ul><li>Private Key - your secret value, which should never be revealed</li>\n<li>Public Key - public address to be published</li>\n<li>Derivation index - index of generated address</li></ul>\n</p>\n<p>Tatum follows BIP44 specification and generates for XDC wallet with derivation path m'/44'/550'/0'/0.\nMore about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible XDC wallet.</p>\n",
        "operationId": "XdcGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate XDC wallet",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate XDC account deposit address from Extended public key. Deposit address is generated for the specific\nindex - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "XdcGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "XDC address",
                      "example": "xdca7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate XDC account address from Extended public key",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "XdcGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate XDC private key",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the XDC node provided by Tatum.\nTo learn more about XDC Web3, visit the <a href=\"https://howto.xinfin.org/\" target=\"_blank\">XDC developer's guide</a>.</p>\n",
        "operationId": "XdcWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/block/current": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get XDC current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "XdcGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 649127 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get XDC block by block hash or block number.</p>\n",
        "operationId": "XdcGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "647065" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XdcBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XDC block by hash",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/account/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get account balance in XDC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.</p>\n",
        "operationId": "XdcGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "xdc3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in XDC", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XDC Account balance",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/transaction/{hash}": {
      "get": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Get XDC transaction by transaction hash.</p>\n",
        "operationId": "XdcGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/XdcTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XdcBroadcast" },
                    { "$ref": "#/components/schemas/Error403XdcGasCalculation" },
                    { "$ref": "#/components/schemas/Error403XdcTxHash" },
                    { "$ref": "#/components/schemas/Error403XdcTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get XDC Transaction",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/transaction/count/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get a number of outgoing XDC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "XdcGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing XDC transactions",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send XDC or Tatum supported ERC20 token from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending XDC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "XdcBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferXdcBlockchain" },
                  { "$ref": "#/components/schemas/TransferXdcBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XdcBroadcast" },
                    { "$ref": "#/components/schemas/Error403XdcGasCalculation" },
                    { "$ref": "#/components/schemas/Error403XdcTxHash" },
                    { "$ref": "#/components/schemas/Error403XdcTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send XDC / ERC20 from account to account",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on XinFin.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "XdcBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallXdcReadSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallXdcSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallXdcSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403XdcBroadcast" },
                    { "$ref": "#/components/schemas/Error403XdcGasCalculation" },
                    { "$ref": "#/components/schemas/Error403XdcTxHash" },
                    { "$ref": "#/components/schemas/Error403XdcTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on XinFin",
        "tags": ["XinFin"]
      }
    },
    "/v3/xdc/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to XDC blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "XdcBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403XdcBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed XDC transaction",
        "tags": ["XinFin"]
      }
    },
    "/v3/kcs/wallet": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Kcs wallet with derivation path m'/44'/966'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Kcs wallet.</p>\n",
        "operationId": "KcsGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": { "type": "string", "maxLength": 500 }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Wallet" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Kcs wallet",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/address/{xpub}/{index}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate Kcs account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "KcsGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "example": 1,
            "required": true,
            "schema": { "type": "number", "example": 0 }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "description": "Kcs address",
                      "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Kcs account address from Extended public key",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/wallet/priv": {
      "post": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "KcsGenerateAddressPrivateKey",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKeyRequest" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/PrivKey" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Generate Kcs private key",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the Kcs node provided by Tatum.\nTo learn more about Kcs Web3, visit the <a href=\"https://docs.kcc.io/\" target=\"_blank\">Kcs developer's guide</a>.</p>\n",
        "operationId": "KcsWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": { "type": "string", "example": "asdlkfjnqunalkwjfnq2oi303294857k" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": { "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 2 }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/block/current": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Kcs current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "KcsGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "number", "description": "Current block number", "example": 6491272 }
              }
            },
            "description": "OK"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/block/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Kcs block by block hash or block number.</p>\n",
        "operationId": "KcsGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": { "type": "string", "example": "6470657" }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/EthBlock" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Kcs block by hash",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/account/balance/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get Kcs account balance in KCS. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.</p>\n",
        "operationId": "KcsGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": { "type": "string", "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": { "type": "string", "description": "Balance in KCS", "example": "10.52" }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Kcs Account balance",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/transaction/{hash}": {
      "get": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Get Kcs transaction by transaction hash.</p>\n",
        "operationId": "KcsGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/KcsTx" } } },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": { "oneOf": [{ "$ref": "#/components/schemas/Error403TxNotFound" }] }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get Kcs Transaction",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/transaction/count/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get a number of outgoing Kcs transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "KcsGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Get count of outgoing Kcs transactions",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Send KCS from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending KCS, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\nAlternatively, using the Tatum client library for supported languages.</p>\n",
        "operationId": "KcsBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/TransferKcsBlockchain" },
                  { "$ref": "#/components/schemas/TransferKcsBlockchainKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KcsBroadcast" },
                    { "$ref": "#/components/schemas/Error403KcsGasPrice" },
                    { "$ref": "#/components/schemas/Error403KcsTxBody" },
                    { "$ref": "#/components/schemas/Error403KcsGasCalculation" },
                    { "$ref": "#/components/schemas/Error403KcsTxHash" },
                    { "$ref": "#/components/schemas/Error403KcsTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Send KCS from account to account",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/smartcontract": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Invoke a method in an existing smart contract on KuCoin Community Chain.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "KcsBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  { "$ref": "#/components/schemas/CallKcsSmartContractReadMethod" },
                  { "$ref": "#/components/schemas/CallKcsSmartContractMethod" },
                  { "$ref": "#/components/schemas/CallKcsSmartContractMethodKMS" }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/TransactionHash" },
                    { "$ref": "#/components/schemas/SignatureId" },
                    { "$ref": "#/components/schemas/Data" }
                  ]
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error403KcsBroadcast" },
                    { "$ref": "#/components/schemas/Error403KcsGasPrice" },
                    { "$ref": "#/components/schemas/Error403KcsScBody" },
                    { "$ref": "#/components/schemas/Error403KcsGasCalculation" },
                    { "$ref": "#/components/schemas/Error403KcsTxHash" },
                    { "$ref": "#/components/schemas/Error403KcsTxSign" }
                  ]
                }
              }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on KuCoin Community Chain",
        "tags": ["KuCoin"]
      }
    },
    "/v3/kcs/broadcast": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Broadcast signed transaction to Kcs blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchian.</p>\n",
        "operationId": "KcsBroadcast",
        "requestBody": {
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BroadcastKMS" } } },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/TransactionHash" } }
            },
            "description": "OK"
          },
          "400": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error400" } } },
            "description": "Bad Request. Validation failed for the given object in the HTTP Body or Request parameters."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    { "$ref": "#/components/schemas/Error401NotActive" },
                    { "$ref": "#/components/schemas/Error401Invalid" }
                  ]
                }
              }
            },
            "description": "Unauthorized. Not valid or inactive subscription key present in the HTTP Header."
          },
          "403": {
            "description": "Forbidden. The request is authenticated, but it is not possible to required perform operation due to logical error or invalid permissions.",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/Error403KcsBroadcast" } }
            }
          },
          "500": {
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error500" } } },
            "description": "Internal server error. There was an error on the server during the processing of the request."
          }
        },
        "security": [{ "X-API-Key": [] }],
        "x-codeSamples": [],
        "summary": "Broadcast signed Kcs transaction",
        "tags": ["KuCoin"]
      }
    }
  },
  "components": {
    "schemas": {
      "Account": {
        "properties": {
          "id": {
            "description": "The ID of the virtual account",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "balance": { "$ref": "#/components/schemas/AccountBalance" },
          "currency": {
            "description": "The currency of the virtual account",
            "example": "BTC",
            "type": "string"
          },
          "frozen": {
            "description": "If set to \"true\", the virtual account is frozen",
            "example": false,
            "type": "boolean"
          },
          "active": {
            "description": "If set to \"true\", the virtual account is active",
            "example": true,
            "type": "boolean"
          },
          "customerId": {
            "description": "The ID of the customer (newly created or existing one) associated with the virtual account",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "accountNumber": {
            "description": "The number associated with the virtual account in an external system",
            "maxLength": 50,
            "minLength": 1,
            "example": "123456",
            "type": "string"
          },
          "accountCode": {
            "description": "The code associated with the virtual account in an external system to designate the purpose of the account in bookkeeping",
            "example": "03_ACC_01",
            "type": "string"
          },
          "accountingCurrency": {
            "description": "The currency in which all the transactions for all accounts will be accounted",
            "example": "EUR",
            "type": "string"
          },
          "xpub": {
            "description": "The extended public key of the blockchain wallet associated with the virtual account; used to generate deposit addresses for the virtual account",
            "example": "xpub6FB4LJzdKNkkpsjggFAGS2p34G48pqjtmSktmK2Ke3k1LKqm9ULsg8bGfDakYUrdhe2EHw5uGKX9DrMbrgYnVfDwrksT4ZVQ3vmgEruo3Ka",
            "type": "string"
          }
        },
        "required": ["id", "active", "frozen", "currency", "balance"],
        "type": "object"
      },
      "Deposit": {
        "required": [
          "txId",
          "address",
          "timestamp",
          "xpub",
          "derivationKey",
          "amount",
          "status",
          "accountId",
          "currency",
          "reference",
          "vout",
          "spent",
          "blockHeight"
        ],
        "properties": {
          "txId": {
            "type": "string",
            "example": "6498A3BE7313FEF32C9C0130F321D7808439F7F59D41932122383CC9E109F534"
          },
          "address": {
            "description": "Blockchain address.",
            "example": "7c21ed165e294db78b95f0f181086d6f",
            "type": "string"
          },
          "timestamp": {
            "type": "number",
            "minimum": 0,
            "example": 1613654998398,
            "description": "End interval in UTC millis."
          },
          "xpub": {
            "description": "Extended public key to derive address from.",
            "example": "xpub6FB4LJzdKNkkpsjggFAGS2p34G48pqjtmSktmK2Ke3k1LKqm9ULsg8bGfDakYUrdhe2EHw5uGKX9DrMbrgYnVfDwrksT4ZVQ3vmgEruo3Ka",
            "type": "string"
          },
          "derivationKey": {
            "description": "Derivation key index for given address.",
            "format": "int32",
            "type": "integer",
            "maximum": 2147483647
          },
          "amount": { "type": "string", "description": "Amount of the trade", "example": "15000" },
          "status": {
            "type": "string",
            "example": "Done",
            "description": "Status of deposit",
            "enum": ["InProgress", "Done", "Failed"]
          },
          "accountId": {
            "description": "Account ID.",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "currency": { "type": "string", "example": "BTC", "description": "Currency" },
          "reference": { "type": "string", "example": "some reference" },
          "vout": { "type": "number", "example": 0 },
          "spent": { "type": "boolean" },
          "blockHeight": {
            "type": "number",
            "minimum": 0,
            "description": "Block of deposit",
            "example": 228232166
          },
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "from": {
            "description": "Blockchain address.",
            "example": "7c21ed165e294db78b95f0f181086d6f",
            "type": "string"
          }
        }
      },
      "EntitiesCount": {
        "type": "object",
        "properties": { "total": { "description": "Total entities", "example": 20, "type": "number" } }
      },
      "ChartRequest": {
        "type": "object",
        "required": ["pair", "from", "to", "timeFrame"],
        "properties": {
          "pair": {
            "type": "string",
            "description": "Trading pair",
            "example": "BTC/EUR",
            "minLength": 3,
            "maxLength": 30,
            "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
          },
          "from": {
            "type": "number",
            "minimum": 0,
            "example": 1613654998398,
            "description": "Start interval in UTC millis."
          },
          "to": {
            "type": "number",
            "minimum": 0,
            "example": 1613654998398,
            "description": "End interval in UTC millis."
          },
          "timeFrame": {
            "type": "string",
            "example": "MIN_5",
            "description": "Time frame of the chart.",
            "enum": [
              "MIN_1",
              "MIN_3",
              "MIN_5",
              "MIN_15",
              "MIN_30",
              "HOUR_1",
              "HOUR_4",
              "HOUR_12",
              "DAY",
              "WEEK",
              "MONTH",
              "YEAR"
            ]
          }
        }
      },
      "Chart": {
        "type": "object",
        "description": "1 point in the chart. This point represents the tick in the grapch based on the specified time frame.",
        "required": ["timestamp", "high", "low", "open", "close", "volume"],
        "properties": {
          "timestamp": {
            "type": "number",
            "description": "Milliseconds in UTC of the time interval.",
            "example": 1613654117167
          },
          "high": {
            "type": "string",
            "description": "Highest trade value in the current interval.",
            "example": "54213.21"
          },
          "low": {
            "type": "string",
            "description": "Lowest trade value in the current interval.",
            "example": "53213.54"
          },
          "open": {
            "type": "string",
            "description": "Open trade value in the current interval.",
            "example": "53513"
          },
          "close": {
            "type": "string",
            "description": "Close trade value in the current interval.",
            "example": "54113"
          },
          "volume": {
            "type": "string",
            "description": "Total volume of assets traded in the current interval. Volume is in currency1 asset.",
            "example": "2.423"
          }
        }
      },
      "AccountBalance": {
        "properties": {
          "accountBalance": {
            "description": "All assets on the account, both available and blocked",
            "example": "1000000",
            "type": "string"
          },
          "availableBalance": {
            "description": "The account balance minus the blocked assets; use the available balance to determine how much a customer can send or withdraw from their virtual account",
            "example": "1000000",
            "type": "string"
          }
        },
        "type": "object",
        "required": ["accountBalance", "availableBalance"]
      },
      "Subscription": {
        "type": "object",
        "required": ["type", "id"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "ACCOUNT_BALANCE_LIMIT",
            "enum": [
              "ADDRESS_TRANSACTION",
              "CONTRACT_LOG_EVENT",
              "ACCOUNT_INCOMING_BLOCKCHAIN_TRANSACTION",
              "ACCOUNT_PENDING_BLOCKCHAIN_TRANSACTION",
              "CUSTOMER_TRADE_MATCH",
              "CUSTOMER_PARTIAL_TRADE_MATCH",
              "TRANSACTION_IN_THE_BLOCK",
              "KMS_FAILED_TX",
              "KMS_COMPLETED_TX",
              "ACCOUNT_BALANCE_LIMIT",
              "TRANSACTION_HISTORY_REPORT"
            ]
          },
          "id": {
            "type": "string",
            "description": "ID of the subscription",
            "example": "7c21ed165e294db78b95f0f1"
          },
          "attr": { "type": "object", "description": "Additional attributes based on the subscription type." }
        }
      },
      "WebHook": {
        "type": "object",
        "required": ["id", "type", "subscriptionId", "url", "data", "failed", "response"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "ACCOUNT_BALANCE_LIMIT",
            "enum": [
              "INCOMING_BLOCKCHAIN_HOOK",
              "ADDRESS_TRANSACTION",
              "CONTRACT_LOG_EVENT",
              "TRADE_MATCH",
              "TRADE_PARTIAL_FILL",
              "PENDING_BLOCKCHAIN_HOOK",
              "TRANSACTION_IN_THE_BLOCK",
              "KMS_FAILED_TX",
              "KMS_COMPLETED_TX"
            ]
          },
          "id": {
            "type": "string",
            "description": "ID of the WebHook",
            "example": "7c21ed165e294db78b95f0f1"
          },
          "subscriptionId": {
            "type": "string",
            "description": "ID of the subscription",
            "example": "7c21ed165e294db78b95f0f1"
          },
          "url": {
            "type": "string",
            "description": "ID of the subscription",
            "example": "http://some-host.net/webhook"
          },
          "data": { "type": "object", "description": "Data of webhook" },
          "nextTime": {
            "type": "number",
            "description": "Next webhook execution try time",
            "example": 1653320900353
          },
          "timestamp": {
            "type": "number",
            "description": "Webhook execution time",
            "example": 1653320900353
          },
          "retryCount": { "type": "number", "description": "Number", "example": 3 },
          "failed": {
            "type": "boolean",
            "description": "Flag indicating whether this webhook was successful or not",
            "example": false
          },
          "response": {
            "type": "object",
            "description": "Response from the server in case the webhook was unsuccessful",
            "required": ["networkError"],
            "properties": {
              "code": { "type": "number", "description": "HTTP Status", "example": 500 },
              "data": {
                "type": "string",
                "description": "Response from the server",
                "example": "Internal server error"
              },
              "networkError": {
                "type": "boolean",
                "description": "Flag indicating whether an error has been caused by the network",
                "example": false
              }
            }
          }
        }
      },
      "CreateSubscriptionBalance": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "ACCOUNT_BALANCE_LIMIT",
            "enum": ["ACCOUNT_BALANCE_LIMIT"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["limit", "typeOfBalance"],
            "properties": {
              "limit": {
                "type": "string",
                "description": "Limit to filter accounts with balance above it.",
                "example": "15000",
                "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
                "maxLength": 38
              },
              "typeOfBalance": {
                "type": "string",
                "description": "Type of balance to filter.",
                "enum": ["account", "available"]
              }
            }
          }
        }
      },
      "CreateSubscriptionInterval": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "TRANSACTION_HISTORY_REPORT",
            "enum": ["TRANSACTION_HISTORY_REPORT"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["interval"],
            "properties": {
              "interval": {
                "type": "number",
                "description": "Number of hours to obtain transactions for.",
                "example": 1,
                "minimum": 1,
                "maximum": 720
              }
            }
          }
        }
      },
      "CreateSubscriptionIncoming": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "ACCOUNT_INCOMING_BLOCKCHAIN_TRANSACTION",
            "enum": ["ACCOUNT_INCOMING_BLOCKCHAIN_TRANSACTION"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["id", "url"],
            "properties": {
              "id": {
                "description": "ID of the account, on which the webhook will be applied, when new incoming blockchain transaction will be credited.",
                "example": "5e6be8e9e6aa436299950c41",
                "maxLength": 24,
                "minLength": 24,
                "type": "string"
              },
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when new incoming blockchain transaction will be credited.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionNotification": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "ADDRESS_TRANSACTION",
            "enum": ["ADDRESS_TRANSACTION"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["chain", "address", "url"],
            "properties": {
              "address": {
                "description": "Blockchain address to watch.",
                "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
                "maxLength": 128,
                "minLength": 13,
                "type": "string"
              },
              "chain": {
                "description": "Blockchain of the address.",
                "example": "SOL",
                "type": "string",
                "enum": ["SOL", "ETH", "MATIC", "CELO", "KLAY", "BTC", "LTC", "BCH", "DOGE", "TRON", "BSC"]
              },
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when transaction is detected on the address.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionContractLogEvent": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "CONTRACT_LOG_EVENT",
            "enum": ["CONTRACT_LOG_EVENT"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["chain", "event", "url"],
            "properties": {
              "event": {
                "description": "Hexadecimal data representing the event emitted from the smart contract; represents \"topic[0,1,2,...]\" from the event log.",
                "example": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
                "maxLength": 66,
                "minLength": 66,
                "type": "string"
              },
              "chain": {
                "description": "The blockchain on which events should be monitored.",
                "example": "MATIC",
                "type": "string",
                "enum": ["ETH", "MATIC", "CELO", "KLAY", "BSC"]
              },
              "url": {
                "type": "string",
                "description": "The URL of the endpoint where an HTTP POST request will be sent when the block where the events from the smart contracts are reflected gets completed.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionMultiTokenTransferEvent": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "CONTRACT_MULTITOKEN_TXS_PER_BLOCK",
            "enum": ["CONTRACT_MULTITOKEN_TXS_PER_BLOCK"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["chain", "url"],
            "properties": {
              "chain": {
                "description": "The blockchain on which events should be monitored.",
                "example": "MATIC",
                "type": "string",
                "enum": ["ETH", "MATIC", "CELO", "KLAY", "BSC"]
              },
              "url": {
                "type": "string",
                "description": "The URL of the endpoint where an HTTP POST request will be sent when the block where the events from the smart contracts are reflected gets completed.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionNftTransferEvent": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "CONTRACT_NFT_TXS_PER_BLOCK",
            "enum": ["CONTRACT_NFT_TXS_PER_BLOCK"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["chain", "url"],
            "properties": {
              "chain": {
                "description": "The blockchain on which events should be monitored.",
                "example": "MATIC",
                "type": "string",
                "enum": ["ETH", "MATIC", "CELO", "KLAY", "BSC"]
              },
              "url": {
                "type": "string",
                "description": "The URL of the endpoint where an HTTP POST request will be sent when the block where the events from the smart contracts are reflected gets completed.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionTradeMatch": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "CUSTOMER_TRADE_MATCH",
            "enum": ["CUSTOMER_TRADE_MATCH"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["id", "url"],
            "properties": {
              "id": {
                "description": "ID of the customer, on which the webhook will be applied, when on any of his accounts trade will be matched and closed.",
                "example": "5e6be8e9e6aa436299950c41",
                "maxLength": 24,
                "minLength": 24,
                "type": "string"
              },
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when on any of his accounts trade will be matched and closed.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionPartialTradeMatch": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "CUSTOMER_PARTIAL_TRADE_MATCH",
            "enum": ["CUSTOMER_PARTIAL_TRADE_MATCH"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["id", "url"],
            "properties": {
              "id": {
                "description": "ID of the customer, on which the webhook will be applied, when on any of his accounts trade will be matched and closed.",
                "example": "5e6be8e9e6aa436299950c41",
                "maxLength": 24,
                "minLength": 24,
                "type": "string"
              },
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when on any of his accounts trade will be matched and closed.",
                "example": "https://webhook.tatum.io/trade",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionKMSError": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "KMS_FAILED_TX",
            "enum": ["KMS_FAILED_TX"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["url"],
            "properties": {
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when error occurs inside Tatum KMS.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionKMSSuccess": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "KMS_COMPLETED_TX",
            "enum": ["KMS_COMPLETED_TX"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["url"],
            "properties": {
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when tx is sucessfully broadcasted using Tatum KMS.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionTxInTheBlock": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "TRANSACTION_IN_THE_BLOCK",
            "enum": ["TRANSACTION_IN_THE_BLOCK"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["url"],
            "properties": {
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when outgoing ledger transaction is included in the block.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "CreateSubscriptionPending": {
        "type": "object",
        "required": ["type", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the subscription.",
            "example": "ACCOUNT_PENDING_BLOCKCHAIN_TRANSACTION",
            "enum": ["ACCOUNT_PENDING_BLOCKCHAIN_TRANSACTION"]
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes based on the subscription type.",
            "required": ["id", "url"],
            "properties": {
              "id": {
                "description": "ID of the account, on which the webhook will be applied, when new incoming pending blockchain transaction with 0 confirmations will be credited.",
                "example": "5e6be8e9e6aa436299950c41",
                "maxLength": 24,
                "minLength": 24,
                "type": "string"
              },
              "url": {
                "type": "string",
                "description": "URL of the endpoint, where HTTP POST request will be sent, when new incoming pending blockchain transaction with 0 confirmations will be credited.",
                "example": "https://dashboard.tatum.io/webhook-handler",
                "maxLength": 500
              }
            }
          }
        }
      },
      "OffchainAddresses": {
        "type": "object",
        "required": ["addresses"],
        "properties": {
          "addresses": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["accountId"],
              "properties": {
                "accountId": {
                  "description": "ID of the account, for which blockchain address will be created.",
                  "example": "5e6be8e9e6aa436299950c41",
                  "maxLength": 24,
                  "minLength": 24,
                  "type": "string"
                },
                "derivationKey": {
                  "description": "Derivation key index for given address to generate. If not present, first not used address will be created.",
                  "format": "int32",
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 2147483647
                }
              }
            }
          }
        }
      },
      "Address": {
        "required": ["address", "currency"],
        "properties": {
          "address": {
            "description": "Blockchain address.",
            "example": "7c21ed165e294db78b95f0f181086d6f",
            "type": "string"
          },
          "currency": {
            "description": "Currency of generated address. BTC, LTC, DOGE, BCH, ETH, XRP, XLM, BNB, TRX, ERC20, TRC20.",
            "example": "BTC",
            "type": "string"
          },
          "derivationKey": {
            "description": "Derivation key index for given address.",
            "format": "int32",
            "type": "integer",
            "maximum": 2147483647
          },
          "xpub": {
            "description": "Extended public key to derive address from. In case of XRP, this is account address, since address is defined as DestinationTag, which is address field. In case of XLM, this is account address, since address is defined as message, which is address field.",
            "example": "xpub6FB4LJzdKNkkpsjggFAGS2p34G48pqjtmSktmK2Ke3k1LKqm9ULsg8bGfDakYUrdhe2EHw5uGKX9DrMbrgYnVfDwrksT4ZVQ3vmgEruo3Ka",
            "type": "string"
          },
          "destinationTag": {
            "description": "In case of XRP, destinationTag is the distinguisher of the account.",
            "type": "number",
            "example": 5
          },
          "memo": {
            "description": "In case of BNB, message is the distinguisher of the account.",
            "type": "string",
            "example": "5"
          },
          "message": {
            "description": "In case of XLM, message is the distinguisher of the account.",
            "type": "string",
            "example": "5"
          }
        },
        "type": "object"
      },
      "Trade": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "description": "ID of the trade", "example": "7c21ed165e294db78b95f0f1" },
          "type": {
            "type": "string",
            "description": "Type of the trade, BUY or SELL",
            "example": "BUY",
            "enum": ["BUY", "SELL"]
          },
          "price": { "type": "string", "description": "Price to buy / sell", "example": "8650.4" },
          "amount": {
            "type": "string",
            "description": "Amount of the trade to be bought / sold",
            "example": "15000"
          },
          "pair": { "type": "string", "description": "Trading pair", "example": "BTC/EUR" },
          "isMaker": {
            "type": "boolean",
            "description": "If closed trade was Maker or Taker trade",
            "example": true
          },
          "fill": {
            "type": "string",
            "description": "How much of the trade was already filled.",
            "example": "1500"
          },
          "feeAccountId": {
            "type": "string",
            "description": "ID of the account where fee will be paid, if any. If trade is a BUY or FUTURE_BUY type, feeAccountId must have same currency as a currency of currency2AccountId, and vice versa if trade is a SELL or FUTURE_SELL type, feeAccountId must have same currency as a currency of currency1AccountId.",
            "example": "7c21ed165e294db78b95f0f1",
            "minLength": 24,
            "maxLength": 24
          },
          "fee": {
            "type": "number",
            "description": "Percentage of the trade amount to be paid as a fee.",
            "example": 1.5,
            "minimum": 0,
            "maximum": 100
          },
          "currency1AccountId": {
            "type": "string",
            "description": "ID of the account of the currenc 1 trade currency",
            "example": "7c21ed165e294db78b95f0f1"
          },
          "currency2AccountId": {
            "type": "string",
            "description": "ID of the account of the currenc 2 trade currency",
            "example": "7c21ed165e294db78b95f0f1"
          },
          "created": {
            "type": "number",
            "description": "Creation date, UTC millis",
            "example": 1585170363103
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes for the future type.",
            "required": ["sealDate"],
            "properties": {
              "sealDate": {
                "type": "number",
                "description": "Time in UTC when the future will be filled.",
                "example": 1572031674384,
                "minimum": 0
              },
              "percentBlock": {
                "description": "Percentage of the future amount which the selling or buying account must have available for the future’s creation. This amount will be blocked until the future is filled or expires.",
                "type": "number",
                "example": 1.5,
                "minimum": 0,
                "maximum": 100
              },
              "percentPenalty": {
                "description": "If one of the parties doesn’t have the full amount of the future at the time of expiration filled, the party will be penalized.",
                "type": "number",
                "example": 1.5,
                "minimum": 0,
                "maximum": 100
              }
            }
          }
        }
      },
      "CreateTrade": {
        "type": "object",
        "required": ["type", "price", "amount", "pair", "currency1AccountId", "currency2AccountId", "attr"],
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the trade, BUY, SELL, FUTURE_BUY, FUTURE_SELL",
            "example": "BUY",
            "enum": ["BUY", "SELL", "FUTURE_BUY", "FUTURE_SELL"]
          },
          "price": {
            "type": "string",
            "description": "Price to buy / sell",
            "example": "8650.4",
            "maxLength": 38,
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "amount": {
            "type": "string",
            "description": "Amount of the trade to be bought / sold",
            "example": "15000",
            "maxLength": 38,
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "pair": {
            "type": "string",
            "description": "Trading pair",
            "example": "BTC/EUR",
            "minLength": 3,
            "maxLength": 30,
            "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
          },
          "currency1AccountId": {
            "type": "string",
            "description": "ID of the account of the currency 1 trade currency",
            "example": "7c21ed165e294db78b95f0f1",
            "minLength": 24,
            "maxLength": 24
          },
          "currency2AccountId": {
            "type": "string",
            "description": "ID of the account of the currency 2 trade currency",
            "example": "7c21ed165e294db78b95f0f1",
            "minLength": 24,
            "maxLength": 24
          },
          "feeAccountId": {
            "type": "string",
            "description": "ID of the account where fee will be paid, if any. If trade is a BUY or FUTURE_BUY type, feeAccountId must have same currency as a currency of currency2AccountId, and vice versa if trade is a SELL or FUTURE_SELL type, feeAccountId must have same currency as a currency of currency1AccountId.",
            "example": "7c21ed165e294db78b95f0f1",
            "minLength": 24,
            "maxLength": 24
          },
          "fee": {
            "type": "number",
            "description": "Percentage of the trade amount to be paid as a fee.",
            "example": 1.5,
            "minimum": 0,
            "maximum": 100
          },
          "attr": {
            "type": "object",
            "description": "Additional attributes for the future type.",
            "required": ["sealDate"],
            "properties": {
              "sealDate": {
                "type": "number",
                "description": "Time in UTC when the future will be filled.",
                "example": 1572031674384,
                "minimum": 0
              },
              "percentBlock": {
                "description": "Percentage of the future amount which selling or buying account must have available on future creation. This amount will be blocked till future is filled or expires.",
                "example": 1.5,
                "minimum": 0,
                "maximum": 100
              },
              "percentPenalty": {
                "description": "If one of the parties dont have filled full amount of the future at the time of expiration, the party will be penalized. Penalty is sent to opposite party in exchanged crypto.",
                "example": 1.5,
                "minimum": 0,
                "maximum": 100
              }
            }
          }
        }
      },
      "BnbBlock": {
        "type": "object",
        "properties": {
          "timestamp": { "type": "number", "example": 1651145988650 },
          "blockHeight": { "type": "number", "example": 44925860 },
          "tx": { "type": "array", "items": { "$ref": "#/components/schemas/BnbTransaction" } }
        }
      },
      "BnbTransaction": {
        "type": "object",
        "properties": {
          "txHash": {
            "type": "string",
            "example": "4B944BBF78F3ADE3A377551B5EA7AD0FEDBDA13165D932F94B106EF7A8E16C1A"
          },
          "blockHeight": { "type": "number", "example": 44925860 },
          "txType": { "type": "string", "example": "TRANSFER" },
          "timeStamp": { "type": "string", "example": "2019-10-17T18:58:01.423Z" },
          "fromAddr": { "type": "string", "example": "tbnb138u9djee6fwphhd2a3628q2h0j5w97yx48zqex" },
          "toAddr": { "type": "string", "example": "tbnb14wu3a8pmauj2kjswyvxtvhdrjktx60efq227uw" },
          "value": { "type": "string", "example": "200.00000000" },
          "txAsset": { "type": "string", "example": "BNB" },
          "txFee": { "type": "string", "example": "0.00037500" },
          "code": { "type": "number", "example": 0 },
          "memo": { "type": "string", "example": "" },
          "source": { "type": "number", "example": 0 },
          "sequence": { "type": "number" }
        }
      },
      "BnbTx": {
        "type": "object",
        "properties": {
          "code": { "type": "number", "example": 0 },
          "hash": {
            "type": "string",
            "example": "4B944BBF78F3ADE3A377551B5EA7AD0FEDBDA13165D932F94B106EF7A8E16C1A"
          },
          "height": { "type": "string", "example": "44925860" },
          "log": { "type": "string", "example": "Msg 0: " },
          "ok": { "type": "boolean", "example": true },
          "tx": {
            "properties": {
              "type": { "type": "string", "example": "auth/StdTx" },
              "value": {
                "properties": {
                  "memo": { "type": "string", "example": "" },
                  "msg": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": { "type": "string", "example": "cosmos-sdk/Send" },
                        "value": {
                          "properties": {
                            "inputs": {
                              "description": "List of transactions, from which assets are being sent.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "example": "tbnb138u9djee6fwphhd2a3628q2h0j5w97yx48zqex"
                                  },
                                  "coins": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "amount": { "type": "string", "example": "20000000000" },
                                        "denom": { "type": "string", "example": "BNB" }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "outputs": {
                              "description": "List of recipient addresses and amounts to send to each of them.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "example": "tbnb14wu3a8pmauj2kjswyvxtvhdrjktx60efq227uw"
                                  },
                                  "coins": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "amount": { "type": "string", "example": "20000000000" },
                                        "denom": { "type": "string", "example": "BNB" }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "type": "object"
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "account_number": { "type": "string", "example": "14" },
                        "pub_key": {
                          "properties": {
                            "type": { "type": "string", "example": "tendermint/PubKeySecp256k1" },
                            "value": {
                              "type": "string",
                              "example": "A4q95eEn4cR1bbxVRqYc8pbLvKYyaMxjzaTSmkTJQUr6"
                            }
                          },
                          "type": "object"
                        },
                        "sequence": { "type": "string", "example": "47816" },
                        "signature": {
                          "type": "string",
                          "example": "VhewxOCPucjrtrpRbQMbl05i5MyJMrw12nUJ4ATssB1qvCqIO2+Fgqa/WTHaYpkhjJuIbpK620e0zpIQ56a5nw=="
                        }
                      }
                    }
                  },
                  "source": { "type": "string", "example": "0" }
                },
                "type": "object"
              }
            },
            "type": "object"
          }
        }
      },
      "BnbTxInAccount": {
        "type": "object",
        "properties": {
          "total": { "type": "number", "example": 10 },
          "tx": { "type": "array", "items": { "$ref": "#/components/schemas/BnbTransaction" } }
        }
      },
      "BnbAccount": {
        "type": "object",
        "properties": {
          "account_number": { "type": "number", "example": 696215 },
          "address": { "type": "string", "example": "tbnb185tqzq3j6y7yep85lncaz9qeectjxqe5054cgn" },
          "balances": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "free": { "type": "string", "example": "207.00000000" },
                "frozen": { "type": "string", "example": "0.00000000" },
                "locked": { "type": "string", "example": "0.00000000" },
                "symbol": { "type": "string", "example": "BNB" }
              }
            }
          },
          "flags": { "type": "number", "example": 0 },
          "sequence": { "type": "number", "example": 0 }
        }
      },
      "BtcBlockHash": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Block hash",
            "example": "0000000053f225e202cf27fe3046e06719efd3b31b5ab75fc5ef7f853c8b246f"
          }
        }
      },
      "BtcBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Hash of block.",
            "example": "00000000ca231a439a5c0a86a5a5dd6dc1918a8e897b96522fa9499288e70183"
          },
          "height": {
            "description": "The number of blocks preceding a particular block on a block chain.",
            "type": "number",
            "example": 15235
          },
          "depth": {
            "description": "The number of blocks following a particular block on a block chain, including current one.",
            "type": "number",
            "example": 1567867
          },
          "version": { "type": "number", "description": "Block version.", "example": 1 },
          "prevBlock": {
            "type": "string",
            "description": "Hash of the previous block.",
            "example": "000000006e79360d7b2519410fe5a73e8e08393fd7166620c73c711e4507d9fd"
          },
          "merkleRoot": {
            "type": "string",
            "description": "The root node of a merkle tree, a descendant of all the hashed pairs in the tree.",
            "example": "480c227c5042377dbd54464d33e1f59c19fe02fe76d7f55b6955db438479aece"
          },
          "time": { "type": "number", "description": "Time of the block.", "example": 1338861927 },
          "bits": { "type": "number", "example": 486604799 },
          "nonce": {
            "type": "number",
            "description": "Arbitrary number that is used in Bitcoin's proof of work consensus algorithm.",
            "example": 1193572362
          },
          "txs": { "type": "array", "items": { "$ref": "#/components/schemas/BtcTx" } }
        }
      },
      "BtcInfo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain of the blockchain, main or test.",
            "example": "test"
          },
          "blocks": { "type": "number", "description": "Last block.", "example": 1579820 },
          "headers": { "type": "number", "description": "Last headers.", "example": 1579820 },
          "bestblockhash": {
            "description": "Hash of the last block.",
            "type": "string",
            "example": "0000000000000106e4c03ca093ce0cf77e796ddff4f3cadc59ca6b0380e3eed4"
          },
          "difficulty": {
            "type": "number",
            "description": "Difficulty of the algorithm.",
            "example": 6522714.521250089
          }
        }
      },
      "BtcBasedBalance": {
        "type": "object",
        "properties": {
          "incoming": {
            "type": "string",
            "description": "Total sum of the assets that arrives to the address.",
            "example": "0.1234"
          },
          "outgoing": {
            "type": "string",
            "description": "Total sum of the assets that leaves from the address.",
            "example": "0.1"
          }
        }
      },
      "BtcTx": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Transaction hash.",
            "example": "4c7846a8ff8415945e96937dea27bdb3144c15d793648d725602784826052586"
          },
          "hex": {
            "type": "string",
            "description": "Transaction hex.",
            "example": "020000000001072840e4f49e088d9ab233f6209aede5d91c44ecb59f490dbf289e7ef5028bc6aa0000000000ffffffffada5ca08d78992fac3bd48e1ac197c2b4bbd98b349d706ba7dd38c7c3dceed940000000000ffffffff0265691f1374c79a164186b6290a6bdf785561dcf5e3c155599dbaa646e2f06e0000000000ffffffff4f0b53ff85e10ff33c3cf95a1b650729c83b75d6b894d8224b40ca00b944a3ff0000000000ffffffff30aa398d22fd3b60534389c926093863d560eaeca4c6f85454b5fa0222f96db30000000000ffffffff9c02daa47a879222fc7e9d3c0ec7158d4853d3cc4a4465001412e5fc0371e7470100000000ffffffff78bdc156966a07d09f9bdb45ccb2e21765657f806b7e2ab7b7bb9dad5d5b5bc30000000000ffffffff010c2845000000000016001490a446c7f165cfd99dd5dd87a6bb83a17fd9e9f1024730440220384fa3d7935db56a637cf6c662dfc6990957e2838afa5db29e7569c996ba24930220567d4ed8ec36a940d871bc26d292656690e55bd10567c823af2c6ffab9a7868f012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c0247304402206b6db0dd0dd158835618613b952056327113374a8dec6be5f41c41a8ce552fe2022027c356009488123c27c98aa66080f6898484b7c098dc366540be8f6935feeefe012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c0247304402200baf8a00f9f767cc83c35e3a29a03a4f054c886fc07828481b83ae858eb5853902202f6d82ef65f64ac5db1db947aa03e1ed5f3b19710cf4c3e4448cd5a7f25277df012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c02483045022100b7d574102ede6a4d556269129592faa8f7ff54ca846c2516804811e06aca380202206a0e519a911e3fe130f1d446f5fd16b951fd25136b2f9b2980dd9eefe4f3a860012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c02473044022008548dc3eff2713011d3fad3e661918f51cd4a3b688f90326f5febf4dbb34c8f0220245e37520b501a7c429f9428c4892034d398c8198006fedd9fdb45790c8d0d23012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c02473044022044bd3552b24b49b2c9bc2acee7a8d587407070cb80e7c65cdefff78fe7df0f99022067581ae9d54d2fdedb9bcf69c2281830e165f9df631f6c889f98dfb7c1e4a78a012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c02483045022100a141642697ba55407e4d6d2b6d3d1b2f93d5126794e77028c00307835a4c71ce02202658200b9d779d0f6f169bdd27dc81cbbb10718e57754349e57e020ea6bf5cfb012103ccb40d87b4e847b970a9dd23c3d5078964213cf6a78257796d801316bb7bb60c00000000"
          },
          "witnessHash": {
            "type": "string",
            "description": "Witness hash in case of a SegWit transaction.",
            "example": "4c7846a8ff8415945e96937dea27bdb3144c15d793648d725602784826052586"
          },
          "fee": {
            "type": "number",
            "description": "Fee paid for this transaction, in satoshis.",
            "example": 4540
          },
          "rate": { "type": "number", "example": 20088 },
          "mtime": { "type": "number", "example": 1575663337 },
          "blockNumber": {
            "type": "number",
            "description": "Height of the block this transaction belongs to.",
            "example": 1611609
          },
          "block": {
            "type": "string",
            "description": "Hash of the block this transaction belongs to.",
            "example": "00000000000001e13fe1eb3977f3379e3d0f6577fc6e087d27db46597ebddb8b"
          },
          "time": { "type": "number", "description": "Time of the transaction.", "example": 1575663091 },
          "index": {
            "type": "number",
            "description": "Index of the transaction in the block.",
            "example": 1
          },
          "version": { "type": "number", "description": "Index of the transaction.", "example": 2 },
          "inputs": {
            "description": "List of transactions, from which assets are being sent.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTxInput" }
          },
          "outputs": {
            "type": "array",
            "description": "List of recipient addresses and amounts to send to each of them.",
            "items": { "$ref": "#/components/schemas/BtcTxOutput" }
          },
          "locktime": {
            "type": "number",
            "description": "Block this transaction was included in.",
            "example": 1611608
          }
        }
      },
      "BtcTxOutput": {
        "type": "object",
        "properties": {
          "value": { "type": "number", "description": "Sent amount in satoshis.", "example": 2068942 },
          "script": {
            "type": "string",
            "description": "Transaction script.",
            "example": "a914eaf2ad7e161c3ce7092bde14dc5842b642fe925187"
          },
          "address": {
            "type": "string",
            "description": "Recipient address.",
            "example": "2NEfWpiQwLEcHGbX2Fwij16NDxTEZwHk4BH"
          }
        }
      },
      "BtcTxInput": {
        "type": "object",
        "properties": {
          "prevout": { "$ref": "#/components/schemas/BtcTxInputPrevOut" },
          "script": {
            "type": "string",
            "description": "Data generated by a spender which is almost always used as variables to satisfy a pubkey script.",
            "example": "1600148c65244f095f3689aebb70981d102e33036fe786"
          },
          "witness": {
            "type": "string",
            "description": "Transaction witness.",
            "example": "0247304402207d7af97665ef5502c957f76a9fcdde2c228b6a8dc9951d45c318e6dfca0fcd2802207519528d6b61cc044800ab2cb499ef5f31d4decdc327c14fad4abbc3dd6e0190012102861d682cfd3bec8cbed98f5162299ba613bc5f352dd0d51961a5d81359fbc0af"
          },
          "sequence": { "type": "number", "example": 4294967294 },
          "coin": { "$ref": "#/components/schemas/BtcTxInputCoin" }
        }
      },
      "BtcTxInputCoin": {
        "properties": {
          "version": { "type": "number", "example": 2 },
          "blockNumber": { "type": "number", "example": 1611608 },
          "value": {
            "type": "number",
            "description": "Amount of the transaction, in Satoshis (1 BTC = 100 000 000 Satoshis)",
            "example": 1341956178
          },
          "script": { "type": "string", "example": "0014049a97d91d4e1123899bf48c5ba6ce3fd959664e" },
          "address": {
            "type": "string",
            "description": "Sender address.",
            "example": "tb1qqjdf0kgafcgj8zvm7jx9hfkw8lv4jejw6wsmjg"
          },
          "coinbase": {
            "type": "boolean",
            "description": "Coinbase transaction - miner fee.",
            "example": false
          }
        },
        "type": "object"
      },
      "BtcTxInputPrevOut": {
        "properties": {
          "hash": {
            "type": "string",
            "description": "Transaction hash of the input.",
            "example": "60bc8445c11318e45a72a3259e65118d2f352568757e6ceb8bf1b527ce68379f"
          },
          "index": { "type": "number", "description": "Transaction index of the input.", "example": 1 }
        },
        "type": "object"
      },
      "BtcUTXO": {
        "type": "object",
        "properties": {
          "version": { "type": "number", "description": "The version of the transaction", "example": 1 },
          "height": {
            "type": "number",
            "description": "The height (number) of the block where the transaction is included in",
            "example": 210000
          },
          "value": {
            "type": "number",
            "description": "The amount of the UTXO (in satoshis)",
            "example": 30000000
          },
          "script": {
            "type": "string",
            "description": "Data generated by the spender; is almost always used as variables to satisfy the conditions in the pubkey script",
            "example": "76a91400ba915c3d18907b79e6cfcd8b9fdf69edc7a7db88ac"
          },
          "address": {
            "type": "string",
            "description": "The blockchain address of the UTXO owner",
            "example": "R9M3aUWCcKoiqDPusJvqNkAbjffLgCqYip"
          },
          "coinbase": {
            "type": "boolean",
            "description": "If set to \"true\", the transaction is a coinbase transaction (a transaction created by a Bitcoin miner to collect their reward)",
            "example": false
          },
          "hash": {
            "type": "string",
            "description": "The hash of the transaction",
            "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc"
          },
          "index": {
            "type": "number",
            "description": "The index of the transaction output checked for the UTXO",
            "example": 0
          }
        }
      },
      "FeeAndChange": {
        "type": "object",
        "required": ["changeAddress"],
        "properties": {
          "changeAddress": {
            "description": "Address, where unspent funds will be transferred.",
            "type": "string",
            "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf",
            "minimum": 30,
            "maximum": 110
          },
          "fee": { "type": "string", "description": "Fee to be paid.", "example": "0.5" }
        }
      },
      "AdaTransactionFromAddress": {
        "type": "object",
        "required": ["to", "fromAddress"],
        "properties": {
          "fromAddress": {
            "description": "The array of blockchain addresses to send the assets from and their private keys. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "privateKey"],
              "properties": {
                "address": {
                  "description": "The blockchain address to send the assets from",
                  "type": "string",
                  "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS",
                  "minimum": 30,
                  "maximum": 50
                },
                "privateKey": {
                  "description": "The private key of the address to send the assets from",
                  "type": "string",
                  "minimum": 52,
                  "maximum": 52,
                  "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf"
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in ADA). The difference between the UTXOs calculated in the <code>fromAddress</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in ADA)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in ADA)",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "AdaTransactionFromUTXO": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the private keys of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index", "privateKey"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "privateKey": {
                  "description": "The private key of the blockchain address that holds the UTXO to be spent",
                  "type": "string",
                  "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf",
                  "minLength": 52,
                  "maxLength": 52
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in ADA). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in ADA)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in ADA)",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "AdaTransactionFromAddressKMS": {
        "type": "object",
        "required": ["to", "fromAddress"],
        "properties": {
          "fromAddress": {
            "description": "The array of blockchain addresses to send the assets from and their signature IDs. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "signatureId"],
              "properties": {
                "address": {
                  "description": "The blockchain address to send the assets from",
                  "type": "string",
                  "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS",
                  "minimum": 30,
                  "maximum": 50
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "The KMS identifier of the private key of the address to send the assets from"
                },
                "index": {
                  "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in ADA). The difference between the UTXOs calculated in the <code>fromAddress</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in ADA)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in ADA)",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "AdaTransactionFromUTXOKMS": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the signature IDs of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "signatureId", "index"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "The KMS identifier of the private key of the blockchain address that holds the UTXO to be spent"
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in ADA). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in ADA)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in ADA)",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BtcTransactionFromAddress": {
        "type": "object",
        "required": ["to", "fromAddress"],
        "properties": {
          "fromAddress": {
            "description": "The array of blockchain addresses to send the assets from and their private keys. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromAddressSource" }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in BTC). The difference between the UTXOs calculated in the <code>fromAddress</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromAddressTarget" }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in BTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BtcTransactionFromAddressSource": {
        "type": "object",
        "required": ["address", "privateKey"],
        "properties": {
          "address": {
            "description": "The blockchain address to send the assets from",
            "type": "string",
            "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS",
            "minimum": 30,
            "maximum": 50
          },
          "privateKey": {
            "description": "The private key of the address to send the assets from",
            "type": "string",
            "minimum": 52,
            "maximum": 52,
            "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf"
          }
        }
      },
      "BtcTransactionFromAddressTarget": {
        "type": "object",
        "required": ["address", "value"],
        "properties": {
          "address": {
            "description": "The blockchain address to receive the assets",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          },
          "value": {
            "description": "The amount to receive (in BTC)",
            "type": "number",
            "minimum": 0,
            "example": 0.02969944
          }
        }
      },
      "BtcTransactionFromUTXO": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the private keys of the associated blockchain addresses",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromUTXOSource" }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in BTC). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromUTXOTarget" }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in BTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaining after covering the fee; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BtcTransactionFromUTXOSource": {
        "type": "object",
        "required": ["txHash", "index", "privateKey"],
        "properties": {
          "txHash": {
            "description": "The transaction hash of the UTXO to be spent",
            "type": "string",
            "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
            "minLength": 64,
            "maxLength": 64
          },
          "index": {
            "description": "The index of the UTXO to be spent",
            "type": "number",
            "example": 0,
            "minimum": 0,
            "maximum": 2147483647
          },
          "privateKey": {
            "description": "The private key of the blockchain address that holds the UTXO to be spent",
            "type": "string",
            "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf",
            "minLength": 52,
            "maxLength": 52
          }
        }
      },
      "BtcTransactionFromUTXOTarget": {
        "type": "object",
        "required": ["address", "value"],
        "properties": {
          "address": {
            "description": "The blockchain address to receive the assets",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          },
          "value": {
            "description": "The amount to receive (in BTC)",
            "type": "number",
            "minimum": 0,
            "example": 0.02969944
          }
        }
      },
      "BtcTransactionFromAddressKMS": {
        "type": "object",
        "required": ["to", "fromAddress"],
        "properties": {
          "fromAddress": {
            "description": "The array of blockchain addresses to send the assets from and their signature IDs. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromAddressKMSSource" }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in BTC). The difference between the UTXOs calculated in the <code>fromAddress</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromAddressKMSTarget" }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in BTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BtcTransactionFromAddressKMSSource": {
        "type": "object",
        "required": ["address", "signatureId"],
        "properties": {
          "address": {
            "description": "The blockchain address to send the assets from",
            "type": "string",
            "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS",
            "minimum": 30,
            "maximum": 50
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "The KMS identifier of the private key of the address to send the assets from"
          },
          "index": {
            "description": "(Only if the signature ID is mnemonic-based and you run KMS v6.2 or later) The index of the address to send the assets from that was generated from the mnemonic",
            "type": "number",
            "example": 0,
            "minimum": 0,
            "maximum": 2147483647
          }
        }
      },
      "BtcTransactionFromAddressKMSTarget": {
        "type": "object",
        "required": ["address", "value"],
        "properties": {
          "address": {
            "description": "The blockchain address to receive the assets",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          },
          "value": {
            "description": "The amount to receive (in BTC)",
            "type": "number",
            "minimum": 0,
            "example": 0.02969944
          }
        }
      },
      "BtcTransactionFromUTXOKMS": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the signature IDs of the associated blockchain addresses",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromUTXOKMSSource" }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in BTC). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BtcTransactionFromUTXOKMSTarget" }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in BTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BtcTransactionFromUTXOKMSSource": {
        "type": "object",
        "required": ["txHash", "signatureId", "index"],
        "properties": {
          "txHash": {
            "description": "The transaction hash of the UTXO to be spent",
            "type": "string",
            "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
            "minLength": 64,
            "maxLength": 64
          },
          "index": {
            "description": "The index of the UTXO to be spent",
            "type": "number",
            "example": 0,
            "minimum": 0,
            "maximum": 2147483647
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "The KMS identifier of the private key of the blockchain address that holds the UTXO to be spent"
          }
        }
      },
      "BtcTransactionFromUTXOKMSTarget": {
        "type": "object",
        "required": ["address", "value"],
        "properties": {
          "address": {
            "description": "The blockchain address to receive the assets",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          },
          "value": {
            "description": "The amount to receive (in BTC)",
            "type": "number",
            "minimum": 0,
            "example": 0.02969944
          }
        }
      },
      "BchBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Hash of block.",
            "example": "000000000000000005e14d3f9fdfb70745308706615cfa9edca4f4558332b201"
          },
          "size": { "type": "number", "description": "Block size.", "example": 81577 },
          "height": {
            "type": "number",
            "description": "The number of blocks preceding a particular block on a block chain.",
            "example": 500000
          },
          "version": { "type": "number", "description": "Block version.", "example": 536870912 },
          "merkleroot": {
            "type": "string",
            "description": "The root node of a merkle tree, a descendant of all the hashed pairs in the tree.",
            "example": "4af279645e1b337e655ae3286fc2ca09f58eb01efa6ab27adedd1e9e6ec19091"
          },
          "tx": {
            "type": "array",
            "description": "List of transactions present in the block.",
            "items": { "$ref": "#/components/schemas/BchTx" }
          },
          "time": { "type": "number", "description": "Time of the block.", "example": 1509343584 },
          "nonce": {
            "type": "number",
            "description": "Arbitrary number that is used in Bitcoin's proof of work consensus algorithm.",
            "example": 3604508752
          },
          "difficulty": { "type": "number", "example": 113081236211.45331 },
          "confirmations": {
            "type": "number",
            "description": "Number of blocks mined after this block.",
            "example": 109602
          },
          "previousblockhash": {
            "type": "string",
            "description": "Hash of the previous block.",
            "example": "0000000000000000043831d6ebb013716f0580287ee5e5687e27d0ed72e6e523"
          },
          "nextblockhash": {
            "type": "string",
            "description": "Hash of the next block.",
            "example": "00000000000000000568f0a96bf4348847bc84e455cbfec389f27311037a20f3"
          }
        }
      },
      "BchInfo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain of the blockchain, main or test.",
            "example": "main"
          },
          "blocks": { "type": "number", "description": "Last block.", "example": 609604 },
          "bestblockhash": {
            "type": "string",
            "description": "Hash of the last block.",
            "example": "0000000000000000024997c878c5a90bd73cd50060877c4f70eef1f2e92243f5"
          },
          "difficulty": {
            "type": "number",
            "description": "Difficulty of the PoW algorithm.",
            "example": 375206303347.133
          }
        }
      },
      "BchTransaction": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the private keys of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index", "privateKey"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "privateKey": {
                  "description": "The private key of the blockchain address that holds the UTXO to be spent",
                  "type": "string",
                  "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf",
                  "minLength": 52,
                  "maxLength": 52
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in BCH). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in BCH)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in BCH); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BchTransactionKMS": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the signature IDs of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index", "signatureId"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "The KMS identifier of the private key of the blockchain address that holds the UTXO to be spent"
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in BCH). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in BCH)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in BCH); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "BchTx": {
        "type": "object",
        "properties": {
          "txid": {
            "type": "string",
            "example": "fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33"
          },
          "version": { "type": "number", "example": 1 },
          "locktime": { "type": "number", "example": 0 },
          "vin": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "txid": {
                  "type": "string",
                  "example": "eea57285462dd70dadcd431fc814857b3f81fe4d0a059a8c02c12fd7d33c02d1"
                },
                "vout": { "type": "number", "example": 0 },
                "scriptSig": {
                  "properties": {
                    "hex": {
                      "type": "string",
                      "example": "48304502210083753ff9954579f1062d60905650d5d07f50dedc96f9425403b80957f199e1ee022053625597b069c48ed29f8825bd3c8f66757ccaa21a7bb49314eae4eca1fb8d7041210299b1eedeb115b5880cd5e0df0717bd982748a8e003e34371dc36301e17ee0ed6"
                    },
                    "asm": {
                      "type": "string",
                      "example": "304502210083753ff9954579f1062d60905650d5d07f50dedc96f9425403b80957f199e1ee022053625597b069c48ed29f8825bd3c8f66757ccaa21a7bb49314eae4eca1fb8d70[ALL|FORKID] 0299b1eedeb115b5880cd5e0df0717bd982748a8e003e34371dc36301e17ee0ed6"
                    }
                  },
                  "type": "object"
                },
                "coinbase": { "type": "string", "example": "04ffff001d02fd04" },
                "sequence": { "type": "number", "example": 2147483647 }
              }
            }
          },
          "vout": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": { "type": "string", "example": "50.00000000" },
                "n": { "type": "number", "example": 0 },
                "scriptPubKey": {
                  "properties": {
                    "hex": {
                      "type": "string",
                      "example": "4104f5eeb2b10c944c6b9fbcfff94c35bdeecd93df977882babc7f3a2cf7f5c81d3b09a68db7f0e04f21de5d4230e75e6dbe7ad16eefe0d4325a62067dc6f369446aac"
                    },
                    "asm": {
                      "type": "string",
                      "example": "04f5eeb2b10c944c6b9fbcfff94c35bdeecd93df977882babc7f3a2cf7f5c81d3b09a68db7f0e04f21de5d4230e75e6dbe7ad16eefe0d4325a62067dc6f369446a OP_CHECKSIG"
                    },
                    "addresses": {
                      "type": "array",
                      "items": { "type": "string" },
                      "example": ["1BW18n7MfpU35q4MTBSk8pse3XzQF8XvzT"]
                    },
                    "type": { "type": "string", "example": "pubkeyhash" }
                  },
                  "type": "object"
                }
              }
            }
          }
        }
      },
      "DogeInfo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain of the blockchain, main or test.",
            "example": "test"
          },
          "blocks": { "type": "number", "description": "Last block.", "example": 1234314 },
          "headers": { "type": "number", "description": "Last headers.", "example": 1234314 },
          "bestblockhash": {
            "type": "string",
            "description": "Hash of the last block.",
            "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
          },
          "difficulty": {
            "type": "number",
            "description": "Difficulty of the PoW algorithm.",
            "example": 0.0018856935093586335
          }
        }
      },
      "DogeBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Hash of block.",
            "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
          },
          "height": {
            "type": "number",
            "description": "The number of blocks preceding a particular block on a block chain.",
            "example": 1234314
          },
          "size": { "type": "number", "description": "The size of the block.", "example": 1234314 },
          "confirmations": {
            "type": "number",
            "description": "Number of confirmations of that block.",
            "example": 1234314
          },
          "weight": { "type": "number", "description": "The weight of the block.", "example": 1234314 },
          "version": { "type": "number", "example": 536870912, "description": "Block version." },
          "previousblockhash": {
            "type": "string",
            "description": "Hash of the previous block.",
            "example": "a3047a060e5d586a9b26779ebe62fc57ce7323745da8f28761ab755454d89c52"
          },
          "merkleRoot": {
            "type": "string",
            "description": "The root node of a merkle tree, a descendant of all the hashed pairs in the tree.",
            "example": "a1634a42a8e956a5fb5225d06c3af6207e7f6fe5a00fa45229edfd0ddfa587f0"
          },
          "time": { "type": "number", "description": "Time of the block.", "example": 1572865501 },
          "bits": { "type": "number", "example": 503452237 },
          "nonce": {
            "type": "number",
            "description": "Arbitrary number that is used in Litecoin's proof of work consensus algorithm.",
            "example": 2278594841
          },
          "txs": { "type": "array", "items": { "$ref": "#/components/schemas/DogeTx" } }
        }
      },
      "DogeTx": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Transaction hash.",
            "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
          },
          "size": { "type": "number", "description": "Size of the transaction.", "example": 145 },
          "vsize": { "type": "number", "example": 145 },
          "version": { "type": "number", "description": "Index of the transaction.", "example": 2 },
          "vin": {
            "description": "List of transactions, from which assets are being sent.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "txid": {
                  "type": "string",
                  "description": "Transaction hash of the input.",
                  "example": "0db5a2881f26f7dce20222f9c2538dc296ab562e134a72052596bdf4bb6913b4"
                },
                "vout": { "type": "number", "description": "Transaction index of the input.", "example": 1 },
                "scriptSig": {
                  "type": "object",
                  "properties": { "asm": { "type": "string" }, "hex": { "type": "string" } }
                },
                "sequence": { "type": "number", "example": 4294967294 }
              }
            }
          },
          "vout": {
            "description": "List of recipient addresses and amounts to send to each of them.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "number",
                  "description": "Amount of UTXO in 1/1000000 DOGE.",
                  "example": 1000
                },
                "n": { "type": "number", "description": "Transaction index of the output.", "example": 1 },
                "scriptPubKey": {
                  "type": "object",
                  "properties": {
                    "asm": {
                      "type": "string",
                      "example": "OP_HASH160 905c261d73922a21a16f505cefccaa07aaee50cd OP_EQUAL"
                    },
                    "hex": { "type": "string", "example": "a914905c261d73922a21a16f505cefccaa07aaee50cd87" },
                    "type": { "type": "string", "example": "scripthash" },
                    "addresses": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "description": "Recipient address.",
                        "example": "n4YNG8q5JyxkeWf7zMi1bMyRZbRKK1W7or"
                      }
                    }
                  }
                }
              }
            }
          },
          "locktime": { "type": "number", "example": 1233222 }
        }
      },
      "DogeUTXO": {
        "type": "object",
        "properties": {
          "scriptPubKey": {
            "type": "object",
            "properties": {
              "asm": {
                "type": "string",
                "example": "OP_HASH160 905c261d73922a21a16f505cefccaa07aaee50cd OP_EQUAL"
              },
              "hex": { "type": "string", "example": "a914905c261d73922a21a16f505cefccaa07aaee50cd87" },
              "type": { "type": "string", "example": "scripthash" },
              "addresses": {
                "type": "array",
                "items": {
                  "type": "string",
                  "description": "Recipient address.",
                  "example": "n4YNG8q5JyxkeWf7zMi1bMyRZbRKK1W7or"
                }
              }
            }
          },
          "version": { "type": "number", "description": "The version of the transaction", "example": 2 },
          "height": {
            "type": "number",
            "description": "The height (number) of the block where the transaction is included in",
            "example": 1233224
          },
          "value": {
            "type": "number",
            "description": "The amount of the UTXO (in 1/1000000 DOGE)",
            "example": 1000
          },
          "coinbase": {
            "type": "boolean",
            "description": "If set to \"true\", the transaction is a coinbase transaction (a transaction created by a Bitcoin miner to collect their reward)",
            "example": false
          },
          "bestblock": {
            "type": "string",
            "description": "The block hash",
            "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
          }
        }
      },
      "DogeTransactionUTXOKMS": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the signature IDs of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "value", "address", "index", "signatureId"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "value": {
                  "type": "string",
                  "description": "The amount to send (in DOGE)",
                  "example": "0.0015"
                },
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "The KMS identifier of the private key of the blockchain address that holds the UTXO to be spent"
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in DOGE). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in DOGE)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in DOGE)",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "DogeTransactionUTXO": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the private keys of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index", "privateKey", "value", "address"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "value": {
                  "type": "string",
                  "description": "The amount to send (in DOGE)",
                  "example": "0.0015"
                },
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "privateKey": {
                  "description": "The private key of the blockchain address that holds the UTXO to be spent",
                  "type": "string",
                  "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf",
                  "minLength": 52,
                  "maxLength": 52
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in DOGE). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in DOGE)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in DOGE)",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "LtcInfo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain of the blockchain, main or test.",
            "example": "test"
          },
          "blocks": { "type": "number", "description": "Last block.", "example": 1234314 },
          "headers": { "type": "number", "description": "Last headers.", "example": 1234314 },
          "bestblockhash": {
            "type": "string",
            "description": "Hash of the last block.",
            "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
          },
          "difficulty": {
            "type": "number",
            "description": "Difficulty of the PoW algorithm.",
            "example": 0.0018856935093586335
          }
        }
      },
      "LtcBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Hash of block.",
            "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
          },
          "blockNumber": {
            "type": "number",
            "description": "The number of blocks preceding a particular block on a block chain.",
            "example": 1234314
          },
          "version": { "type": "number", "example": 536870912, "description": "Block version." },
          "prevBlock": {
            "type": "string",
            "description": "Hash of the previous block.",
            "example": "a3047a060e5d586a9b26779ebe62fc57ce7323745da8f28761ab755454d89c52"
          },
          "merkleRoot": {
            "type": "string",
            "description": "The root node of a merkle tree, a descendant of all the hashed pairs in the tree.",
            "example": "a1634a42a8e956a5fb5225d06c3af6207e7f6fe5a00fa45229edfd0ddfa587f0"
          },
          "time": { "type": "number", "description": "Time of the block.", "example": 1572865501 },
          "bits": { "type": "number", "example": 503452237 },
          "nonce": {
            "type": "number",
            "description": "Arbitrary number that is used in Litecoin's proof of work consensus algorithm.",
            "example": 2278594841
          },
          "txs": { "type": "array", "items": { "$ref": "#/components/schemas/LtcTx" } }
        }
      },
      "LtcTx": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Transaction hash.",
            "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
          },
          "witnessHash": {
            "type": "string",
            "description": "Witness hash in case of a SegWit transaction.",
            "example": "d819688a3ac77cb6d2751808e5411baf7e20fa3eeeccf65867554a09beddd9a3"
          },
          "fee": {
            "type": "string",
            "description": "Fee paid for this transaction, in LTC.",
            "example": "0.00001682"
          },
          "rate": { "type": "string", "example": "0.00010011" },
          "ps": { "type": "number", "example": 1572703011 },
          "blockNumber": {
            "type": "number",
            "description": "Height of the block this transaction belongs to.",
            "example": 1233224
          },
          "block": {
            "type": "string",
            "description": "Hash of the block this transaction belongs to.",
            "example": "b540bf37450eae0fb9fb7f190009ca890f0dd17cb19521c6241a0dc5e70f67dc"
          },
          "ts": { "type": "number", "description": "Time of the transaction.", "example": 1572694484 },
          "index": {
            "type": "number",
            "description": "Index of the transaction in the block.",
            "example": 2
          },
          "version": { "type": "number", "description": "Index of the transaction.", "example": 2 },
          "flag": { "type": "number", "example": 1 },
          "inputs": {
            "description": "List of transactions, from which assets are being sent.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "prevout": {
                  "properties": {
                    "hash": {
                      "type": "string",
                      "description": "Transaction hash of the input.",
                      "example": "0db5a2881f26f7dce20222f9c2538dc296ab562e134a72052596bdf4bb6913b4"
                    },
                    "index": {
                      "type": "number",
                      "description": "Transaction index of the input.",
                      "example": 1
                    }
                  },
                  "type": "object"
                },
                "script": {
                  "type": "string",
                  "description": "Data generated by a spender which is almost always used as variables to satisfy a pubkey script.",
                  "example": "1600148c65244f095f3689aebb70981d102e33036fe786"
                },
                "witness": {
                  "type": "string",
                  "description": "Transaction witness.",
                  "example": "0247304402202cad8f03fd061fbdd19d285f528dd7451c3818f4a1d0f5f9f559f141fb910c6e02203fb62fc770cf54ae53e4b488b589f9f096d28c1bd24dc8e4d80783dd58041826012102c44d21e840b24c786a7eff2980e35f51c4abcc9a032e7a132ca258f90ee4a19d"
                },
                "sequence": { "type": "number", "example": 4294967294 },
                "coin": {
                  "properties": {
                    "version": { "type": "number", "example": 2 },
                    "height": { "type": "number", "example": 1232869 },
                    "value": {
                      "type": "string",
                      "description": "Value of the transaction, in LTC.",
                      "example": "0.0989946"
                    },
                    "script": {
                      "type": "string",
                      "example": "a91472593295cfe5e7ea466e43822167cabcb2cb103387"
                    },
                    "address": {
                      "type": "string",
                      "description": "Sender address.",
                      "example": "2N3fqsiA5Nk4pZGWcfZApATGhXfn9B74oXK"
                    },
                    "coinbase": {
                      "type": "boolean",
                      "description": "Coinbase transaction - miner fee.",
                      "example": false
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "outputs": {
            "description": "List of recipient addresses and amounts to send to each of them.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": { "type": "string", "description": "Sent amount in LTC.", "example": "0.0015" },
                "script": {
                  "type": "string",
                  "description": "Transaction script.",
                  "example": "76a914fc8f50c952da910f473a0533561311ad140c989b88ac"
                },
                "address": {
                  "type": "string",
                  "description": "Recipient address.",
                  "example": "n4YNG8q5JyxkeWf7zMi1bMyRZbRKK1W7or"
                }
              }
            }
          },
          "locktime": {
            "type": "number",
            "description": "Block this transaction was included in.",
            "example": 1233222
          }
        }
      },
      "LtcUTXO": {
        "type": "object",
        "properties": {
          "version": { "type": "number", "description": "The version of the transaction", "example": 2 },
          "height": {
            "type": "number",
            "description": "The height (number) of the block where the transaction is included in",
            "example": 1233224
          },
          "value": { "type": "number", "description": "The amount of the UTXO", "example": 30000000 },
          "script": {
            "type": "string",
            "description": "Data generated by the spender; is almost always used as variables to satisfy the conditions in the pubkey script",
            "example": "76a914fc8f50c952da910f473a0533561311ad140c989b88ac"
          },
          "address": {
            "type": "string",
            "description": "The blockchain address of the UTXO owner",
            "example": "n4YNG8q5JyxkeWf7zMi1bMyRZbRKK1W7or"
          },
          "coinbase": {
            "type": "boolean",
            "description": "If set to \"true\", the transaction is a coinbase transaction (a transaction created by a Bitcoin miner to collect their reward)",
            "example": false
          },
          "hash": {
            "type": "string",
            "description": "The hash of the transaction",
            "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
          },
          "index": {
            "type": "number",
            "description": "The index of the transaction output checked for the UTXO",
            "example": 0
          }
        }
      },
      "LtcTransactionAddress": {
        "type": "object",
        "required": ["to", "fromAddress"],
        "properties": {
          "fromAddress": {
            "description": "The array of blockchain addresses to send the assets from and their private keys. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "privateKey"],
              "properties": {
                "address": {
                  "description": "The blockchain address to send the assets from",
                  "type": "string",
                  "minimum": 30,
                  "maximum": 50,
                  "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS"
                },
                "privateKey": {
                  "description": "The private key of the address to send the assets from",
                  "type": "string",
                  "minimum": 52,
                  "maximum": 52,
                  "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf"
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in LTC). The difference between the UTXOs calculated in the <code>fromAddress</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in LTC)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in LTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "LtcTransactionUTXO": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the private keys of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index", "privateKey"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "privateKey": {
                  "description": "The private key of the blockchain address that holds the UTXO to be spent",
                  "type": "string",
                  "example": "cVX7YtgL5muLTPncHFhP95oitV1mqUUA5VeSn8HeCRJbPqipzobf",
                  "minLength": 52,
                  "maxLength": 52
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in LTC). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in LTC)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in LTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "LtcTransactionAddressKMS": {
        "type": "object",
        "required": ["to", "fromAddress"],
        "properties": {
          "fromAddress": {
            "description": "The array of blockchain addresses to send the assets from and their signature IDs. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "signatureId"],
              "properties": {
                "address": {
                  "description": "The blockchain address to send the assets from",
                  "type": "string",
                  "minimum": 30,
                  "maximum": 50,
                  "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS"
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "The KMS identifier of the private key of the address to send the assets from"
                },
                "index": {
                  "description": "(Only if the signature ID is mnemonic-based and you run KMS v6.2 or later) The index of the address to send the assets from that was generated from the mnemonic",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in LTC). The difference between the UTXOs calculated in the <code>fromAddress</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in LTC)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in LTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee to; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "LtcTransactionUTXOKMS": {
        "type": "object",
        "required": ["to", "fromUTXO"],
        "properties": {
          "fromUTXO": {
            "description": "The array of transaction hashes, indexes of its UTXOs, and the signature IDs of the associated blockchain addresses",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index", "signatureId"],
              "properties": {
                "txHash": {
                  "description": "The transaction hash of the UTXO to be spent",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "The index of the UTXO to be spent",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "The KMS identifier of the private key of the blockchain address that holds the UTXO to be spent"
                }
              }
            }
          },
          "to": {
            "description": "The array of blockchain addresses to send the assets to and the amounts that each address should receive (in LTC). The difference between the UTXOs calculated in the <code>fromUTXO</code> section and the total amount to receive calculated in the <code>to</code> section will be used as the gas fee. To explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent, set the <code>fee</code> and <code>changeAddress</code> parameters.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "The blockchain address to receive the assets",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "The amount to receive (in LTC)",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          },
          "fee": {
            "type": "string",
            "description": "The fee to be paid for the transaction (in LTC); if you are using this parameter, you have to also use the <code>changeAddress</code> parameter because these two parameters only work together.",
            "example": "0.0015"
          },
          "changeAddress": {
            "description": "The blockchain address to send any extra assets remaning after covering the fee; if you are using this parameter, you have to also use the <code>fee</code> parameter because these two parameters only work together.",
            "type": "string",
            "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
            "minimum": 30,
            "maximum": 60
          }
        }
      },
      "AdaBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Hash of block.",
            "example": "6178dda07b94becb118f67b21aa72f60d85c1029e9e9b8ae56a25d684de66078"
          },
          "number": {
            "type": "number",
            "description": "The number of blocks preceding a particular block on a block chain.",
            "example": 1234314
          },
          "epochNo": {
            "type": "number",
            "example": 536870912,
            "description": "Number of the epoch the block is included in."
          },
          "slotNo": {
            "type": "number",
            "description": "Number of the slot the block is included in.",
            "example": "a3047a060e5d586a9b26779ebe62fc57ce7323745da8f28761ab755454d89c52"
          },
          "forgedAt": {
            "type": "string",
            "description": "Time of the block.",
            "example": "2020-10-20T08:21:50.107Z"
          },
          "transactions": { "type": "array", "items": { "$ref": "#/components/schemas/AdaTx" } }
        }
      },
      "AdaTx": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Transaction hash.",
            "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
          },
          "fee": {
            "type": "string",
            "description": "Fee paid for this transaction, in ADA.",
            "example": "0.00001682"
          },
          "block": {
            "type": "object",
            "properties": {
              "number": {
                "type": "number",
                "description": "Index of the block this transaction belongs to.",
                "example": 1233224
              },
              "hash": {
                "type": "string",
                "description": "Block hash.",
                "example": "5f83d51c8d3054012cea3011fa626b85d89442788721afd60719ab1f9ab8f78a"
              }
            }
          },
          "inputs": {
            "description": "List of transactions, from which assets are being sent.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "txHash": {
                  "type": "string",
                  "description": "Transaction hash of the input.",
                  "example": "0db5a2881f26f7dce20222f9c2538dc296ab562e134a72052596bdf4bb6913b4"
                },
                "value": {
                  "type": "string",
                  "description": "Value of the transaction, in Lovelace - 1/1000000 of ADA.",
                  "example": "989946"
                },
                "address": {
                  "type": "string",
                  "description": "Sender address.",
                  "example": "addr1qxm3vd0msv9ph8elhy7xrv975z88y6lr3d8vdgy3fwr2e22uvu2ffa2ctx3pdl4rjjja5p7al2k356x5yx8cn03am88s2807d9"
                }
              }
            }
          },
          "outputs": {
            "description": "List of recipient addresses and amounts to send to each of them.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/AdaUTXO" }
          }
        }
      },
      "AdaUTXO": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "Sent amount in Lovelace - 1/1000000 of ADA.",
            "example": "15000"
          },
          "index": {
            "type": "number",
            "description": "Index of the output in the transaction.",
            "example": 1
          },
          "txHash": {
            "type": "string",
            "description": "Transaction hash.",
            "example": "76a914fc8f50c952da910f473a0533561311ad140c989b88ac"
          },
          "address": {
            "type": "string",
            "description": "Recipient address.",
            "example": "addr1qxm3vd0msv9ph8elhy7xrv975z88y6lr3d8vdgy3fwr2e22uvu2ffa2ctx3pdl4rjjja5p7al2k356x5yx8cn03am88s2807d9"
          }
        }
      },
      "AdaAccountBalance": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "currency": {
              "type": "object",
              "properties": {
                "symbol": { "type": "string", "description": "Name of the asset." },
                "decimals": { "type": "number", "description": "Number of decimal places." }
              }
            },
            "value": { "type": "string", "description": "Quantity of the asset." }
          }
        }
      },
      "AdaTransaction": {
        "type": "object",
        "required": ["to"],
        "properties": {
          "fromAddress": {
            "description": "Array of addresses and corresponding private keys. Tatum will automatically scan last unspent transactions for each address and will use all of the unspent values. We advise to use this option if you have 1 address per 1 transaction only.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address"],
              "properties": {
                "address": {
                  "description": "Address to send assets from.",
                  "type": "string",
                  "minimum": 30,
                  "maximum": 150,
                  "example": "addr1qxm3vd0msv9ph8elhy7xrv975z88y6lr3d8vdgy3fwr2e22uvu2ffa2ctx3pdl4rjjja5p7al2k356x5yx8cn03am88s2807d9"
                },
                "privateKey": {
                  "description": "Private key of the address to send assets from. Private key, or signature Id must be present.",
                  "type": "string",
                  "minimum": 192,
                  "maximum": 192,
                  "example": "7808a501e1bbc9926ac8ac6981e47cb0401288ae331a1f2333d1bed46c5b3051b5f875c39477b05bc3a43a3800b763f616ae3646f21df0ab5d95db944e71f5cfa8082d5c4e6241d49b17b2b6173f01bb3fd03be012cc8908ceea9e559e33e4fc"
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
                }
              }
            }
          },
          "fromUTXO": {
            "description": "Array of transaction hashes, index of UTXO in it and corresponding private keys. Use this option if you want to calculate amount to send manually. Either fromUTXO or fromAddress must be present.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index"],
              "properties": {
                "txHash": {
                  "description": "Transaction hash of the UTXO to be spent.",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "Index of the UTXO to be spent.",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                },
                "privateKey": {
                  "description": "Private key of the UTXO to be spent. Private key, or signature Id must be present.",
                  "type": "string",
                  "example": "7808a501e1bbc9926ac8ac6981e47cb0401288ae331a1f2333d1bed46c5b3051b5f875c39477b05bc3a43a3800b763f616ae3646f21df0ab5d95db944e71f5cfa8082d5c4e6241d49b17b2b6173f01bb3fd03be012cc8908ceea9e559e33e4fc",
                  "minLength": 192,
                  "maxLength": 192
                },
                "signatureId": {
                  "type": "string",
                  "format": "uuid",
                  "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
                  "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
                }
              }
            }
          },
          "to": {
            "description": "Array of addresses and values to send Litecoins to. Values must be set in LTC. Difference between from and to is transaction fee.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "Destination address.",
                  "type": "string",
                  "example": "addr1qxm3vd0msv9ph8elhy7xrv975z88y6lr3d8vdgy3fwr2e22uvu2ffa2ctx3pdl4rjjja5p7al2k356x5yx8cn03am88s2807d9",
                  "minimum": 30,
                  "maximum": 150
                },
                "value": {
                  "description": "Amount to be sent, in ADA.",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.029609
                }
              }
            }
          }
        }
      },
      "AdaInfo": {
        "type": "object",
        "properties": {
          "testnet": {
            "type": "string",
            "description": "Chain of the blockchain, main or test.",
            "example": "test"
          },
          "tip": {
            "type": "object",
            "properties": {
              "number": { "type": "number", "description": "Last block.", "example": 2749845 },
              "slotNo": { "type": "number", "description": "Last slot number.", "example": 31798572 },
              "epoch": {
                "type": "object",
                "properties": {
                  "number": { "type": "number", "description": "Last epoch number.", "example": 143 }
                }
              }
            }
          }
        }
      },
      "Blockage": {
        "properties": {
          "id": {
            "description": "ID of the blockage.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "accountId": {
            "description": "ID of the account this blockage is for.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "amount": { "description": "Amount blocked on account.", "example": "5", "type": "string" },
          "type": { "description": "Type of blockage.", "type": "string", "example": "DEBIT_CARD_OP" },
          "description": {
            "description": "Description of blockage.",
            "type": "string",
            "example": "Card payment in the shop."
          }
        }
      },
      "BlockAmount": {
        "properties": {
          "amount": {
            "description": "Amount to be blocked on account.",
            "maxLength": 38,
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "example": "5",
            "type": "string"
          },
          "type": {
            "description": "Type of blockage.",
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "example": "DEBIT_CARD_OP"
          },
          "description": {
            "description": "Description of blockage.",
            "type": "string",
            "minLength": 1,
            "maxLength": 300,
            "example": "Card payment in the shop."
          }
        },
        "required": ["amount", "type"],
        "type": "object"
      },
      "BroadcastKMS": {
        "properties": {
          "txData": {
            "description": "Raw signed transaction to be published to network.",
            "example": "62BD544D1B9031EFC330A3E855CC3A0D51CA5131455C1AB3BCAC6D243F65460D",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "description": "ID of prepared payment template to sign. Required only, when broadcasting transaction signed by Tatum KMS.",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "required": ["txData"],
        "type": "object"
      },
      "HmacWebHook": {
        "properties": {
          "hmacSecret": {
            "description": "Your HMAC secret password, which is used for signing the webhook payload.",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string",
            "maxLength": 100
          }
        },
        "required": ["hmacSecret"],
        "type": "object"
      },
      "Broadcast": {
        "properties": {
          "txData": {
            "description": "Raw signed transaction to be published to network.",
            "example": "62BD544D1B9031EFC330A3E855CC3A0D51CA5131455C1AB3BCAC6D243F65460D",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "minLength": 24,
            "maxLength": 24,
            "example": "5e68c66581f2ee32bc354087",
            "description": "Identifier of KMS pending transaction ID to be completed with the broadcast."
          }
        },
        "required": ["txData"],
        "type": "object"
      },
      "BroadcastResponse": {
        "properties": {
          "completed": {
            "description": "Flag, if withdrawal is successfully completed within Tatum systems.",
            "example": true,
            "type": "boolean"
          },
          "txId": {
            "description": "Transaction ID of broadcast transaction and status",
            "example": "62BD544D1B9031EFC330A3E855CC3A0D51CA5131455C1AB3BCAC6D243F65460D",
            "type": "string"
          }
        },
        "type": "object"
      },
      "BroadcastWithdrawal": {
        "properties": {
          "currency": {
            "description": "Currency of signed transaction to be broadcast, BTC, LTC, DOGE, BNB, XLM, TRX, BCH, ETH, XRP, ERC20, TRC20",
            "example": "BTC",
            "maxLength": 40,
            "minLength": 2,
            "type": "string"
          },
          "txData": {
            "description": "Raw signed transaction to be published to network.",
            "example": "62BD544D1B9031EFC330A3E855CC3A0D51CA5131455C1AB3BCAC6D243F65460D",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "withdrawalId": {
            "description": "Withdrawal ID to be completed by transaction broadcast",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "signatureId": {
            "description": "ID of prepared payment template to sign. This is should be stored on a client side to retrieve ID of the blockchain transaction, when signing application signs the transaction and broadcasts it to the blockchain.",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "required": ["txData", "currency"],
        "type": "object"
      },
      "Id": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID of the entity.",
            "example": "5e68c66581f2ee32bc354087"
          }
        }
      },
      "CreateAccountBatch": {
        "type": "object",
        "properties": {
          "accounts": { "type": "array", "items": { "$ref": "#/components/schemas/CreateAccount" } }
        },
        "required": ["accounts"]
      },
      "CreateAccount": {
        "properties": {
          "currency": {
            "description": "Account currency. Supported values are BTC, BNB, LTC, DOGE, BCH, ETH, XLM, XRP, TRON, BSC, SOL, MATIC, ALGO, KCS, EGLD, CELO, KLAY, XDC, FLOW, Tatum virtual currencies started with the \"VC_\" prefix (this includes fiat currencies), USDT, WBTC, LEO, LINK, GMC, UNI, FREE, MKR, USDC, BAT, TUSD, BUSD, PAX, PAXG, MMY, XCON, USDT_TRON, BETH, BUSD, BBTC, BADA, WBNB, BDOT, BXRP, BLTC, BBCH, CAKE, BUSD_BSC, ERC-20, BEP-20 or TRC-10/20 custom tokens registered on the Tatum platform, XLM or XRP assets created via the Tatum platform. ERC-20 tokens and BEP-20 tokens do not have testnet blockchains, therefore you cannot use them in a non-production environment. You can emulate a testnet environment by <a href=\"https://apidoc.tatum.io/tag/Blockchain-operations#operation/registerErc20Token\" target=\"_blank\">registering a custom ERC-20 or BEP-20 token</a> on the Tatum  platform and then minting some tokens from the token's address using the <a href=\"https://erc20faucet.com/\" target=\"_blank\">Ethereum ERC-20 Token Faucet</a>.\n",
            "example": "BTC",
            "maxLength": 40,
            "minLength": 2,
            "type": "string"
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "compliant": {
            "description": "Enable compliant checks. If this is enabled, it is impossible to create account if compliant check fails.",
            "example": false,
            "type": "boolean"
          },
          "accountCode": {
            "description": "For bookkeeping to distinct account purpose.",
            "maxLength": 50,
            "minLength": 1,
            "example": "AC_1011_B",
            "type": "string"
          },
          "accountingCurrency": {
            "description": "All transaction will be accounted in this currency for all accounts. Currency can be overridden per account level. If not set, customer accountingCurrency is used or EUR by default. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "accountNumber": {
            "description": "Account number from external system.",
            "maxLength": 50,
            "minLength": 1,
            "example": "123456",
            "type": "string"
          }
        },
        "required": ["currency"],
        "type": "object"
      },
      "CreateAccountXpub": {
        "properties": {
          "currency": {
            "description": "Account currency. Supported values are BTC, BNB, LTC, DOGE, BCH, ETH, XLM, XRP, TRON, BSC, SOL, MATIC, ALGO, KCS, EGLD, CELO, KLAY, XDC, FLOW, Tatum virtual currencies started with the \"VC_\" prefix (this includes fiat currencies), USDT, WBTC, LEO, LINK, GMC, UNI, FREE, MKR, USDC, BAT, TUSD, BUSD, PAX, PAXG, MMY, XCON, USDT_TRON, BETH, BUSD, BBTC, BADA, WBNB, BDOT, BXRP, BLTC, BBCH, CAKE, BUSD_BSC, ERC-20, BEP-20 or TRC-10/20 custom tokens registered on the Tatum platform, XLM or XRP assets created via the Tatum platform. ERC-20 tokens and BEP-20 tokens do not have testnet blockchains, therefore you cannot use them in a non-production environment. You can emulate a testnet environment by <a href=\"https://apidoc.tatum.io/tag/Blockchain-operations#operation/registerErc20Token\" target=\"_blank\">registering a custom ERC-20 or BEP-20 token</a> on the Tatum  platform and then minting some tokens from the token's address using the <a href=\"https://erc20faucet.com/\" target=\"_blank\">Ethereum ERC-20 Token Faucet</a>.\n",
            "example": "BTC",
            "maxLength": 40,
            "minLength": 2,
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key to generate addresses from.",
            "maxLength": 192,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "compliant": {
            "description": "Enable compliant checks. If this is enabled, it is impossible to create account if compliant check fails.",
            "example": false,
            "type": "boolean"
          },
          "accountCode": {
            "description": "For bookkeeping to distinct account purpose.",
            "maxLength": 50,
            "minLength": 1,
            "example": "AC_1011_B",
            "type": "string"
          },
          "accountingCurrency": {
            "description": "All transaction will be accounted in this currency for all accounts. Currency can be overridden per account level. If not set, customer accountingCurrency is used or EUR by default. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "accountNumber": {
            "description": "Account number from external system.",
            "maxLength": 50,
            "minLength": 1,
            "example": "123456",
            "type": "string"
          }
        },
        "required": ["currency", "xpub"],
        "type": "object"
      },
      "UpdateAccount": {
        "properties": {
          "accountCode": {
            "description": "For bookkeeping to distinct account purpose.",
            "maxLength": 50,
            "minLength": 1,
            "example": "AC_1011_B",
            "type": "string"
          },
          "accountNumber": {
            "description": "Account number from external system.",
            "maxLength": 50,
            "minLength": 1,
            "example": "123456",
            "type": "string"
          }
        },
        "type": "object"
      },
      "CreateTransaction": {
        "properties": {
          "senderAccountId": {
            "description": "Internal sender account ID within Tatum platform",
            "example": "5e6645712b55823de7ea82f1",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "recipientAccountId": {
            "description": "Internal recipient account ID within Tatum platform",
            "example": "5e6645712b55823de7ea82f2",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "anonymous": {
            "default": false,
            "description": "Anonymous transaction does not show sender account to recipient, default is false",
            "example": false,
            "type": "boolean"
          },
          "compliant": {
            "description": "Enable compliant checks. Transaction will not be processed, if compliant check fails.",
            "example": false,
            "type": "boolean"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Payment ID, External identifier of the payment, which can be used to pair transactions within Tatum accounts.",
            "example": "9625",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "recipientNote": {
            "description": "Note visible to both, sender and recipient",
            "example": "Private note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Only applicable for Tatum's Virtual currencies Ledger transactions. Override default exchange rate for the Virtual Currency."
          },
          "senderNote": {
            "description": "Note visible to sender",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "recipientAccountId", "senderAccountId"],
        "type": "object"
      },
      "BatchCreateTransaction": {
        "properties": {
          "senderAccountId": {
            "description": "Internal sender account ID within Tatum platform",
            "example": "5e6645712b55823de7ea82f1",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "transaction": {
            "description": "Array of block seals.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["amount", "recipientAccountId"],
              "properties": {
                "recipientAccountId": {
                  "description": "Internal recipient account ID within Tatum platform",
                  "example": "5e6645712b55823de7ea82f2",
                  "maxLength": 24,
                  "minLength": 24,
                  "type": "string"
                },
                "amount": {
                  "description": "Amount to be sent.",
                  "maxLength": 38,
                  "example": "5",
                  "type": "string",
                  "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
                },
                "anonymous": {
                  "default": false,
                  "description": "Anonymous transaction does not show sender account to recipient, default is false",
                  "example": false,
                  "type": "boolean"
                },
                "compliant": {
                  "description": "Enable compliant checks. Transaction will not be processed, if compliant check fails.",
                  "example": false,
                  "type": "boolean"
                },
                "transactionCode": {
                  "description": "For bookkeeping to distinct transaction purpose.",
                  "example": "1_01_EXTERNAL_CODE",
                  "maxLength": 100,
                  "minLength": 1,
                  "type": "string"
                },
                "paymentId": {
                  "description": "Payment ID, External identifier of the payment, which can be used to pair transactions within Tatum accounts.",
                  "example": "9625",
                  "maxLength": 100,
                  "minLength": 1,
                  "type": "string"
                },
                "recipientNote": {
                  "description": "Note visible to both, sender and recipient",
                  "example": "Private note",
                  "maxLength": 500,
                  "minLength": 1,
                  "type": "string"
                },
                "baseRate": {
                  "type": "number",
                  "example": 1,
                  "default": 1,
                  "minimum": 0,
                  "description": "Exchange rate of the base pair. Only applicable for Tatum's Virtual currencies Ledger transactions. Override default exchange rate for the Virtual Currency."
                },
                "senderNote": {
                  "description": "Note visible to sender",
                  "example": "Sender note",
                  "maxLength": 500,
                  "minLength": 1,
                  "type": "string"
                }
              }
            }
          }
        },
        "required": ["senderAccountId"],
        "type": "object"
      },
      "UnblockAmount": {
        "properties": {
          "recipientAccountId": {
            "description": "Internal recipient account ID within Tatum platform",
            "example": "5e6645712b55823de7ea82f2",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent. Amount can be smaller then the blocked amount.",
            "maxLength": 38,
            "example": "5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "anonymous": {
            "default": false,
            "description": "Anonymous transaction does not show sender account to recipient, default is false",
            "example": false,
            "type": "boolean"
          },
          "compliant": {
            "description": "Enable compliant checks. Transaction will not be processed, if compliant check fails.",
            "example": false,
            "type": "boolean"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Payment ID, External identifier of the payment, which can be used to pair transactions within Tatum accounts.",
            "example": "9625",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "recipientNote": {
            "description": "Note visible to both, sender and recipient",
            "example": "Private note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Only applicable for Tatum's Virtual currencies Ledger transactions. Override default exchange rate for the Virtual Currency."
          },
          "senderNote": {
            "description": "Note visible to sender",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "recipientAccountId"],
        "type": "object"
      },
      "Customer": {
        "required": ["active", "id", "externalId", "enabled"],
        "properties": {
          "externalId": { "description": "Customer external ID.", "example": "651234", "type": "string" },
          "id": {
            "description": "Customer internal ID within Tatum.",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "enabled": {
            "description": "Indicates whether customer is enabled or not",
            "example": true,
            "type": "boolean"
          },
          "active": {
            "description": "Indicates whether customer is active or not",
            "example": true,
            "type": "boolean"
          },
          "accountingCurrency": {
            "description": "All transaction will be accounted in this currency for all accounts of the customer. Currency can be overridden per account level. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "type": "string"
          },
          "customerCountry": {
            "description": "Country customer has to be compliant with",
            "example": "US",
            "type": "string"
          },
          "providerCountry": {
            "description": "Country service provider has to be compliant with",
            "example": "US",
            "type": "string"
          }
        },
        "type": "object"
      },
      "CustomerRegistration": {
        "properties": {
          "accountingCurrency": {
            "description": "All transaction will be accounted in this currency for all accounts. Currency can be overridden per account level. If not set, EUR is used. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "customerCountry": {
            "description": "Country customer has to be compliant with. ISO-3166-1",
            "example": "US",
            "maxLength": 2,
            "minLength": 2,
            "type": "string"
          },
          "externalId": {
            "description": "Customer external ID. Use only anonymized identification you have in your system. If customer with externalId does not exists new customer is created. If customer with specified externalId already exists it is updated.",
            "example": "123654",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "providerCountry": {
            "description": "Country service provider has to be compliant with. ISO-3166-1",
            "example": "US",
            "maxLength": 2,
            "minLength": 2,
            "type": "string"
          }
        },
        "required": ["externalId"],
        "type": "object",
        "description": "If customer is filled then is created or updated."
      },
      "CustomerUpdate": {
        "properties": {
          "externalId": {
            "description": "External customer ID. If not set, it will not be updated.",
            "example": "123654",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "accountingCurrency": {
            "description": "All transaction will be accounted in this currency for all accounts. Currency can be overridden per account level. If not set, it will not be updated. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "customerCountry": {
            "description": "Country customer has to be compliant with. If not set, it will not be updated. ISO-3166-1.",
            "enum": [
              "AD",
              "AE",
              "AF",
              "AG",
              "AI",
              "AL",
              "AM",
              "AO",
              "AR",
              "AS",
              "AT",
              "AU",
              "AW",
              "AX",
              "AZ",
              "BA",
              "BB",
              "BD",
              "BE",
              "BF",
              "BG",
              "BH",
              "BI",
              "BJ",
              "BL",
              "BM",
              "BN",
              "BO",
              "BQ",
              "BR",
              "BS",
              "BT",
              "BV",
              "BW",
              "BY",
              "BZ",
              "CA",
              "CC",
              "CD",
              "CF",
              "CG",
              "CH",
              "CI",
              "CK",
              "CL",
              "CM",
              "CN",
              "CO",
              "CR",
              "CU",
              "CV",
              "CW",
              "CX",
              "CY",
              "CZ",
              "DE",
              "DJ",
              "DK",
              "DM",
              "DO",
              "DZ",
              "EC",
              "EE",
              "EG",
              "EH",
              "ER",
              "ES",
              "ET",
              "FI",
              "FJ",
              "FK",
              "FM",
              "FO",
              "FR",
              "GA",
              "GB",
              "GD",
              "GE",
              "GF",
              "GG",
              "GH",
              "GI",
              "GL",
              "GM",
              "GN",
              "GP",
              "GQ",
              "GR",
              "GS",
              "GT",
              "GU",
              "GW",
              "GY",
              "HK",
              "HM",
              "HN",
              "HR",
              "HT",
              "HU",
              "ID",
              "IE",
              "IL",
              "IM",
              "IN",
              "IO",
              "IQ",
              "IR",
              "IS",
              "IT",
              "JE",
              "JM",
              "JO",
              "JP",
              "KE",
              "KG",
              "KH",
              "KI",
              "KM",
              "KN",
              "KP",
              "KR",
              "KW",
              "KY",
              "KZ",
              "LA",
              "LB",
              "LC",
              "LI",
              "LK",
              "LR",
              "LS",
              "LT",
              "LU",
              "LV",
              "LY",
              "MA",
              "MC",
              "MD",
              "ME",
              "MF",
              "MG",
              "MH",
              "MK",
              "ML",
              "MM",
              "MN",
              "MO",
              "MP",
              "MQ",
              "MR",
              "MS",
              "MT",
              "MU",
              "MV",
              "MW",
              "MX",
              "MY",
              "MZ",
              "NA",
              "NC",
              "NE",
              "NF",
              "NG",
              "NI",
              "NL",
              "NO",
              "NP",
              "NR",
              "NU",
              "NZ",
              "OM",
              "PA",
              "PE",
              "PF",
              "PG",
              "PH",
              "PK",
              "PL",
              "PM",
              "PN",
              "PR",
              "PS",
              "PT",
              "PW",
              "PY",
              "QA",
              "RE",
              "RO",
              "RS",
              "RU",
              "RW",
              "SA",
              "SB",
              "SC",
              "SD",
              "SE",
              "SG",
              "SH",
              "SI",
              "SJ",
              "SK",
              "SL",
              "SM",
              "SN",
              "SO",
              "SR",
              "SS",
              "ST",
              "SV",
              "SX",
              "SY",
              "SZ",
              "TC",
              "TD",
              "TF",
              "TG",
              "TH",
              "TJ",
              "TK",
              "TL",
              "TM",
              "TN",
              "TO",
              "TR",
              "TT",
              "TV",
              "TW",
              "TZ",
              "UA",
              "UG",
              "UM",
              "US",
              "UY",
              "UZ",
              "VA",
              "VC",
              "VE",
              "VG",
              "VI",
              "VN",
              "VU",
              "WF",
              "WS",
              "YE",
              "YT",
              "ZA",
              "ZM",
              "ZW"
            ],
            "example": "US",
            "maxLength": 2,
            "minLength": 2,
            "type": "string"
          },
          "providerCountry": {
            "description": "Country service provider has to be compliant with. If not set, it will not be updated. ISO-3166-1",
            "enum": [
              "AD",
              "AE",
              "AF",
              "AG",
              "AI",
              "AL",
              "AM",
              "AO",
              "AR",
              "AS",
              "AT",
              "AU",
              "AW",
              "AX",
              "AZ",
              "BA",
              "BB",
              "BD",
              "BE",
              "BF",
              "BG",
              "BH",
              "BI",
              "BJ",
              "BL",
              "BM",
              "BN",
              "BO",
              "BQ",
              "BR",
              "BS",
              "BT",
              "BV",
              "BW",
              "BY",
              "BZ",
              "CA",
              "CC",
              "CD",
              "CF",
              "CG",
              "CH",
              "CI",
              "CK",
              "CL",
              "CM",
              "CN",
              "CO",
              "CR",
              "CU",
              "CV",
              "CW",
              "CX",
              "CY",
              "CZ",
              "DE",
              "DJ",
              "DK",
              "DM",
              "DO",
              "DZ",
              "EC",
              "EE",
              "EG",
              "EH",
              "ER",
              "ES",
              "ET",
              "FI",
              "FJ",
              "FK",
              "FM",
              "FO",
              "FR",
              "GA",
              "GB",
              "GD",
              "GE",
              "GF",
              "GG",
              "GH",
              "GI",
              "GL",
              "GM",
              "GN",
              "GP",
              "GQ",
              "GR",
              "GS",
              "GT",
              "GU",
              "GW",
              "GY",
              "HK",
              "HM",
              "HN",
              "HR",
              "HT",
              "HU",
              "ID",
              "IE",
              "IL",
              "IM",
              "IN",
              "IO",
              "IQ",
              "IR",
              "IS",
              "IT",
              "JE",
              "JM",
              "JO",
              "JP",
              "KE",
              "KG",
              "KH",
              "KI",
              "KM",
              "KN",
              "KP",
              "KR",
              "KW",
              "KY",
              "KZ",
              "LA",
              "LB",
              "LC",
              "LI",
              "LK",
              "LR",
              "LS",
              "LT",
              "LU",
              "LV",
              "LY",
              "MA",
              "MC",
              "MD",
              "ME",
              "MF",
              "MG",
              "MH",
              "MK",
              "ML",
              "MM",
              "MN",
              "MO",
              "MP",
              "MQ",
              "MR",
              "MS",
              "MT",
              "MU",
              "MV",
              "MW",
              "MX",
              "MY",
              "MZ",
              "NA",
              "NC",
              "NE",
              "NF",
              "NG",
              "NI",
              "NL",
              "NO",
              "NP",
              "NR",
              "NU",
              "NZ",
              "OM",
              "PA",
              "PE",
              "PF",
              "PG",
              "PH",
              "PK",
              "PL",
              "PM",
              "PN",
              "PR",
              "PS",
              "PT",
              "PW",
              "PY",
              "QA",
              "RE",
              "RO",
              "RS",
              "RU",
              "RW",
              "SA",
              "SB",
              "SC",
              "SD",
              "SE",
              "SG",
              "SH",
              "SI",
              "SJ",
              "SK",
              "SL",
              "SM",
              "SN",
              "SO",
              "SR",
              "SS",
              "ST",
              "SV",
              "SX",
              "SY",
              "SZ",
              "TC",
              "TD",
              "TF",
              "TG",
              "TH",
              "TJ",
              "TK",
              "TL",
              "TM",
              "TN",
              "TO",
              "TR",
              "TT",
              "TV",
              "TW",
              "TZ",
              "UA",
              "UG",
              "UM",
              "US",
              "UY",
              "UZ",
              "VA",
              "VC",
              "VE",
              "VG",
              "VI",
              "VN",
              "VU",
              "WF",
              "WS",
              "YE",
              "YT",
              "ZA",
              "ZM",
              "ZW"
            ],
            "example": "US",
            "maxLength": 2,
            "minLength": 2,
            "type": "string"
          }
        },
        "type": "object",
        "required": ["externalId"]
      },
      "DeployErc20OffchainMnemXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of ERC20, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "derivation index of address to pay for deployment of ERC20",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "basePair",
          "xpub",
          "derivationIndex",
          "mnemonic",
          "index"
        ]
      },
      "DeployErc20OffchainMnemonicAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of ERC20, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "derivation index of address to pay for deployment of ERC20",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "address", "mnemonic", "index"]
      },
      "DeployErc20OffchainPKXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "privateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC20 will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "xpub", "derivationIndex", "privateKey"]
      },
      "DeployErc20OffchainPKAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "privateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC20 will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "privateKey", "address"]
      },
      "DeployErc20OffchainKMSAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "address", "signatureId"]
      },
      "DeployErc20OffchainKMSXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "xpub", "derivationIndex", "signatureId"]
      },
      "DeployKCSErc20OffchainMnemXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of ERC20, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "derivation index of address to pay for deployment of ERC20",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "basePair",
          "xpub",
          "derivationIndex",
          "mnemonic",
          "index"
        ]
      },
      "DeployKCSErc20OffchainMnemonicAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of ERC20, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "derivation index of address to pay for deployment of ERC20",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "address", "mnemonic", "index"]
      },
      "DeployKCSErc20OffchainPKXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "privateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC20 will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "xpub", "derivationIndex", "privateKey"]
      },
      "DeployKCSErc20OffchainPKAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "privateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC20 will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "privateKey", "address"]
      },
      "DeployKCSErc20OffchainKMSAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "address", "signatureId"]
      },
      "DeployKCSErc20OffchainKMSXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "nonce": {
            "type": "number",
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used.",
            "minimum": 0
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "xpub", "derivationIndex", "signatureId"]
      },
      "DeployAlgoErc20OffchainMnemonicAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 58,
            "minLength": 58,
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of ERC20, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "artist alarm clerk obscure timber firm reopen provide ankle vicious exhibit waste math toilet believe puppy lucky coast post kind black suspect mule able market",
            "type": "string"
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "address", "mnemonic"]
      },
      "DeployAlgoErc20OffchainPKAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 58,
            "minLength": 58,
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "privateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC20 will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 103,
            "minLength": 103,
            "example": "NBYMCVEEDFYV3TPWVRE6APE7PKHUJD4XAKXCKNCLKGUXOC3LFNJGZQCJCRA53HB7ZAHF6NFJH2QIVQ5USQNWG35QCJLD4KZ5IWMB24Q"
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "privateKey", "address"]
      },
      "DeployAlgoErc20OffchainKMSAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the ERC20 token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "description": {
            "description": "Description of the ERC20 token",
            "example": "My ERC20 Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20 token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Ethereum blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 58,
            "minLength": 58,
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          }
        },
        "required": ["description", "supply", "symbol", "basePair", "address", "signatureId"]
      },
      "TransferAlgoErc20": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "The ID of the virtual account to send the ERC-20-equivalent Algorand tokens from",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "address": {
            "description": "The blockchain address to send the ERC-20-equivalent Algorand tokens to",
            "example": "5YVZBUH3STSQ5ABCTLEIEIJ7QOZFILM2DLAEEA4ZL6CU55ODZIQXO5EMYM",
            "maxLength": 58,
            "minLength": 58,
            "type": "string"
          },
          "amount": {
            "description": "The amount of the ERC-20-equivalent Algorand tokens to send",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "privateKey": {
            "maxLength": 103,
            "minLength": 103,
            "description": "The secret of the Algorand wallet (account). Secret, or signature Id must be present.",
            "example": "NBYMCVEEDFYV3TPWVRE6APE7PKHUJD4XAKXCKNCLKGUXOC3LFNJGZQCJCRA53HB7ZAHF6NFJH2QIVQ5USQNWG35QCJLD4KZ5IWMB24Q",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check; if the withdrawal is not compliant, it will not be processed",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "The identifier of the token transfer that is shown on the virtual account for the created transaction",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "The note for the recipient; must not contain spaces",
            "example": "Helloworld",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "privateKey", "amount", "fee"]
      },
      "DeployTrcOffchainMnemXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the TRC token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of TRC token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Description of the TRC token",
            "example": "My TRC Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 130,
            "minLength": 130,
            "example": "0244b3f40c6e570ae0032f6d7be87737a6c4e5314a4a1a82e22d0460a0d0cd794936c61f0c80dc74ace4cd04690d4eeb1aa6555883be006e1748306faa7ed3a26a",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of TRC, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "derivation index of address to pay for deployment of TRC",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "basePair",
          "decimals",
          "type",
          "xpub",
          "derivationIndex",
          "mnemonic",
          "index"
        ]
      },
      "DeployTrcOffchainMnemonicAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the TRC token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of TRC token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Description of the TRC token",
            "example": "My TRC Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Tron blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 34,
            "minLength": 34,
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for the deploy account of TRC, from which the gas will be paid (index will be used). If address is not present, mnemonic is used to generate xpub and index is set to 1. Either mnemonic and index or privateKey and address must be present, not both.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "derivation index of address to pay for deployment of TRC",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "decimals",
          "type",
          "basePair",
          "address",
          "mnemonic",
          "index"
        ]
      },
      "DeployTrcOffchainPKXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the TRC token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of TRC token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Description of the TRC token",
            "example": "My TRC Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "0244b3f40c6e570ae0032f6d7be87737a6c4e5314a4a1a82e22d0460a0d0cd794936c61f0c80dc74ace4cd04690d4eeb1aa6555883be006e1748306faa7ed3a26a",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "privateKey": {
            "description": "Private key of Tron account address, from which gas for deployment of TRC will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "e75d702ce00987633f8009fbb1eabb5b187cb5b50fe9179a8d6cee6bab076b66"
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "basePair",
          "decimals",
          "type",
          "xpub",
          "derivationIndex",
          "privateKey"
        ]
      },
      "DeployTrcOffchainPKAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the TRC token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of TRC token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Description of the TRC token",
            "example": "My TRC Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Tron blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "type": "string"
          },
          "privateKey": {
            "description": "Private key of Tron account address, from which gas for deployment of TRC will be paid. Private key, mnemonic or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0244b3f40c6e570ae0032f6d7be87737a6c4e5314a4a1a82e22d0460a0d0cd794936c61f0c80dc74ace4cd04690d4eeb1aa6555883be006e1748306faa7ed3a26a"
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "decimals",
          "type",
          "basePair",
          "privateKey",
          "address"
        ]
      },
      "DeployTrcOffchainKMSAddress": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the TRC token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of TRC token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Description of the TRC token",
            "example": "My TRC Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "address": {
            "description": "Address on Tron blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 42,
            "minLength": 42,
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "type": "string"
          },
          "from": {
            "description": "Blockchain address to perform operation from",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "maxLength": 34,
            "minLength": 34,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "from",
          "decimals",
          "type",
          "basePair",
          "address",
          "signatureId"
        ]
      },
      "DeployTrcOffchainKMSXpub": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Name of the TRC token - stored as a symbol on Blockchain",
            "example": "MT",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "max supply of TRC token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Description of the TRC token",
            "example": "My TRC Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. 1 token will be equal to 1 unit of base pair. Transaction value will be calculated according to this base pair.",
            "maxLength": 30,
            "minLength": 2,
            "type": "string",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "0244b3f40c6e570ae0032f6d7be87737a6c4e5314a4a1a82e22d0460a0d0cd794936c61f0c80dc74ace4cd04690d4eeb1aa6555883be006e1748306faa7ed3a26a",
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "from": {
            "description": "Blockchain address to perform operation from",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "maxLength": 34,
            "minLength": 34,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          }
        },
        "required": [
          "description",
          "supply",
          "symbol",
          "from",
          "decimals",
          "type",
          "basePair",
          "xpub",
          "derivationIndex",
          "signatureId"
        ]
      },
      "DeployErc20": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on XDC blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "xdca0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of XDC account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "symbol", "address", "supply", "fromPrivateKey", "digits"]
      },
      "DeployErc20KMS": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on XDC blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "xdca0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "symbol", "address", "supply", "signatureId", "digits"]
      },
      "DeployErc721": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the ERC721 token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the ERC721 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "symbol", "fromPrivateKey"]
      },
      "DeployErc721KMS": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the ERC721 token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the ERC721 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "symbol", "signatureId"]
      },
      "EthBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/EthTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "FlowBlock": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Hash of the block.",
            "type": "string",
            "example": "e11ca8f92f2d5dea7406e64ab8cb1780a8a19185d9ac670b16ca8c4f09f05add"
          },
          "parentId": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "7bd701e87f319254d19dc17459f97df6a44052d05df5e1cd442dd2e3f48ecedc"
          },
          "height": { "description": "The block number.", "type": "number", "example": 31733102 },
          "timestamp": {
            "description": "Timestamp of the block.",
            "type": "string",
            "example": "2021-05-11T19:13:03.227Z"
          },
          "transactions": {
            "description": "Array of transaction IDs.",
            "type": "array",
            "items": {
              "type": "string",
              "example": "3b4351560d3b454a4c1ae2485074b0786093058bfe2b28d436584311b1e433a4"
            }
          },
          "signatures": {
            "description": "Array of signatures.",
            "type": "array",
            "items": {
              "type": "string",
              "example": "b5ffad6c227cc8dbcb3043dfaa50e8ea5093459ee30242379e6e65e982db84c22faa1da70792349219f3620de95ea16aa8a490000ae824a0002abd60d80b54dc0b42ceab5e98339ec22464f5abb794465357f780f8143f2df077b8f2af69ecd2"
            }
          },
          "blockSeals": {
            "description": "Array of block seals.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "blockId": {
                  "type": "string",
                  "example": "c85bc2853ca9596a80050b6d2661aad10bd6b27d06b013050076ad1bed2c8b6a"
                },
                "executionReceiptSignatures": { "type": "array", "items": { "type": "string" } },
                "executionReceiptId": {
                  "type": "string",
                  "example": "e79acd6437efe49c22832802346908f9590b92fbcd452f72e3b2f1151c48f3ea"
                },
                "resultApprovalSignatures": { "type": "array", "items": { "type": "string" } }
              }
            }
          }
        }
      },
      "FlowAccount": {
        "type": "object",
        "properties": {
          "address": { "description": "Account address.", "type": "string", "example": "0x02fcc83938d2b63b" },
          "balance": {
            "description": "Balance of the account in smallest FLOW unit = 1 FLOW = 1e8 unit",
            "type": "number",
            "example": 10000000
          },
          "code": { "description": "Account code", "type": "string" },
          "contracts": { "type": "object" },
          "keys": {
            "description": "Array of public keys assigned.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "index": { "description": "Index of the public key.", "type": "number", "example": 0 },
                "publicKey": {
                  "type": "string",
                  "example": "ba38c835921828e11264e35fe31cc5ad90149f803fd3106e1dd1df49567a05714ed2bf5e42d58b4fef7eb9b0f7121f446d9b607216fdf04459e007b053288287"
                },
                "signAlgo": {
                  "description": "Type of signature algorithm. 2 - ECDSA_secp256k1",
                  "type": "number",
                  "example": 2
                },
                "hashAlgo": {
                  "description": "Type of hash algo. 3 - SHA3_256",
                  "type": "number",
                  "example": 3
                },
                "sequenceNumber": {
                  "description": "Number of outgoing transactions for this public key.",
                  "type": "number",
                  "example": 1
                },
                "revoked": { "type": "boolean", "example": false },
                "weight": {
                  "description": "Weight of the key. 1000 means single signature necessary.",
                  "type": "number",
                  "example": 1000
                }
              }
            }
          }
        }
      },
      "FlowTx": {
        "type": "object",
        "properties": {
          "referenceBlockId": {
            "description": "Id of the block",
            "type": "string",
            "example": "ad8b9ab637d56e19188cd5410db6e993fbf66216296c99f7934cf9f3594f9658"
          },
          "script": { "description": "Script to execute in the transaction", "type": "string" },
          "args": {
            "description": "Args to the transaction",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": { "type": "string", "example": "Address" },
                "value": { "type": "string", "example": "0x21cbd745a4df66f1" }
              }
            }
          },
          "gasLimit": { "type": "number", "example": 1000, "description": "Gas limit for the transaction" },
          "proposalKey": {
            "type": "object",
            "properties": {
              "address": { "type": "string", "example": "21cbd745a4df66f1" },
              "keyId": { "type": "number", "example": 0 },
              "sequenceNumber": { "type": "number", "example": 20 }
            }
          },
          "payer": {
            "type": "string",
            "description": "Address from which the assets and fees were debited",
            "example": "955cd3f17b2fd8ad"
          },
          "payloadSignatures": {
            "description": "Array of payload signatures.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": { "type": "string", "example": "21cbd745a4df66f1" },
                "keyId": { "type": "number", "example": 0 },
                "signature": {
                  "type": "string",
                  "example": "17a936b93b405f74af8ed4c70884ef10d98e900d04fb05bf12767e64ce5e498194348a13952c86335f56c8638fbfd0b1efde66b87e6df9ad687833709f9bd3f3"
                }
              }
            }
          },
          "envelopeSignatures": {
            "description": "Array of envelope signatures.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": { "type": "string", "example": "21cbd745a4df66f1" },
                "keyId": { "type": "number", "example": 0 },
                "signature": {
                  "type": "string",
                  "example": "17a936b93b405f74af8ed4c70884ef10d98e900d04fb05bf12767e64ce5e498194348a13952c86335f56c8638fbfd0b1efde66b87e6df9ad687833709f9bd3f3"
                }
              }
            }
          },
          "status": { "type": "number", "example": 4, "description": "Status of the transaction" },
          "statusCode": { "type": "number", "example": 0, "description": "Status cofe of the transaction" },
          "errorMessage": { "type": "string" },
          "events": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": { "type": "string", "example": "A.7e60df042a9c0868.FlowToken.TokensWithdrawn" },
                "transactionId": {
                  "type": "string",
                  "example": "d1c75a84e4bdf0dd9bf1bcd0ce4fb25f89e2ed3c5e9574dbca2760b52c428717"
                },
                "transactionIndex": { "type": "number", "example": 0 },
                "eventIndex": { "type": "number", "example": 0 },
                "data": { "type": "object", "description": "Event specific data. May vary." }
              }
            }
          }
        }
      },
      "FlowEvent": {
        "type": "object",
        "properties": {
          "blockID": {
            "type": "string",
            "example": "c49322287d9ce1d05e909668a15f3e1ed5593b11ace2cbbee56eebf8e9fb1a85"
          },
          "blockHeight": { "type": "number", "example": 14493280 },
          "blockTimestamp": { "type": "string", "example": "2021-05-14T21:08:34.536Z" },
          "type": { "type": "string", "example": "A.7e60df042a9c0868.FlowToken.TokensWithdrawn" },
          "transactionId": {
            "type": "string",
            "example": "d1c75a84e4bdf0dd9bf1bcd0ce4fb25f89e2ed3c5e9574dbca2760b52c428717"
          },
          "transactionIndex": { "type": "number", "example": 0 },
          "eventIndex": { "type": "number", "example": 0 },
          "payload": {
            "type": "object",
            "properties": {
              "type": { "type": "string", "description": "Type of payload.", "enum": ["Event"] },
              "value": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "Event type",
                    "example": "A.1654653399040a61.FlowToken.TokensWithdrawn"
                  },
                  "fields": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "example": "name",
                          "description": "Name of the property"
                        },
                        "value": {
                          "oneOf": [
                            {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "Type of the value",
                                  "example": "UFix64"
                                },
                                "value": { "type": "string", "description": "Value", "example": "0.001" }
                              }
                            },
                            {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "Type of the value",
                                  "example": "Optional"
                                },
                                "value": {
                                  "type": "object",
                                  "properties": {
                                    "type": {
                                      "type": "string",
                                      "description": "Type of the value",
                                      "example": "Address"
                                    },
                                    "value": {
                                      "type": "string",
                                      "description": "Value",
                                      "example": "0x18eb4ee6b3c026d2"
                                    }
                                  }
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "EthTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": { "$ref": "#/components/schemas/EthTxLog" }
          }
        }
      },
      "EthTxLog": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "From which this event originated from.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "topics": {
            "type": "array",
            "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
            "items": {
              "type": "string",
              "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
            }
          },
          "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
          "logIndex": {
            "type": "number",
            "description": "Integer of the event index position in the block."
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transaction’s index position, the event was created in."
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction this event was created in.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          }
        }
      },
      "EthTxInternal": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "timeStamp": {
            "type": "string",
            "description": "Time of the transaction in seconds.",
            "example": "1477837690"
          },
          "hash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": ""
          },
          "traceId": { "type": "string", "description": "Trace ID.", "example": "0" },
          "type": { "type": "string", "description": "Type of the transaction.", "example": "create" },
          "errCode": { "type": "string", "description": "Error code.", "example": "Bad jump destination" },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "isError": {
            "type": "string",
            "example": "0",
            "description": "1 if the transaction was not successful, 0 otherwise."
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          }
        }
      },
      "Trc": {
        "properties": {
          "symbol": {
            "description": "TRC token name. Used as a identifier within Tatum system and also in blockchain as a currency symbol.",
            "example": "MY_TOKEN",
            "maxLength": 30,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "supply": {
            "description": "Supply of TRC tokens.",
            "maxLength": 38,
            "example": "1000000.0",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Number of decimal points of the token.",
            "example": 6,
            "minimum": 0,
            "type": "number"
          },
          "type": {
            "description": "Type of TRC token to create.",
            "example": "TRC10",
            "type": "string",
            "enum": ["TRC10", "TRC20"]
          },
          "description": {
            "description": "Used as a description within Tatum system and in blockchain as a currency name.",
            "example": "My Public Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "url": {
            "description": "URL of the project. Applicable for TRC-10 only.",
            "example": "https://mytoken.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for TRC token. Transaction value will be calculated according to this base pair.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "accountingCurrency": {
            "description": "All transaction will be billed in this currency for created account associated with this currency. If not set, EUR is used. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 130,
            "minLength": 130,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "address": {
            "description": "Address on Tron blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 34,
            "minLength": 34,
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "type": "string"
          }
        },
        "required": ["symbol", "supply", "decimals", "type", "description", "basePair"],
        "type": "object"
      },
      "Erc20": {
        "properties": {
          "symbol": {
            "description": "ERC20/BEP20 token name. Used as a identifier within Tatum system and also in blockchain as a currency symbol.",
            "example": "MY_TOKEN",
            "maxLength": 30,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "supply": {
            "description": "Supply of ERC20/BEP20 token.",
            "maxLength": 38,
            "example": "1000000.0",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Decimals of ERC20/BEP20 token.",
            "minimum": 0,
            "example": 8,
            "type": "number"
          },
          "description": {
            "description": "Used as a description within Tatum system and in blockchain as a currency name.",
            "example": "My Public Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20/BEP20 token. Transaction value will be calculated according to this base pair.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CELO",
              "CEUR",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CUSD",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "accountingCurrency": {
            "description": "All transaction will be billed in this currency for created account associated with this currency. If not set, EUR is used. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "derivationIndex": {
            "description": "Derivation index for xpub to generate specific deposit address.",
            "format": "int32",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          },
          "xpub": {
            "description": "Extended public key (xpub), from which address, where all initial supply will be stored, will be generated. Either xpub and derivationIndex, or address must be present, not both.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          }
        },
        "required": ["symbol", "supply", "decimals", "description", "basePair", "derivationIndex", "xpub"],
        "type": "object"
      },
      "Erc20Address": {
        "properties": {
          "symbol": {
            "description": "ERC20/BEP20/SPL token name. Used as a identifier within Tatum system and also in blockchain as a currency symbol.",
            "example": "MY_TOKEN",
            "maxLength": 30,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "supply": {
            "description": "Supply of ERC20/BEP20/SPL token.",
            "maxLength": 38,
            "example": "1000000.0",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "decimals": {
            "description": "Decimals of ERC20/BEP20/SPL token.",
            "minimum": 0,
            "example": 8,
            "type": "number"
          },
          "description": {
            "description": "Used as a description within Tatum system and in blockchain as a currency name.",
            "example": "My Public Token",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "basePair": {
            "description": "Base pair for ERC20/BEP20/SPL token. Transaction value will be calculated according to this base pair.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CELO",
              "CEUR",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CUSD",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "accountingCurrency": {
            "description": "All transaction will be billed in this currency for created account associated with this currency. If not set, EUR is used. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          },
          "address": {
            "description": "Address on the blockchain, where all initial supply will be stored. Either xpub and derivationIndex, or address must be present, not both. For Solana, only address can be used.",
            "maxLength": 44,
            "minLength": 42,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          }
        },
        "required": ["symbol", "supply", "decimals", "description", "basePair", "address"],
        "type": "object"
      },
      "Erc20Response": {
        "properties": {
          "accountId": {
            "description": "Account ID with the type of currency as created ERC20/BEP20 token symbol. Supply of ERC20/BEP20 token will be credited as soon as ERC20/BEP20 token is deployed to the Ethereum blockchain.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "address": {
            "description": "Initial address of new created ERC20/BEP20 token. On this address, all tokens will be minted.",
            "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DeployErc20Response": {
        "properties": {
          "accountId": {
            "description": "Account ID with the type of currency as created ERC20/BEP20 token symbol. Account will be unfrozen when ERC20/BEP20 contract address will be set.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "txId": {
            "description": "TX hash of successful transaction. From this transaction receipt contract address can be obtained.",
            "example": "c83f8818db43d9ba4accfe454aa44fc33123d47a4f89d47b314d6748eb0e9bc9",
            "type": "string"
          }
        },
        "type": "object",
        "required": ["accountId", "txId"]
      },
      "DeployErc20SignatureResponse": {
        "properties": {
          "accountId": {
            "description": "Account ID with the type of currency as created ERC20/BEP20 token symbol. Account will be unfrozen when ERC20/BEP20 contract address will be set.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "signatureId": {
            "description": "ID of prepared payment template to sign. This is should be stored on a client side to retrieve ID of the blockchain transaction, when signing application signs the transaction and broadcasts it to the blockchain.",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "type": "object",
        "required": ["accountId", "signatureId"]
      },
      "DeployAlgoErc20Response": {
        "properties": {
          "accountId": {
            "description": "Account ID with the type of currency as created ERC20 token symbol. Account will be unfrozen when ERC20 contract address will be set.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "txId": {
            "description": "TX hash of successful transaction. From this transaction receipt contract address can be obtained.",
            "example": "JGDMW6F6BUWQLFXDEPZIUO5WCTQOL3QV7KZ2SBV44K5WE6SSNN7Q",
            "type": "string"
          }
        },
        "type": "object",
        "required": ["accountId", "txId"]
      },
      "DeployAlgoErc20SignatureResponse": {
        "properties": {
          "accountId": {
            "description": "Account ID with the type of currency as created ERC20 token symbol. Account will be unfrozen when ERC20 contract address will be set.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "signatureId": {
            "description": "ID of prepared payment template to sign. This is should be stored on a client side to retrieve ID of the blockchain transaction, when signing application signs the transaction and broadcasts it to the blockchain.",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "type": "object",
        "required": ["accountId", "signatureId"]
      },
      "Error": {
        "properties": {
          "errorCode": { "description": "payment.amount.notNull", "type": "string" },
          "message": { "description": "Payment amount must be greater than 0.", "type": "string" },
          "statusCode": { "description": "403", "type": "number" }
        },
        "required": ["errorCode", "message"],
        "type": "object"
      },
      "Error400": {
        "properties": {
          "errorCode": {
            "example": "validation.failed",
            "description": "validation.failed",
            "type": "string"
          },
          "message": {
            "example": "Request validation failed. Please see data for additional information.",
            "description": "Request validation failed. Please see data for additional information.",
            "type": "string"
          },
          "statusCode": { "example": 400, "description": "400", "type": "number" },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["target"],
              "properties": {
                "target": {
                  "type": "object",
                  "additionalProperties": true,
                  "description": "Request object present in the body of the HTTP request",
                  "example": { "property": 12345 }
                },
                "value": {
                  "type": "number",
                  "description": "Value of the target object which validation is wrong. Can be of any data type, example here is using type number.",
                  "example": 12345
                },
                "property": {
                  "type": "string",
                  "description": "Property name of the target object which validation is wrong",
                  "example": "property1"
                },
                "constraints": {
                  "type": "object",
                  "additionalProperties": true,
                  "description": "Object of failed constraints for the target object. Key is the constraint, value is detailed description of the failed constraint.",
                  "example": { "min": "property1 must not be less than 50000" }
                }
              }
            }
          }
        },
        "required": ["errorCode", "message", "statusCode", "data"],
        "type": "object"
      },
      "Error401Invalid": {
        "properties": {
          "errorCode": {
            "example": "subscription.invalid",
            "description": "subscription.invalid",
            "type": "string"
          },
          "message": {
            "example": "Unable to find valid subscription for '${apiKey}'",
            "description": "Unable to find valid subscription for '${apiKey}'",
            "type": "string"
          },
          "statusCode": { "example": 401, "description": "401", "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error401NotActive": {
        "properties": {
          "errorCode": {
            "example": "subscription.not.active",
            "description": "subscription.not.active",
            "type": "string"
          },
          "message": {
            "example": "Subscription not active anymore.",
            "description": "Subscription not active anymore.",
            "type": "string"
          },
          "statusCode": { "example": 401, "description": "401", "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403ComplianceBtc": {
        "properties": {
          "errorCode": {
            "description": "compliance.country.btc.not.supported",
            "example": "compliance.country.btc.not.supported",
            "type": "string"
          },
          "message": {
            "description": "Customer country not supported for BTC.",
            "example": "Customer country not supported for BTC.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403Libra": {
        "properties": {
          "errorCode": {
            "description": "libra.request.failed",
            "example": "libra.request.failed",
            "type": "string"
          },
          "message": { "description": "${error}", "example": "${error}", "type": "string" },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthBroadcast": {
        "properties": {
          "errorCode": {
            "description": "ethereum.broadcast.failed",
            "example": "ethereum.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthErc20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such ERC20 currency ${name}.",
            "example": "No such ERC20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxNotFound": {
        "properties": {
          "errorCode": { "description": "tx.missing", "example": "tx.missing", "type": "string" },
          "message": { "description": "No such tx.", "example": "No such tx.", "type": "string" },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error404TxNotFound": {
        "properties": {
          "errorCode": { "description": "tx.not.found", "example": "tx.not.found", "type": "string" },
          "message": {
            "description": "Transaction not found. Possible not exists or is still pending.",
            "example": "Transaction not found. Possible not exists or is still pending.",
            "type": "string"
          },
          "statusCode": { "description": "404", "example": 404, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthErc20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "ERC20 address was already set.",
            "example": "ERC20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthErc20Unsupported": {
        "properties": {
          "errorCode": {
            "description": "eth.erc20.unsupported",
            "example": "eth.erc20.unsupported",
            "type": "string"
          },
          "message": {
            "description": "Unsupported ETH ERC20 blockchain.",
            "example": "Unsupported ETH ERC20 blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthTxHash": {
        "properties": {
          "errorCode": {
            "description": "eth.transaction.hash",
            "example": "eth.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthTxSign": {
        "properties": {
          "errorCode": {
            "description": "eth.transaction.sign",
            "example": "eth.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthErc20TxSign": {
        "properties": {
          "errorCode": { "description": "eth.erc20.sign", "example": "eth.erc20.sign", "type": "string" },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthErc721TxSign": {
        "properties": {
          "errorCode": { "description": "eth.erc721.sign", "example": "eth.erc721.sign", "type": "string" },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthErc721Call": {
        "properties": {
          "errorCode": {
            "description": "eth.erc721.failed",
            "example": "eth.erc721.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to obtain information for token. ${error}",
            "example": "Unable to obtain information for token. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "eth.transaction.gas",
            "example": "eth.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthTxBody": {
        "properties": {
          "errorCode": {
            "description": "ethereum.transaction.body",
            "example": "ethereum.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthScBody": {
        "properties": {
          "errorCode": {
            "description": "ethereum.sc.invalid",
            "example": "ethereum.sc.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid parameters for smart contract invocation.",
            "example": "Invalid parameters for smart contract invocation.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EthGasPrice": {
        "properties": {
          "errorCode": { "description": "gas.price.failed", "example": "gas.price.failed", "type": "string" },
          "message": {
            "description": "Unable to obtain current GAS price.",
            "example": "Unable to obtain current GAS price.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403ComplianceEth": {
        "properties": {
          "errorCode": {
            "description": "compliance.country.eth.not.supported",
            "example": "compliance.country.eth.not.supported",
            "type": "string"
          },
          "message": {
            "description": "Customer country not supported for ETH.",
            "example": "Customer country not supported for ETH.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountTestnet": {
        "properties": {
          "errorCode": {
            "description": "account.blockchain.testnet",
            "example": "account.blockchain.testnet",
            "type": "string"
          },
          "message": {
            "description": "Unable to create account, unsupported testnet blockchain.",
            "example": "Unable to create account, unsupported testnet blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountXpub": {
        "properties": {
          "errorCode": {
            "description": "account.xpub.present",
            "example": "account.xpub.present",
            "type": "string"
          },
          "message": {
            "description": "Unable to create ${account.currency} account with xpub.",
            "example": "Unable to create ${account.currency} account with xpub.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AddressXpub": {
        "properties": {
          "errorCode": {
            "description": "account.xpub.present",
            "example": "account.xpub.present",
            "type": "string"
          },
          "message": {
            "description": "Xpub assigned to account, it is not possible to assign address. Use generateAddress method instead.",
            "example": "Xpub assigned to account, it is not possible to assign address. Use generateAddress method instead.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountCurrency": {
        "properties": {
          "errorCode": {
            "description": "ledger.currency.invalid",
            "example": "ledger.currency.invalid",
            "type": "string"
          },
          "message": {
            "description": "Unable to create an account, unsupported currency.",
            "example": "Unable to create an account, unsupported currency.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountIncompatibleXpub": {
        "properties": {
          "errorCode": {
            "description": "account.xpub.incompatible",
            "example": "account.xpub.incompatible",
            "type": "string"
          },
          "message": {
            "description": "Xpub not compatible with account currency.",
            "example": "Xpub not compatible with account currency.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountIncompatibleXpubBtc": {
        "properties": {
          "errorCode": {
            "description": "Address.generation.failed.wrong.xpub",
            "example": "address.generation.failed.wrong.xpub",
            "type": "string"
          },
          "message": {
            "description": "Unable to generate address, wrong xpub and account type.",
            "example": "Unable to generate address, wrong xpub and account type.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountAddressGeneral": {
        "properties": {
          "errorCode": {
            "description": "Address.generation.failed",
            "example": "address.generation.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to generate address.",
            "example": "Unable to generate address.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BnbFailed": {
        "properties": {
          "errorCode": { "description": "bnb.failed", "example": "bnb.failed", "type": "string" },
          "message": {
            "description": "Unable to communicate with blockchain. ${error}",
            "example": "Unable to communicate with blockchain. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BnbAddressFailed": {
        "properties": {
          "errorCode": {
            "description": "Address.bnb.generation.failed.wrong.xpub",
            "example": "address.bnb.generation.failed.wrong.xpub",
            "type": "string"
          },
          "message": {
            "description": "Unable to generate BNB address, wrong xpub and account type.",
            "example": "Unable to generate BNB address, wrong xpub and account type.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BnbBroadcatSigFailed": {
        "properties": {
          "errorCode": {
            "description": "bnb.broadcast.bad.signature",
            "example": "bnb.broadcast.bad.signature",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast BNB transaction, bad signature.",
            "example": "Unable to broadcast BNB transaction, bad signature.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BnbTxStateFailed": {
        "properties": {
          "errorCode": {
            "description": "bnb.broadcast.failed.tx.state",
            "example": "bnb.broadcast.failed.tx.state",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast BNB transaction, tx ${hash} state not OK.",
            "example": "Unable to broadcast BNB transaction, tx ${hash} state not OK.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BnbTxFailed": {
        "properties": {
          "errorCode": {
            "description": "bnb.transfer.failed",
            "example": "bnb.transfer.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to transfer funds. ${error}",
            "example": "Unable to transfer funds. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BtcTxFailed": {
        "properties": {
          "errorCode": {
            "description": "transaction.failed",
            "example": "transaction.failed",
            "type": "string"
          },
          "message": {
            "description": "No spendable inputs.",
            "example": "No spendable inputs.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BtcTx": {
        "properties": {
          "errorCode": {
            "description": "transaction.invalid.body",
            "example": "transaction.invalid.body",
            "type": "string"
          },
          "message": {
            "description": "Either UTXO, or addresses must be present.",
            "example": "Either UTXO, or addresses must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountNotExists": {
        "properties": {
          "errorCode": {
            "description": "account.not.exists",
            "example": "account.not.exists",
            "type": "string"
          },
          "message": { "description": "No such account.", "example": "No such account.", "type": "string" },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BlockageNotExists": {
        "properties": {
          "errorCode": {
            "description": "blockage.not.exists",
            "example": "blockage.not.exists",
            "type": "string"
          },
          "message": { "description": "No such blockage.", "example": "No such blockage.", "type": "string" },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BlockageAmount": {
        "properties": {
          "errorCode": {
            "description": "blockage.amount.exceeded",
            "example": "blockage.amount.exceeded",
            "type": "string"
          },
          "message": {
            "description": "Amount to transfer is greater then amount of the blockage.",
            "example": "Amount to transfer is greater then amount of the blockage.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionNotExists": {
        "properties": {
          "errorCode": {
            "description": "subscription.not.exists",
            "example": "subscription.not.exists",
            "type": "string"
          },
          "message": {
            "description": "No such subscription.",
            "example": "No such subscription.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionType": {
        "properties": {
          "errorCode": {
            "description": "subscription.type.invalid",
            "example": "subscription.type.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid subscription type.",
            "example": "Invalid subscription type.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionCurrency": {
        "properties": {
          "errorCode": {
            "description": "subscription.attr.currency.invalid",
            "example": "subscription.attr.currency.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid subscription attribute 'currency'.",
            "example": "Invalid subscription attribute 'currency'.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionInterval": {
        "properties": {
          "errorCode": {
            "description": "subscription.attr.interval.invalid",
            "example": "subscription.attr.interval.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid subscription attribute 'interval'.",
            "example": "Invalid subscription attribute 'interval'.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionBalance": {
        "properties": {
          "errorCode": {
            "description": "subscription.attr.balance.invalid",
            "example": "subscription.attr.balance.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid subscription attribute 'limit' or 'typeOfBalance'.",
            "example": "Invalid subscription attribute 'limit' or 'typeOfBalance'.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionId": {
        "properties": {
          "errorCode": {
            "description": "subscription.attr.incoming.invalid",
            "example": "subscription.attr.incoming.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid subscription attribute 'id' or 'url'.",
            "example": "Invalid subscription attribute 'id' or 'url'.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SubscriptionPendingId": {
        "properties": {
          "errorCode": {
            "description": "subscription.attr.pending.invalid",
            "example": "subscription.attr.pending.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid subscription attribute 'id' or 'url'.",
            "example": "Invalid subscription attribute 'id' or 'url'.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403ReportNotAvailable": {
        "properties": {
          "errorCode": { "description": "report.invalid", "example": "report.invalid", "type": "string" },
          "message": {
            "description": "Unsupported report type.",
            "example": "Unsupported report type.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountInactive": {
        "properties": {
          "errorCode": { "description": "account.inactive", "example": "account.inactive", "type": "string" },
          "message": {
            "description": "Unable to deactivate inactive account.",
            "example": "Unable to deactivate inactive account.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountActive": {
        "properties": {
          "errorCode": { "description": "account.active", "example": "account.active", "type": "string" },
          "message": {
            "description": "Unable to activate active account.",
            "example": "Unable to activate active account.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountFrozen": {
        "properties": {
          "errorCode": { "description": "account.frozen", "example": "account.frozen", "type": "string" },
          "message": {
            "description": "Unable to freeze frozen account.",
            "example": "Unable to freeze frozen account.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountNotFrozen": {
        "properties": {
          "errorCode": {
            "description": "account.not.frozen",
            "example": "account.not.frozen",
            "type": "string"
          },
          "message": {
            "description": "Unable to unfreeze unfrozen account.",
            "example": "Unable to unfreeze unfrozen account.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerInternalNotExists": {
        "properties": {
          "errorCode": {
            "description": "customer.internal.not.exists",
            "example": "customer.internal.not.exists",
            "type": "string"
          },
          "message": { "description": "No such customer.", "example": "No such customer.", "type": "string" },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerActive": {
        "properties": {
          "errorCode": { "description": "customer.active", "example": "customer.active", "type": "string" },
          "message": {
            "description": "Unable to activate active customer.",
            "example": "Unable to activate active customer.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerInactive": {
        "properties": {
          "errorCode": {
            "description": "customer.inactive",
            "example": "customer.inactive",
            "type": "string"
          },
          "message": {
            "description": "Unable to perform operation on inactive customer.",
            "example": "Unable to perform operation on inactive customer.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerDisabled": {
        "properties": {
          "errorCode": {
            "description": "customer.disabled",
            "example": "customer.disabled",
            "type": "string"
          },
          "message": {
            "description": "Unable to disable disabled customer.",
            "example": "Unable to disable disabled customer.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerEnabled": {
        "properties": {
          "errorCode": { "description": "customer.enabled", "example": "customer.enabled", "type": "string" },
          "message": {
            "description": "Unable to enable enabled customer.",
            "example": "Unable to enable enabled customer.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerDeactivateActiveAccounts": {
        "properties": {
          "errorCode": {
            "description": "customer.deactivate.account.active",
            "example": "customer.deactivate.account.active",
            "type": "string"
          },
          "message": {
            "description": "Unable to deactivate customer, accounts not deactivated.",
            "example": "Unable to deactivate customer, accounts not deactivated.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerNotExists": {
        "properties": {
          "errorCode": {
            "description": "customer.not.exists",
            "example": "customer.not.exists",
            "type": "string"
          },
          "message": {
            "description": "No customer with given external ID ${externalId} exists.",
            "example": "No customer with given external ID ${externalId} exists.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BlockDelete": {
        "properties": {
          "errorCode": {
            "description": "customer.blockage.inactive",
            "example": "customer.blockage.inactive",
            "type": "string"
          },
          "message": {
            "description": "Unable to delete blockages on account for inactive customer.",
            "example": "Unable to delete blockages on account for inactive customer.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CustomerNotActive": {
        "properties": {
          "errorCode": {
            "description": "customer.not.active",
            "example": "customer.not.active",
            "type": "string"
          },
          "message": {
            "description": "Customer not active.",
            "example": "Customer not active.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCNoAccount": {
        "properties": {
          "errorCode": {
            "description": "virtual.account.notValid",
            "example": "virtual.account.notValid",
            "type": "string"
          },
          "message": {
            "description": "Unable to perform operation on virtual currency, account does not exists.",
            "example": "Unable to perform operation on virtual currency, account does not exists.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCTxFailed": {
        "properties": {
          "errorCode": {
            "description": "virtual.tx.failed",
            "example": "virtual.tx.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to perform operation on virtual currency, impossible to store transaction.",
            "example": "Unable to perform operation on virtual currency, impossible to store transaction.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCRevokeBalance": {
        "properties": {
          "errorCode": {
            "description": "virtual.account.balance",
            "example": "virtual.account.balance",
            "type": "string"
          },
          "message": {
            "description": "Insufficient balance to revoke virtual currency on account.",
            "example": "Insufficient balance to revoke virtual currency on account.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCCreateFailed": {
        "properties": {
          "errorCode": {
            "description": "virtual.creation.error",
            "example": "virtual.creation.error",
            "type": "string"
          },
          "message": {
            "description": "It is not possible to create virtual currency.",
            "example": "It is not possible to create virtual currency.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCPrefix": {
        "properties": {
          "errorCode": {
            "description": "virtual.name.prefix",
            "example": "virtual.name.prefix",
            "type": "string"
          },
          "message": {
            "description": "Virtual currency has wrong name, must start with VC_.",
            "example": "Virtual currency has wrong name, must start with VC_.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCDuplicate": {
        "properties": {
          "errorCode": {
            "description": "virtual.duplicate",
            "example": "virtual.duplicate",
            "type": "string"
          },
          "message": {
            "description": "Virtual currency with given name already exists.",
            "example": "Virtual currency with given name already exists.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountCustomerInactive": {
        "properties": {
          "errorCode": {
            "description": "account.customer.inactive",
            "example": "account.customer.inactive",
            "type": "string"
          },
          "message": {
            "description": "Unable to activate account, customer inactive.",
            "example": "Unable to activate account, customer inactive.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountBalanceNonZero": {
        "properties": {
          "errorCode": {
            "description": "account.balance.non.zero",
            "example": "account.balance.non.zero",
            "type": "string"
          },
          "message": {
            "description": "Unable to deactivate account with non-zero balance.",
            "example": "Unable to deactivate account with non-zero balance.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TradeBalanceNonZero": {
        "properties": {
          "errorCode": {
            "description": "account.trade.non.zero",
            "example": "account.trade.non.zero",
            "type": "string"
          },
          "message": {
            "description": "Unable to deactivate account with non-zero exchange trades.",
            "example": "Unable to deactivate account with non-zero exchange trades.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AmountFormat": {
        "properties": {
          "errorCode": { "description": "amount.format", "example": "amount.format", "type": "string" },
          "message": {
            "description": "Amount has incorrect format.",
            "example": "Amount has incorrect format.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403RecipientFormat": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.recipient.format",
            "example": "withdrawal.recipient.format",
            "type": "string"
          },
          "message": {
            "description": "Recipient blockchain address has incorrect format.",
            "example": "Recipient blockchain address has incorrect format.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AccountCurrencyVC": {
        "properties": {
          "errorCode": {
            "description": "account.currency.missing",
            "example": "account.currency.missing",
            "type": "string"
          },
          "message": {
            "description": "No such virtual currency ${currency} for account ${account}.",
            "example": "No such virtual currency ${currency} for account ${account}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VCNotFound": {
        "properties": {
          "errorCode": { "description": "vc.not.found", "example": "vc.not.found", "type": "string" },
          "message": {
            "description": "No such virtual currency.",
            "example": "No such virtual currency.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AddressUsed": {
        "properties": {
          "errorCode": { "description": "Address.used", "example": "address.used", "type": "string" },
          "message": {
            "description": "Address and currency already in use.",
            "example": "Address and currency already in use.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AddressNotFound": {
        "properties": {
          "errorCode": {
            "description": "Address.not.found",
            "example": "address.not.found",
            "type": "string"
          },
          "message": {
            "description": "No such address exists.",
            "example": "No such address exists.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AddressAccountXpubMissing": {
        "properties": {
          "errorCode": {
            "description": "account.xpub.missing",
            "example": "account.xpub.missing",
            "type": "string"
          },
          "message": {
            "description": "No xpub assigned to account, it is not possible to generate address. Use assignAddress method instead.",
            "example": "No xpub assigned to account, it is not possible to generate address. Use assignAddress method instead.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AddressIndexUsed": {
        "properties": {
          "errorCode": {
            "description": "Address.index.used",
            "example": "address.index.used",
            "type": "string"
          },
          "message": {
            "description": "Unable to create address, derivation index is already used.",
            "example": "Unable to create address, derivation index is already used.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BtcBlockchain": {
        "properties": {
          "errorCode": {
            "description": "blockchain.error.code",
            "example": "blockchain.error.code",
            "type": "string"
          },
          "message": {
            "description": "${error.message} Code: ${error.code}",
            "example": "${error.message} Code: ${error.code}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error404BlockNotExists": {
        "properties": {
          "errorCode": {
            "description": "block.hash.not.exists",
            "example": "block.hash.not.exists",
            "type": "string"
          },
          "message": { "description": "No such block.", "example": "No such block.", "type": "string" },
          "statusCode": { "description": "404", "example": 404, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403Broadcast": {
        "properties": {
          "errorCode": {
            "description": "blockchain.broadcast.error",
            "example": "blockchain.broadcast.error",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction, wrong input data.",
            "example": "Unable to broadcast transaction, wrong input data.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BlockchainPrivateFailed": {
        "properties": {
          "errorCode": {
            "description": "key.generation.failed.wrong.mnemonic",
            "example": "key.generation.failed.wrong.mnemonic",
            "type": "string"
          },
          "message": {
            "description": "Unable to generate address, wrong mnemonic and index.",
            "example": "Unable to generate address, wrong mnemonic and index.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BtcUTXO": {
        "properties": {
          "errorCode": {
            "description": "tx.hash.index.spent",
            "example": "tx.hash.index.spent",
            "type": "string"
          },
          "message": {
            "description": "No such UTXO for transaction and index.",
            "example": "No such UTXO for transaction and index.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BcashBroadcast": {
        "properties": {
          "errorCode": {
            "description": "bch.broadcast.failed",
            "example": "bch.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction. Error from blockchain: ${error}",
            "example": "Unable to broadcast transaction. Error from blockchain: ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403WithdrawalNotFound": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.missing",
            "example": "withdrawal.missing",
            "type": "string"
          },
          "message": {
            "description": "No such withdrawal.",
            "example": "No such withdrawal.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KMSNotExists": {
        "properties": {
          "errorCode": { "description": "kms.missing", "example": "kms.missing", "type": "string" },
          "message": {
            "description": "No such KMS signature with id '{id}'.",
            "example": "No such KMS signature with id '{id}'.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OffchainNotCancelled": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.not.cancelled.transaction.failed",
            "example": "withdrawal.not.cancelled.transaction.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction, and impossible to cancel withdrawal. ID is attached, \"${withdrawalId}\", cancel it manually.",
            "example": "Unable to broadcast transaction, and impossible to cancel withdrawal. ID is attached, \"${withdrawalId}\", cancel it manually.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XlmFailed": {
        "properties": {
          "errorCode": { "description": "xlm.failed", "example": "xlm.failed", "type": "string" },
          "message": {
            "description": "Unable to communicate with blockchain. ${error}",
            "example": "Unable to communicate with blockchain. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpFailed": {
        "properties": {
          "errorCode": { "description": "xrp.failed", "example": "xrp.failed", "type": "string" },
          "message": {
            "description": "Unable to communicate with blockchain. ${error}",
            "example": "Unable to communicate with blockchain. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpCode": {
        "properties": {
          "errorCode": {
            "description": "xrp.account.failed",
            "example": "xrp.account.failed",
            "type": "string"
          },
          "message": {
            "description": "${error} Code: ${code}",
            "example": "${error} Code: ${code}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpLedger": {
        "properties": {
          "errorCode": {
            "description": "xrp.ledger.failed",
            "example": "xrp.ledger.failed",
            "type": "string"
          },
          "message": {
            "description": "${error} Code: ${code}",
            "example": "${error} Code: ${code}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpBroadcast": {
        "properties": {
          "errorCode": {
            "description": "xrp.broadcast.failed",
            "example": "xrp.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Xrp submit tx failed. ${error}",
            "example": "Xrp submit tx failed. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpMultiple": {
        "properties": {
          "errorCode": {
            "description": "xrp.settings.multiple",
            "example": "xrp.settings.multiple",
            "type": "string"
          },
          "message": {
            "description": "It is possible to set 1 parameter at a time.",
            "example": "It is possible to set 1 parameter at a time.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpAttr": {
        "properties": {
          "errorCode": {
            "description": "attr.wrong.format",
            "example": "attr.wrong.format",
            "type": "string"
          },
          "message": {
            "description": "Wrong attr of withdrawal, should be of uint32 type.",
            "example": "Wrong attr of withdrawal, should be of uint32 type.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpFee": {
        "properties": {
          "errorCode": { "description": "xrp.fee", "example": "xrp.fee", "type": "string" },
          "message": {
            "description": "Unable to calculate fee.",
            "example": "Unable to calculate fee.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XrpSign": {
        "properties": {
          "errorCode": { "description": "xrp.sign.failed", "example": "xrp.sign.failed", "type": "string" },
          "message": {
            "description": "Unable to sign tx. ${error}",
            "example": "Unable to sign tx. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XlmTxFailed": {
        "properties": {
          "errorCode": { "description": "xlm.tx.failed", "example": "xlm.tx.failed", "type": "string" },
          "message": {
            "description": "Unable to construct transaction. ${error}",
            "example": "Unable to construct transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VetFailed": {
        "properties": {
          "errorCode": { "description": "vet.failed", "example": "vet.failed", "type": "string" },
          "message": {
            "description": "Unable to communicate with blockchain. ${error}",
            "example": "Unable to communicate with blockchain. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VetGas": {
        "properties": {
          "errorCode": {
            "description": "vet.transaction.gas",
            "example": "vet.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403VetTxHash": {
        "properties": {
          "errorCode": {
            "description": "vet.transaction.hash",
            "example": "vet.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash.",
            "example": "Unable to calculate transaction hash.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TransactionFeeEgldBlockchain": {
        "type": "object",
        "properties": {
          "sender": {
            "description": "Account address of the sender",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7",
            "maxLength": 62,
            "minLength": 62,
            "type": "string"
          },
          "receiver": {
            "description": "Account address of the receiver or smart contract",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq6",
            "maxLength": 62,
            "minLength": 62,
            "type": "string"
          },
          "value": { "type": "string", "description": "Value to be sent.", "example": "0.1" },
          "data": {
            "type": "string",
            "description": "Additinal data, that will be passed to blockchain transaction.",
            "example": "Hello world"
          }
        },
        "required": ["sender", "receiver", "value"]
      },
      "Error403EgldGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "egld.transaction.gas",
            "example": "egld.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OffchainBroadcastState": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.unexpected.state",
            "example": "withdrawal.unexpected.state",
            "type": "string"
          },
          "message": {
            "description": "Unable to complete withdrawal, which is not in InProgress state.",
            "example": "Unable to complete withdrawal, which is not in InProgress state.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OffchainCancelled": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.prepare.failed",
            "example": "withdrawal.prepare.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to prepare transaction, withdrawal cancelled.",
            "example": "Unable to prepare transaction, withdrawal cancelled.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OffchainNotSupported": {
        "properties": {
          "errorCode": {
            "description": "offchain.not.supported",
            "example": "offchain.not.supported",
            "type": "string"
          },
          "message": {
            "description": "Offchain not supported for account with ${account.currency} currency.",
            "example": "Offchain not supported for account with ${account.currency} currency.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403AddressAccountXpubUsed": {
        "properties": {
          "errorCode": { "description": "xpub.used", "example": "xpub.used", "type": "string" },
          "message": {
            "description": "XPub already used registered within Tatum",
            "example": "XPub already used registered within Tatum",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403RateNotFound": {
        "properties": {
          "errorCode": { "description": "rate.not.found", "example": "rate.not.found", "type": "string" },
          "message": {
            "description": "No such currency rate.",
            "example": "No such currency rate.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OffchainBroadcast": {
        "properties": {
          "errorCode": {
            "description": "broadcast.failed.withdrawalId",
            "example": "broadcast.failed.withdrawalId",
            "type": "string"
          },
          "message": {
            "description": "WithdrawalId must be present.",
            "example": "WithdrawalId must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OffchainCheck": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.check.currency",
            "example": "withdrawal.check.currency",
            "type": "string"
          },
          "message": {
            "description": "Withdrawal check available only for ETH based currencies.",
            "example": "Withdrawal check available only for ETH based currencies.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BtcTxUtxoFailed": {
        "properties": {
          "errorCode": {
            "description": "transaction.preparation.failed.utxo",
            "example": "transaction.preparation.failed.utxo",
            "type": "string"
          },
          "message": {
            "description": "Impossible to find last UTXO.",
            "example": "Impossible to find last UTXO.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BtcMnemonicTxFailed": {
        "properties": {
          "errorCode": {
            "description": "transaction.preparation.failed",
            "example": "transaction.preparation.failed",
            "type": "string"
          },
          "message": {
            "description": "Impossible to prepare transaction. Either mnemonic or keyPair and attr must be present.",
            "example": "Impossible to prepare transaction. Either mnemonic or keyPair and attr must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403WithdrawalFailed": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.failed.transaction.failed",
            "example": "withdrawal.failed.transaction.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to store withdrawal, it is impossible to create transaction.",
            "example": "Unable to store withdrawal, it is impossible to create transaction.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403WithdrawalCancelled": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.not.cancelled.transaction.failed",
            "example": "withdrawal.not.cancelled.transaction.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to cancel withdrawal ${id}, it is impossible to create refund transaction.",
            "example": "Unable to cancel withdrawal ${id}, it is impossible to create refund transaction.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403FeeFormat": {
        "properties": {
          "errorCode": { "description": "fee.format", "example": "fee.format", "type": "string" },
          "message": {
            "description": "Fee has incorrect format.",
            "example": "Fee has incorrect format.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxSenderNotFound": {
        "properties": {
          "errorCode": {
            "description": "senderAccount.not.exists",
            "example": "senderAccount.not.exists",
            "type": "string"
          },
          "message": {
            "description": "Unable to find sender account ${transaction.senderAccountId}.",
            "example": "Unable to find sender account ${transaction.senderAccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxSenderFrozen": {
        "properties": {
          "errorCode": {
            "description": "senderAccount.frozen",
            "example": "senderAccount.frozen",
            "type": "string"
          },
          "message": {
            "description": "Sender account ${transaction.senderAccountId} is frozen, unable to perform payment.",
            "example": "Sender account ${transaction.senderAccountId} is frozen, unable to perform payment.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxSenderCustomerDisabled": {
        "properties": {
          "errorCode": {
            "description": "senderAccount.customer.disabled",
            "example": "senderAccount.customer.disabled",
            "type": "string"
          },
          "message": {
            "description": "Sender accounts customer ${senderAccount.customerId} is disabled, unable to perform payment.",
            "example": "Sender accounts customer ${senderAccount.customerId} is disabled, unable to perform payment.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxRecipientNotFound": {
        "properties": {
          "errorCode": {
            "description": "recipientAccount.not.exists",
            "example": "recipientAccount.not.exists",
            "type": "string"
          },
          "message": {
            "description": "Unable to find recipient account ${transaction.recipientAccountId}.",
            "example": "Unable to find recipient account ${transaction.recipientAccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxCurrency": {
        "properties": {
          "errorCode": {
            "description": "transaction.currency.incompatible",
            "example": "transaction.currency.incompatible",
            "type": "string"
          },
          "message": {
            "description": "Incompatible currencies for sender account ${transaction.senderAccountId} and recipient account ${transaction.recipientAccountId}.",
            "example": "Incompatible currencies for sender account ${transaction.senderAccountId} and recipient account ${transaction.recipientAccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxBalance": {
        "properties": {
          "errorCode": {
            "description": "balance.insufficient",
            "example": "balance.insufficient",
            "type": "string"
          },
          "message": {
            "description": "Insufficient balance for account ${transaction.senderAccountId} and payment amount ${transaction.amount}. Sender balance is ${senderAccount.balance.availableBalance as string}, amount is ${amount}",
            "example": "Insufficient balance for account ${transaction.senderAccountId} and payment amount ${transaction.amount}. Sender balance is ${senderAccount.balance.availableBalance as string}, amount is ${amount}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxAmountBtc": {
        "properties": {
          "errorCode": { "description": "amount.btc", "example": "amount.btc", "type": "string" },
          "message": {
            "description": "BTC|LTC|BCH payment amount must be at least 0.00000000000001, not ${transaction.amount}.",
            "example": "BTC|LTC|BCH payment amount must be at least 0.00000000000001, not ${transaction.amount}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxAmountBtcOffchain": {
        "properties": {
          "errorCode": {
            "description": "transaction.amount.btc",
            "example": "transaction.amount.btc",
            "type": "string"
          },
          "message": {
            "description": "BTC|LTC|BCH payment amount must be at least 0.00000001, not ${transaction.amount}.",
            "example": "BTC|LTC|BCH payment amount must be at least 0.00000001, not ${transaction.amount}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxAmountAda": {
        "properties": {
          "errorCode": {
            "description": "transaction.amount.ada",
            "example": "transaction.amount.ada",
            "type": "string"
          },
          "message": {
            "description": "ADA payment amount must be at least 0.000001, not ${transaction.amount}.",
            "example": "ADA payment amount must be at least 0.000001, not ${transaction.amount}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxAmountAdaOffchain": {
        "properties": {
          "errorCode": { "description": "amount.ada", "example": "amount.ada", "type": "string" },
          "message": {
            "description": "ADA payment amount must be at least 0.000000000001, not ${transaction.amount}.",
            "example": "ADA payment amount must be at least 0.000000000001, not ${transaction.amount}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403WithdrawalPending": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.pending",
            "example": "withdrawal.pending",
            "type": "string"
          },
          "message": {
            "description": "Unable to prepare withdrawal, last withdrawal with id ${id} is not yet processed by blockchain.",
            "example": "Unable to prepare withdrawal, last withdrawal with id ${id} is not yet processed by blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxAmountEth": {
        "properties": {
          "errorCode": { "description": "amount.eth", "example": "amount.eth", "type": "string" },
          "message": {
            "description": "ETH payment amount must be at least 0.000000000001, not ${transaction.amount}.",
            "example": "ETH payment amount must be at least 0.000000000001, not ${transaction.amount}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxAmountEthOffchain": {
        "properties": {
          "errorCode": {
            "description": "transaction.amount.eth",
            "example": "transaction.amount.eth",
            "type": "string"
          },
          "message": {
            "description": "ETH payment amount must be at least 0.000000000000000001, not ${transaction.amount}.",
            "example": "ETH payment amount must be at least 0.000000000000000001, not ${transaction.amount}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403TxNotCompliant": {
        "properties": {
          "errorCode": {
            "description": "transaction.not.compliant",
            "example": "transaction.not.compliant",
            "type": "string"
          },
          "message": {
            "description": "Transaction not compliant, recipient account customer country is not defined.",
            "example": "Transaction not compliant, recipient account customer country is not defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403WithdrawalVC": {
        "properties": {
          "errorCode": {
            "description": "withdrawal.account.virtual",
            "example": "withdrawal.account.virtual",
            "type": "string"
          },
          "message": {
            "description": "Sender account cannot be virtual.",
            "example": "Sender account cannot be virtual.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403Erc20Prefix": {
        "properties": {
          "errorCode": {
            "description": "erc20.symbol.prefix",
            "example": "erc20.symbol.prefix",
            "type": "string"
          },
          "message": {
            "description": "ERC20 token cannot start with VC_.",
            "example": "ERC20 token cannot start with VC_.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403Erc20XpubBoth": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.xpub.both",
            "example": "erc20.address.xpub.both",
            "type": "string"
          },
          "message": {
            "description": "Either xpub or address must be present, not both.",
            "example": "Either xpub or address must be present, not both.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403Erc20XpubMissing": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.xpub.missing",
            "example": "erc20.address.xpub.missing",
            "type": "string"
          },
          "message": {
            "description": "Either xpub or address must be present.",
            "example": "Either xpub or address must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403Erc20NameDuplicate": {
        "properties": {
          "errorCode": {
            "description": "erc20.duplicate.name",
            "example": "erc20.duplicate.name",
            "type": "string"
          },
          "message": {
            "description": "ERC20 token with given name already exists.",
            "example": "ERC20 token with given name already exists.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency1NotFound": {
        "properties": {
          "errorCode": {
            "description": "trade.currency1AccountId.not.exists",
            "example": "trade.currency1AccountId.not.exists",
            "type": "string"
          },
          "message": {
            "description": "Unable to find currency1 account ${trade.currency1AccountId}.",
            "example": "Unable to find currency1 account ${trade.currency1AccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderFeeNotFound": {
        "properties": {
          "errorCode": { "description": "trade.feeAccount", "example": "trade.feeAccount", "type": "string" },
          "message": {
            "description": "Unable to find fee account ${trade.feeAccountId}.",
            "example": "Unable to find fee account ${trade.feeAccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderFeeIncompatible": {
        "properties": {
          "errorCode": {
            "description": "trade.currency.fee",
            "example": "trade.currency.fee",
            "type": "string"
          },
          "message": {
            "description": "Incompatible currencies for currency1 and fee account.",
            "example": "Incompatible currencies for currency1 and fee account.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency1Frozen": {
        "properties": {
          "errorCode": {
            "description": "trade.currency1AccountId.frozen",
            "example": "trade.currency1AccountId.frozen",
            "type": "string"
          },
          "message": {
            "description": "Currency1 account ${trade.currency1AccountId} is frozen, unable to perform trade.",
            "example": "Currency1 account ${trade.currency1AccountId} is frozen, unable to perform trade.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency1CustomerDisabled": {
        "properties": {
          "errorCode": {
            "description": "trade.currency1AccountId.customer.disabled",
            "example": "trade.currency1AccountId.customer.disabled",
            "type": "string"
          },
          "message": {
            "description": "Currency1 account's customer ${currency1Account.customerId} is disabled, unable to perform exchange trade.",
            "example": "Currency1 account's customer ${currency1Account.customerId} is disabled, unable to perform exchange trade.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency2NotFound": {
        "properties": {
          "errorCode": {
            "description": "trade.currency2AccountId.not.exists",
            "example": "trade.currency2AccountId.not.exists",
            "type": "string"
          },
          "message": {
            "description": "Unable to find currency2 account ${trade.currency2AccountId}.",
            "example": "Unable to find currency2 account ${trade.currency2AccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency2Frozen": {
        "properties": {
          "errorCode": {
            "description": "trade.currency2AccountId.frozen",
            "example": "trade.currency2AccountId.frozen",
            "type": "string"
          },
          "message": {
            "description": "Currency2 account ${trade.currency2AccountId} is frozen, unable to perform trade.",
            "example": "Currency2 account ${trade.currency2AccountId} is frozen, unable to perform trade.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency2CustomerDisabled": {
        "properties": {
          "errorCode": {
            "description": "trade.currency2AccountId.customer.disabled",
            "example": "trade.currency2AccountId.customer.disabled",
            "type": "string"
          },
          "message": {
            "description": "Currency2 account's customer ${currency2Account.customerId} is disabled, unable to perform exchange trade.",
            "example": "Currency2 account's customer ${currency2Account.customerId} is disabled, unable to perform exchange trade.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency1Pair": {
        "properties": {
          "errorCode": {
            "description": "trade.currency1.pair",
            "example": "trade.currency1.pair",
            "type": "string"
          },
          "message": {
            "description": "Incompatible currencies for currency1 account ${trade.currency1AccountId} and trading pair.",
            "example": "Incompatible currencies for currency1 account ${trade.currency1AccountId} and trading pair.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency2Pair": {
        "properties": {
          "errorCode": {
            "description": "trade.currency2.pair",
            "example": "trade.currency2.pair",
            "type": "string"
          },
          "message": {
            "description": "Incompatible currencies for currency2 account ${trade.currency2AccountId} and trading pair.",
            "example": "Incompatible currencies for currency2 account ${trade.currency2AccountId} and trading pair.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency1Balance": {
        "properties": {
          "errorCode": {
            "description": "trade.currency1.balance",
            "example": "trade.currency1.balance",
            "type": "string"
          },
          "message": {
            "description": "Insufficient balance on currency1 account ${trade.currency1AccountId}.",
            "example": "Insufficient balance on currency1 account ${trade.currency1AccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OrderCurrency2Balance": {
        "properties": {
          "errorCode": {
            "description": "trade.currency2.balance",
            "example": "trade.currency2.balance",
            "type": "string"
          },
          "message": {
            "description": "Insufficient balance on currency2 account ${trade.currency2AccountId}.",
            "example": "Insufficient balance on currency2 account ${trade.currency2AccountId}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error500": {
        "properties": {
          "message": {
            "example": "Internal server error",
            "description": "Internal server error",
            "type": "string"
          },
          "statusCode": { "example": 500, "description": "500", "type": "number" }
        },
        "required": ["statusCode", "message"],
        "type": "object"
      },
      "Error403": {
        "properties": {
          "message": { "example": "Forbidden", "description": "Forbidden", "type": "string" },
          "statusCode": { "example": 403, "description": "403", "type": "number" }
        },
        "required": ["statusCode", "message"],
        "type": "object"
      },
      "Error401": {
        "properties": {
          "message": { "example": "Unauthorized", "description": "Unauthorized", "type": "string" },
          "statusCode": { "example": 401, "description": "401", "type": "number" }
        },
        "required": ["statusCode", "message"],
        "type": "object"
      },
      "FeeETH": {
        "type": "object",
        "required": ["gasLimit", "gasPrice"],
        "properties": {
          "gasLimit": {
            "type": "number",
            "description": "Gas limit for transaction in gas price.",
            "example": 40000
          },
          "gasPrice": { "type": "number", "description": "Gas price in Gwei.", "example": 20 }
        }
      },
      "FeeBtc": {
        "type": "object",
        "required": ["fast", "medium", "slow"],
        "properties": {
          "fast": {
            "type": "string",
            "description": "Transaction fee in BTC|LTC to be paid, if transaction should be included in next 1-2 blocks.",
            "example": "0.006584"
          },
          "medium": {
            "type": "string",
            "description": "Transaction fee in BTC|LTC to be paid, if transaction should be included in next 5-6 blocks.",
            "example": "0.004584"
          },
          "slow": {
            "type": "string",
            "description": "Transaction fee in BTC|LTC to be paid, if transaction should be included in next 7+ blocks.",
            "example": "0.002584"
          }
        }
      },
      "EstimateFee": {
        "type": "object",
        "required": ["chain", "type"],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": ["CELO", "ETH", "BSC", "XDC", "ONE", "MATIC", "KLAY"]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "DEPLOY_ERC20",
              "DEPLOY_NFT",
              "MINT_NFT",
              "BURN_NFT",
              "TRANSFER_NFT",
              "TRANSFER_ERC20",
              "DEPLOY_AUCTION",
              "DEPLOY_MARKETPLACE"
            ]
          },
          "sender": {
            "type": "string",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "description": "Sender address, if type is TRANSFER_ERC20"
          },
          "recipient": {
            "description": "Blockchain address to send assets, if type is TRANSFER_ERC20",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "contractAddress": {
            "description": "Contract address of ERC20 token, if type is TRANSFER_ERC20",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in ERC20, if type is TRANSFER_ERC20",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        }
      },
      "EstimateFeeDeployCustodialWallet": {
        "type": "object",
        "required": ["chain", "type", "batchCount"],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": ["CELO", "ETH", "BSC", "XDC", "ONE", "MATIC", "KLAY"]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": ["DEPLOY_CUSTODIAL_WALLET_BATCH"]
          },
          "batchCount": {
            "description": "Number of addresses to create",
            "example": 10,
            "minimum": 1,
            "maximum": 300,
            "type": "number"
          }
        }
      },
      "EstimateFeeBatchMintNft": {
        "type": "object",
        "required": ["chain", "type", "sender", "recipients", "tokenIds", "urls"],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": ["CELO", "ETH", "BSC", "XDC", "ONE", "MATIC", "KLAY"]
          },
          "type": { "type": "string", "description": "Type of transaction", "enum": ["MINT_NFT_BATCH"] },
          "sender": {
            "type": "string",
            "maxLength": 42,
            "minLength": 43,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "description": "Address of the minter"
          },
          "recipients": {
            "type": "array",
            "description": "Blockchain addresses to mint tokens to",
            "items": {
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
              "maxLength": 42,
              "minLength": 43,
              "type": "string"
            }
          },
          "contractAddress": {
            "description": "Contract address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 43,
            "type": "string"
          },
          "tokenIds": {
            "type": "array",
            "description": "Token IDs",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "urls": {
            "type": "array",
            "description": "Metadata URLs",
            "items": {
              "example": "ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          }
        }
      },
      "EstimateFeeTransferFromCustodial": {
        "type": "object",
        "required": [
          "chain",
          "type",
          "sender",
          "recipient",
          "contractAddress",
          "custodialAddress",
          "amount",
          "tokenType"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": ["CELO", "ETH", "BSC", "XDC", "KLAY", "ONE", "MATIC"]
          },
          "type": { "type": "string", "description": "Type of transaction", "enum": ["TRANSFER_CUSTODIAL"] },
          "sender": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address"
          },
          "recipient": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "contractAddress": {
            "description": "Contract address of the token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "custodialAddress": {
            "description": "Contract address of custodial wallet contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in native asset, ERC20 or ERC1155",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenType": {
            "description": "Type of the token to transfer from gas pump wallet. 0 - ERC20, 1 - ERC721, 2 - ERC1155, 3 - native asset",
            "example": 0,
            "type": "number",
            "minimum": 0,
            "maximum": 3
          }
        }
      },
      "OffchainEstimateFee": {
        "type": "object",
        "required": ["senderAccountId", "address", "amount"],
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          }
        }
      },
      "EstimateFeeFromAddress": {
        "type": "object",
        "required": ["chain", "type", "fromAddress", "to"],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": ["BTC", "LTC"]
          },
          "type": { "type": "string", "description": "Type of transaction", "enum": ["TRANSFER"] },
          "fromAddress": {
            "description": "Array of addresses. Tatum will automatically scan last 100 transactions for each address and will use all of the unspent values. We advise to use this option if you have 1 address per 1 transaction only.",
            "type": "array",
            "items": {
              "type": "string",
              "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS",
              "minimum": 30,
              "maximum": 50
            }
          },
          "to": {
            "description": "Array of addresses and values to send bitcoins to. Values must be set in BTC. Difference between from and to is transaction fee.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "Destination address.",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "Amount to be sent, in BTC.",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          }
        }
      },
      "EstimateFeeFromUTXO": {
        "type": "object",
        "required": ["chain", "type", "fromUTXO", "to"],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": ["BTC", "LTC"]
          },
          "type": { "type": "string", "description": "Type of transaction", "enum": ["TRANSFER"] },
          "fromUTXO": {
            "description": "Array of transaction hashes, index of UTXO in it and corresponding private keys. Use this option if you want to calculate amount to send manually. Either fromUTXO or fromAddress must be present.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["txHash", "index"],
              "properties": {
                "txHash": {
                  "description": "Transaction hash of the UTXO to be spent.",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "Index of the UTXO to be spent.",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                }
              }
            }
          },
          "to": {
            "description": "Array of addresses and values to send bitcoins to. Values must be set in BTC. Difference between from and to is transaction fee.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["address", "value"],
              "properties": {
                "address": {
                  "description": "Destination address.",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "Amount to be sent, in BTC.",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          }
        }
      },
      "MarketValue": {
        "description": "FIAT value of transaction.",
        "properties": {
          "amount": {
            "description": "Value of transaction in given base pair.",
            "example": "1235.56",
            "type": "string"
          },
          "currency": {
            "description": "Base pair.",
            "example": "EUR",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "type": "string"
          },
          "sourceDate": {
            "description": "Date of validity of rate in UTC.",
            "example": 1572031674384,
            "type": "number"
          },
          "source": { "description": "Source of base pair.", "example": "fixer.io", "type": "string" }
        },
        "type": "object",
        "required": ["amount", "currency", "sourceDate", "source"]
      },
      "ExchangeRate": {
        "description": "FIAT value in EURO of the FIAT or crypto asset.",
        "properties": {
          "id": {
            "description": "FIAT or crypto asset.",
            "example": "BTC",
            "type": "string",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "value": {
            "description": "FIAT value of the asset in given base pair.",
            "example": "1235.56",
            "type": "string"
          },
          "basePair": {
            "description": "Base pair.",
            "example": "EUR",
            "default": "EUR",
            "type": "string",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ]
          },
          "timestamp": {
            "description": "Date of validity of rate in UTC.",
            "example": 1572031674384,
            "type": "number"
          },
          "source": { "description": "Source of base pair.", "example": "fixer.io", "type": "string" }
        },
        "type": "object",
        "required": ["id", "value", "basePair", "timestamp", "source"]
      },
      "Object": { "type": "object" },
      "Consumption": {
        "type": "object",
        "properties": {
          "day": {
            "type": "string",
            "description": "The date in the MM/DD/YYYY format",
            "example": "10/25/2020"
          },
          "usage": {
            "type": "number",
            "description": "The number of credits used on the specified day",
            "example": 123
          }
        }
      },
      "PrivKey": {
        "type": "object",
        "properties": {
          "key": {
            "description": "Generated private key.",
            "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
            "type": "string"
          }
        }
      },
      "PrivKeyRequest": {
        "type": "object",
        "properties": {
          "index": {
            "description": "Derivation index of private key to generate.",
            "example": 0,
            "maximum": 2147483647,
            "type": "integer"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key from.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          }
        },
        "required": ["mnemonic", "index"]
      },
      "EthBalance": {
        "type": "object",
        "properties": { "balance": { "type": "string", "description": "Balance in ETH", "example": "10.52" } }
      },
      "Transaction": {
        "properties": {
          "accountId": {
            "description": "Source account - source of transaction(s)",
            "example": "5e6645712b55823de7ea82f1",
            "type": "string"
          },
          "counterAccountId": {
            "description": "Counter account - transaction(s) destination account. In case of blockchain recipient, this is addess of blockchain account.",
            "example": "5e6645712b55823de7ea82f1",
            "type": "string"
          },
          "currency": { "description": "Transaction currency", "example": "BTC", "type": "string" },
          "amount": { "description": "Amount in account's currency", "example": "0.1", "type": "string" },
          "anonymous": {
            "description": "Whether the transaction is anonymous. If true, counter account owner does not see source account.",
            "example": false,
            "type": "boolean"
          },
          "created": {
            "description": "Time in UTC of transaction.",
            "example": 1572031674384,
            "type": "number"
          },
          "marketValue": { "$ref": "#/components/schemas/MarketValue" },
          "operationType": {
            "description": "Type of operation.",
            "enum": [
              "PAYMENT",
              "WITHDRAWAL",
              "BLOCKCHAIN_TRANSACTION",
              "EXCHANGE",
              "FAILED",
              "DEPOSIT",
              "MINT",
              "REVOKE"
            ],
            "example": "PAYMENT",
            "type": "string"
          },
          "transactionType": {
            "description": "Type of payment.",
            "enum": [
              "FAILED",
              "DEBIT_PAYMENT",
              "CREDIT_PAYMENT",
              "CREDIT_DEPOSIT",
              "DEBIT_WITHDRAWAL",
              "CANCEL_WITHDRAWAL",
              "DEBIT_OUTGOING_PAYMENT",
              "CREDIT_INCOMING_PAYMENT",
              "EXCHANGE_BUY",
              "EXCHANGE_SELL"
            ],
            "example": "CREDIT_PAYMENT",
            "type": "string"
          },
          "reference": {
            "description": "Transaction internal reference - unique identifier within Tatum ledger. In order of failure, use this value to search for problems.",
            "example": "5e6be8e9e6aa436299950c41",
            "type": "string"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible for sender.",
            "example": "Sender note",
            "type": "string"
          },
          "recipientNote": {
            "description": "Note visible for both sender and recipient.",
            "example": "Private note",
            "type": "string"
          },
          "paymentId": {
            "description": "Payment ID defined in payment order by sender.",
            "example": "65426",
            "type": "string"
          },
          "attr": {
            "example": "123",
            "description": "Present only for operationType WITHDRAWAL and XLM / XRP based accounts it represents message or destinationTag of the recipient, if present.",
            "type": "string"
          },
          "address": {
            "type": "string",
            "description": "For operationType DEPOSIT it represents address, on which was deposit credited for the account.",
            "example": "qrppgud79n5h5ehqt9s7x8uc82pcag82es0w9tada0"
          },
          "txId": {
            "type": "string",
            "description": "For operationType DEPOSIT, BLOCKCHAIN_TRANSACTION it represents transaction id, for which deposit occured.",
            "example": "c6c176e3f6705596d58963f0ca79b34ffa5b78874a65df9c974e22cf86a7ba67"
          }
        },
        "type": "object",
        "required": [
          "accountId",
          "reference",
          "anonymous",
          "amount",
          "marketValue",
          "created",
          "operationType",
          "transactionType",
          "currency"
        ]
      },
      "TransactionFilter": {
        "properties": {
          "id": {
            "description": "Account ID - source of transaction(s).",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "counterAccount": {
            "description": "Counter account - transaction(s) destination account.",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "from": {
            "description": "Starting date to search for transactions from in UTC millis. If not present, search all history.",
            "example": 1571833231000,
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "to": {
            "description": "Date until to search for transactions in UTC millis. If not present, search up till now.",
            "example": 1571833231000,
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "currency": {
            "description": "Currency of the transactions.",
            "example": "BTC",
            "minLength": 1,
            "maxLength": 50,
            "type": "string"
          },
          "amount": {
            "type": "array",
            "description": "Amount of the transaction. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "currencies": {
            "description": "List of currencies of the transactions.",
            "type": "array",
            "items": { "example": "BTC", "minLength": 1, "maxLength": 50, "type": "string" }
          },
          "transactionType": {
            "description": "Type of payment",
            "enum": [
              "FAILED",
              "DEBIT_PAYMENT",
              "CREDIT_PAYMENT",
              "CREDIT_DEPOSIT",
              "DEBIT_WITHDRAWAL",
              "CANCEL_WITHDRAWAL",
              "DEBIT_OUTGOING_PAYMENT",
              "EXCHANGE_BUY",
              "EXCHANGE_SELL",
              "DEBIT_TRANSACTION",
              "CREDIT_INCOMING_PAYMENT"
            ]
          },
          "transactionTypes": {
            "description": "Types of payment",
            "type": "array",
            "items": {
              "type": "string",
              "example": "CREDIT_PAYMENT",
              "enum": [
                "FAILED",
                "DEBIT_PAYMENT",
                "CREDIT_PAYMENT",
                "CREDIT_DEPOSIT",
                "DEBIT_WITHDRAWAL",
                "CANCEL_WITHDRAWAL",
                "DEBIT_OUTGOING_PAYMENT",
                "EXCHANGE_BUY",
                "EXCHANGE_SELL",
                "DEBIT_TRANSACTION",
                "CREDIT_INCOMING_PAYMENT"
              ]
            }
          },
          "opType": {
            "description": "Type of operation",
            "enum": [
              "PAYMENT",
              "WITHDRAWAL",
              "BLOCKCHAIN_TRANSACTION",
              "EXCHANGE",
              "FAILED",
              "DEPOSIT",
              "MINT",
              "REVOKE"
            ],
            "example": "PAYMENT",
            "type": "string"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Payment ID defined in payment order by sender.",
            "example": "65426",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "recipientNote": {
            "description": "Recipient note defined in payment order by sender.",
            "example": "65426",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Sender note defined in payment order by sender.",
            "example": "65426",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["id"],
        "type": "object"
      },
      "TransactionFilterCustomer": {
        "properties": {
          "id": {
            "description": "Customer internal ID to search for.",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "account": {
            "description": "Source account - source of transaction(s).",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "counterAccount": {
            "description": "Counter account - transaction(s) destination account.",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "currency": {
            "description": "Currency of the transactions.",
            "example": "BTC",
            "minLength": 1,
            "maxLength": 50,
            "type": "string"
          },
          "from": {
            "description": "Starting date to search for transactions from in UTC millis. If not present, search all history.",
            "example": 1571833231000,
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "to": {
            "description": "Date until to search for transactions in UTC millis. If not present, search up till now.",
            "example": 1571833231000,
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "amount": {
            "type": "array",
            "description": "Amount of the transaction. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "currencies": {
            "description": "List of currencies of the transactions.",
            "type": "array",
            "items": { "example": "BTC", "minLength": 1, "maxLength": 50, "type": "string" }
          },
          "transactionType": {
            "description": "Type of payment",
            "enum": [
              "FAILED",
              "DEBIT_PAYMENT",
              "CREDIT_PAYMENT",
              "CREDIT_DEPOSIT",
              "DEBIT_WITHDRAWAL",
              "CANCEL_WITHDRAWAL",
              "DEBIT_OUTGOING_PAYMENT",
              "EXCHANGE_BUY",
              "EXCHANGE_SELL",
              "DEBIT_TRANSACTION",
              "CREDIT_INCOMING_PAYMENT"
            ]
          },
          "transactionTypes": {
            "description": "Types of payment",
            "type": "array",
            "items": {
              "type": "string",
              "example": "CREDIT_PAYMENT",
              "enum": [
                "FAILED",
                "DEBIT_PAYMENT",
                "CREDIT_PAYMENT",
                "CREDIT_DEPOSIT",
                "DEBIT_WITHDRAWAL",
                "CANCEL_WITHDRAWAL",
                "DEBIT_OUTGOING_PAYMENT",
                "EXCHANGE_BUY",
                "EXCHANGE_SELL",
                "DEBIT_TRANSACTION",
                "CREDIT_INCOMING_PAYMENT"
              ]
            }
          },
          "opType": {
            "description": "Type of operation.",
            "enum": [
              "PAYMENT",
              "WITHDRAWAL",
              "BLOCKCHAIN_TRANSACTION",
              "EXCHANGE",
              "FAILED",
              "DEPOSIT",
              "MINT",
              "REVOKE"
            ],
            "example": "PAYMENT",
            "type": "string"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Payment ID defined in payment order by sender.",
            "example": "65426",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "recipientNote": {
            "description": "Recipient note defined in payment order by sender.",
            "example": "65426",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Sender note defined in payment order by sender.",
            "example": "65426",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["id"],
        "type": "object"
      },
      "TransactionFilterLedger": {
        "properties": {
          "account": {
            "description": "Source account - source of transaction(s).",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "counterAccount": {
            "description": "Counter account - transaction(s) destination account.",
            "example": "5e6be8e9e6aa436299950c41",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "currency": {
            "description": "Currency of the transactions.",
            "example": "BTC",
            "minLength": 1,
            "maxLength": 50,
            "type": "string"
          },
          "from": {
            "description": "Starting date to search for transactions from in UTC millis. If not present, search all history.",
            "example": 1571833231000,
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "amount": {
            "type": "array",
            "description": "Amount of the transaction. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "currencies": {
            "description": "List of currencies of the transactions.",
            "type": "array",
            "items": { "example": "BTC", "minLength": 1, "maxLength": 50, "type": "string" }
          },
          "transactionType": {
            "description": "Type of payment",
            "enum": [
              "FAILED",
              "DEBIT_PAYMENT",
              "CREDIT_PAYMENT",
              "CREDIT_DEPOSIT",
              "DEBIT_WITHDRAWAL",
              "CANCEL_WITHDRAWAL",
              "DEBIT_OUTGOING_PAYMENT",
              "EXCHANGE_BUY",
              "EXCHANGE_SELL",
              "DEBIT_TRANSACTION",
              "CREDIT_INCOMING_PAYMENT"
            ]
          },
          "transactionTypes": {
            "description": "Types of payment",
            "type": "array",
            "items": {
              "type": "string",
              "example": "CREDIT_PAYMENT",
              "enum": [
                "FAILED",
                "DEBIT_PAYMENT",
                "CREDIT_PAYMENT",
                "CREDIT_DEPOSIT",
                "DEBIT_WITHDRAWAL",
                "CANCEL_WITHDRAWAL",
                "DEBIT_OUTGOING_PAYMENT",
                "EXCHANGE_BUY",
                "EXCHANGE_SELL",
                "DEBIT_TRANSACTION",
                "CREDIT_INCOMING_PAYMENT"
              ]
            }
          },
          "opType": {
            "description": "Type of operation.",
            "enum": [
              "PAYMENT",
              "WITHDRAWAL",
              "BLOCKCHAIN_TRANSACTION",
              "EXCHANGE",
              "FAILED",
              "DEPOSIT",
              "MINT",
              "REVOKE"
            ],
            "example": "PAYMENT",
            "type": "string"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Payment ID defined in payment order by sender.",
            "example": "65426",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "recipientNote": {
            "description": "Recipient note defined in payment order by sender.",
            "example": "65426",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Sender note defined in payment order by sender.",
            "example": "65426",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "to": {
            "description": "Date until to search for transactions in UTC millis. If not present, search up till now.",
            "example": 1571833231000,
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "TransactionResult": {
        "properties": {
          "reference": {
            "description": "Transaction internal reference - unique identifier within Tatum ledger. In order of failure, use this value to search for problems.",
            "example": "0c64cc04-5412-4e57-a51c-ee5727939bcb",
            "type": "string"
          }
        },
        "type": "object"
      },
      "BatchTransactionResult": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "reference": {
              "description": "Transaction internal reference - unique identifier within Tatum ledger. In order of failure, use this value to search for problems.",
              "example": "0c64cc04-5412-4e57-a51c-ee5727939bcb",
              "type": "string"
            }
          }
        }
      },
      "TransferBnbBlockchain": {
        "type": "object",
        "properties": {
          "to": {
            "description": "Blockchain address to send assets.",
            "example": "tbnb138u9djee6fwphhd2a3628q2h0j5w97yx48zqex",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Binance Blockchain Account.",
            "enum": ["BNB"],
            "example": "BNB",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in BNB.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
            "description": "Private key of sender address."
          },
          "message": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Message to recipient.",
            "example": "Message to recipient",
            "type": "string"
          }
        },
        "required": ["to", "amount", "fromPrivateKey", "currency"]
      },
      "TransferBnbBlockchainKMS": {
        "type": "object",
        "properties": {
          "to": {
            "description": "Blockchain address to send assets.",
            "example": "tbnb138u9djee6fwphhd2a3628q2h0j5w97yx48zqex",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Binance Blockchain Account.",
            "enum": ["BNB"],
            "example": "BNB",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in BNB.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Signature hash of the mnemonic, which will be used to sign transactions locally.\nAll signature Ids should be present, which might be used to sign transaction.\n"
          },
          "fromAddress": {
            "description": "Blockchain address to send from",
            "example": "tbnb1q82g2h9q0kfe7sysnj5w7nlak92csfjztymp39",
            "maxLength": 50,
            "minLength": 42,
            "type": "string"
          },
          "message": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Message to recipient.",
            "example": "Message to recipient",
            "type": "string"
          }
        },
        "required": ["to", "amount", "signatureId", "fromAddress", "currency"]
      },
      "TransferLtcMnemonic": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.0005 LTC is used. Minimum fee is 0.00001 LTC.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic seed - usually 12-24 words with access to whole wallet.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "mnemonic", "xpub"],
        "type": "object"
      },
      "TransferLtcKeyPair": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.0005 LTC is used. Minimum fee is 0.00001 LTC.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "keyPair": {
            "description": "Array of assigned blockchain addresses with their private keys.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "Blockchain address assigned to account withdrawal is made from.",
                  "maxLength": 50,
                  "minLength": 30
                },
                "privateKey": {
                  "type": "string",
                  "description": "Private key of blockchain address.",
                  "maxLength": 52,
                  "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
                  "minLength": 52
                }
              }
            }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "keyPair", "attr"],
        "type": "object"
      },
      "TransferLtcKMS": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.0005 LTC is used. Minimum fee is 0.00001 LTC.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Signature hash of the mnemonic, which will be used to sign transactions locally.\nAll signature Ids should be present, which might be used to sign transaction.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "signatureId", "xpub"],
        "type": "object"
      },
      "TransferDogeMnemonic": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 1 DOGE is used.",
            "example": "1",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic seed - usually 12-24 words with access to whole wallet.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "mnemonic", "xpub"],
        "type": "object"
      },
      "TransferDogeKeyPair": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 1 DOGE is used.",
            "example": "1",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "keyPair": {
            "description": "Array of assigned blockchain addresses with their private keys.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "Blockchain address assigned to account withdrawal is made from.",
                  "maxLength": 50,
                  "minLength": 30
                },
                "privateKey": {
                  "type": "string",
                  "description": "Private key of blockchain address.",
                  "maxLength": 52,
                  "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
                  "minLength": 52
                }
              }
            }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "keyPair", "attr"],
        "type": "object"
      },
      "TransferDogeKMS": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 1 DOGE is used.",
            "example": "1",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Signature hash of the mnemonic, which will be used to sign transactions locally.\nAll signature Ids should be present, which might be used to sign transaction.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "signatureId", "xpub"],
        "type": "object"
      },
      "TransferBtcMnemonic": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.0005 BTC is used. Minimum fee is 0.00001 BTC.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic seed - usually 12-24 words with access to whole wallet.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "mnemonic", "xpub"],
        "type": "object"
      },
      "TransferBtcKeyPair": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.0005 BTC is used. Minimum fee is 0.00001 BTC.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "keyPair": {
            "description": "Array of assigned blockchain addresses with their private keys.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "Blockchain address assigned to account withdrawal is made from.",
                  "maxLength": 50,
                  "minLength": 30
                },
                "privateKey": {
                  "type": "string",
                  "description": "Private key of blockchain address.",
                  "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
                  "maxLength": 52,
                  "minLength": 52
                }
              }
            }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "keyPair", "attr"],
        "type": "object"
      },
      "TransferBtcKMS": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.0005 BTC is used. Minimum fee is 0.00001 BTC.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Signature hash of the mnemonic, which will be used to sign transactions locally.\nAll signature Ids should be present, which might be used to sign transaction.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "signatureId", "xpub"],
        "type": "object"
      },
      "TransferBchMnemonic": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.00005 BCH is used.",
            "example": "0.00005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic seed - usually 12-24 words with access to whole wallet.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "mnemonic", "xpub"],
        "type": "object"
      },
      "TransferBchKeyPair": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.00005 BCH is used.",
            "example": "0.00005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "keyPair": {
            "description": "Array of assigned blockchain addresses with their private keys.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "Blockchain address assigned to account withdrawal is made from.",
                  "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
                  "maxLength": 50,
                  "minLength": 30
                },
                "privateKey": {
                  "type": "string",
                  "description": "Private key of blockchain address.",
                  "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
                  "maxLength": 52,
                  "minLength": 52
                }
              }
            }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "keyPair", "attr"],
        "type": "object"
      },
      "TransferBchKMS": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "bitcoincash:qrd9khmeg4nqag3h5gzu8vjt537pm7le85lcauzez",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.00005 BCH is used.",
            "example": "0.00005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Signature hash of the mnemonic, which will be used to sign transactions locally.\nAll signature Ids should be present, which might be used to sign transaction.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 150,
            "minLength": 1,
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "signatureId", "xpub"],
        "type": "object"
      },
      "TransferErc20Blockchain": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "digits", "fromPrivateKey", "amount"]
      },
      "TransferErc20BlockchainKMS": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "signatureId", "digits", "amount"]
      },
      "CallSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "object" },
            "description": "Parameters of the method to be invoked."
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": { "$ref": "#/components/schemas/CustomFee" }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CustomFee": {
        "description": "Custom defined fee. If not present, it will be calculated automatically.",
        "type": "object",
        "required": ["gasLimit", "gasPrice"],
        "properties": {
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        }
      },
      "CallReadSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "object" },
            "description": "Parameters of the method to be invoked."
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "items": { "type": "object" },
            "description": "Parameters of the method to be invoked."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": { "$ref": "#/components/schemas/CustomFee" }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferErc721": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "tokenId", "fromPrivateKey"]
      },
      "GenerateMarketplace": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "KLAY", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "chain", "marketplaceFee", "fromPrivateKey"]
      },
      "GenerateMarketplaceCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "marketplaceFee", "chain", "feeCurrency", "fromPrivateKey"]
      },
      "GenerateMarketplaceKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "KLAY", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "chain", "marketplaceFee", "signatureId"]
      },
      "GenerateMarketplaceCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "marketplaceFee", "chain", "feeCurrency", "signatureId"]
      },
      "GenerateAuction": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "KLAY", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "auctionFee": {
            "type": "number",
            "description": "Percentage of the selling amount of the NFT asset. 100 - 1%",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "chain", "auctionFee", "fromPrivateKey"]
      },
      "GenerateAuctionCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "auctionFee": {
            "type": "number",
            "description": "Percentage of the selling amount of the NFT asset. 100 - 1%",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "auctionFee", "chain", "feeCurrency", "fromPrivateKey"]
      },
      "GenerateAuctionKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "KLAY", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "auctionFee": {
            "type": "number",
            "description": "Percentage of the selling amount of the NFT asset. 100 - 1%",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "chain", "auctionFee", "signatureId"]
      },
      "GenerateAuctionCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "auctionFee": {
            "type": "number",
            "description": "Percentage of the selling amount of the NFT asset. 100 - 1%",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["feeRecipient", "auctionFee", "chain", "feeCurrency", "signatureId"]
      },
      "GenerateMarketplaceTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "from", "feeRecipient", "marketplaceFee", "fromPrivateKey"]
      },
      "GenerateMarketplaceTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "from": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "from", "feeRecipient", "marketplaceFee", "signatureId"]
      },
      "SellAssetOnMarketplace": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter amount only in case of native currency cashback.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "price": {
            "description": "Price of the asset to sell. Marketplace fee will be obtained on top of this price.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "listingId",
          "seller",
          "price",
          "fromPrivateKey"
        ]
      },
      "SellAssetOnMarketplaceCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter amount only in case of native currency cashback.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "price": {
            "description": "Price of the asset to sell. Marketplace fee will be obtained on top of this price.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "listingId",
          "seller",
          "price",
          "feeCurrency",
          "fromPrivateKey"
        ]
      },
      "SellAssetOnMarketplaceKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter amount only in case of natiev currency cashback.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "price": {
            "description": "Price of the asset to sell. Marketplace fee will be obtained on top of this price.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "listingId",
          "seller",
          "price",
          "signatureId"
        ]
      },
      "SellAssetOnMarketplaceCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter amount only in case of natiev currency cashback.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "price": {
            "description": "Price of the asset to sell. Marketplace fee will be obtained on top of this price.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "listingId",
          "seller",
          "price",
          "feeCurrency",
          "signatureId"
        ]
      },
      "CreateAuction": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "ID of the auction. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "endedAt": {
            "description": "Last block, where auction accepts bids.",
            "example": 100000,
            "minimum": 0,
            "type": "number"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "id",
          "seller",
          "endedAt",
          "fromPrivateKey"
        ]
      },
      "CreateAuctionCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "ID of the auction. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "endedAt": {
            "description": "Last block, where auction accepts bids.",
            "example": 100000,
            "minimum": 0,
            "type": "number"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "id",
          "seller",
          "endedAt",
          "feeCurrency",
          "fromPrivateKey"
        ]
      },
      "CreateAuctionKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "ID of the auction. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "endedAt": {
            "description": "Last block, where auction accepts bids.",
            "example": 100000,
            "minimum": 0,
            "type": "number"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "id",
          "seller",
          "endedAt",
          "signatureId"
        ]
      },
      "CreateAuctionCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "seller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the seller of the NFT asset.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "ID of the auction. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "endedAt": {
            "description": "Last block, where auction accepts bids.",
            "example": 100000,
            "minimum": 0,
            "type": "number"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "id",
          "seller",
          "endedAt",
          "feeCurrency",
          "signatureId"
        ]
      },
      "SellAssetOnMarketplaceTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "nftAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "seller": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the seller of the NFT asset.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Optional address of the TRC20 token, which will be used as a selling currency of the NFT.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "price": {
            "description": "Price of the asset to sell. Marketplace fee will be obtained on top of this price.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": [
          "feeLimit",
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "listingId",
          "seller",
          "price",
          "fromPrivateKey"
        ]
      },
      "SellAssetOnMarketplaceTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nftAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the NFT asset to sell smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "seller": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the seller of the NFT asset.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Optional address of the TRC20 token, which will be used as a selling currency of the NFT.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "price": {
            "description": "Price of the asset to sell. Marketplace fee will be obtained on top of this price.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": [
          "feeLimit",
          "nftAddress",
          "chain",
          "contractAddress",
          "tokenId",
          "isErc721",
          "listingId",
          "seller",
          "price",
          "from",
          "signatureId"
        ]
      },
      "BuyAssetOnMarketplace": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "buyer": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 listing, it's possible to buy on behalf of someone else. This value is the address of the buyer, which should approve spending of the ERC20 tokens for the Marketplace contract. This could be used for a buying from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing.",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent for buying.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "listingId", "amount", "fromPrivateKey"]
      },
      "BuyAssetOnMarketplaceCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing.",
            "minLength": 1,
            "maxLength": 200
          },
          "buyer": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 listing, it's possible to buy on behalf of someone else. This value is the address of the buyer, which should approve spending of the ERC20 tokens for the Marketplace contract. This could be used for a buying from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent for buying.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "listingId", "amount", "feeCurrency", "fromPrivateKey"]
      },
      "BuyAssetOnMarketplaceKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "buyer": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 listing, it's possible to buy on behalf of someone else. This value is the address of the buyer, which should approve spending of the ERC20 tokens for the Marketplace contract. This could be used for a buying from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing.",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent for buying.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["nftAddress", "chain", "listingId", "amount", "signatureId", "contractAddress"]
      },
      "BuyAssetOnMarketplaceCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "buyer": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 listing, it's possible to buy on behalf of someone else. This value is the address of the buyer, which should approve spending of the ERC20 tokens for the Marketplace contract. This could be used for a buying from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing.",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent for buying.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "listingId", "amount", "feeCurrency", "signatureId"]
      },
      "ApproveNftSpending": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract - new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the ERC20 token, which is used for buying NFT asset from the marketplace.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "spender", "fromPrivateKey", "isErc721", "tokenId"]
      },
      "ApproveNftSpendingCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the ERC20 token, which is used for buying NFT asset from the marketplace.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract - new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "spender",
          "tokenId",
          "isErc721",
          "feeCurrency",
          "fromPrivateKey"
        ]
      },
      "ApproveNftSpendingKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the ERC20 token, which is used for buying NFT asset from the marketplace.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract - new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "chain", "spender", "tokenId", "isErc721", "signatureId"]
      },
      "ApproveNftSpendingCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the ERC20 token, which is used for buying NFT asset from the marketplace.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract - new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "isErc721": {
            "type": "boolean",
            "description": "True if asset is NFT of type ERC721, false if ERC1155.",
            "example": true
          },
          "tokenId": {
            "description": "ID of token, if transaction is for ERC-721 or ERC-1155.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "spender",
          "isErc721",
          "tokenId",
          "feeCurrency",
          "signatureId"
        ]
      },
      "BidOnAuction": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x487422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "bidder": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 auction, it's possible to bid on behalf of someone else. This value is the address of the bidder, which should approve spending of the ERC20 tokens for the Auction contract. This could be used for a bidding from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "bidValue": {
            "description": "Amount of the assets to be bid. This must include auction fee.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "id", "amount", "fromPrivateKey"]
      },
      "BidOnAuctionCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "bidder": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 auction, it's possible to bid on behalf of someone else. This value is the address of the bidder, which should approve spending of the ERC20 tokens for the Auction contract. This could be used for a bidding from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "bidValue": {
            "description": "Amount of the assets to be bid. This must include auction fee.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "id", "amount", "feeCurrency", "fromPrivateKey"]
      },
      "BidOnAuctionKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "bidder": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 auction, it's possible to bid on behalf of someone else. This value is the address of the bidder, which should approve spending of the ERC20 tokens for the Auction contract. This could be used for a bidding from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "bidValue": {
            "description": "Amount of the assets to be bid. This must include auction fee.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["nftAddress", "chain", "id", "amount", "signatureId"]
      },
      "BidOnAuctionCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the auction smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "bidder": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 auction, it's possible to bid on behalf of someone else. This value is the address of the bidder, which should approve spending of the ERC20 tokens for the Auction contract. This could be used for a bidding from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "bidValue": {
            "description": "Amount of the assets to be bid. This must include auction fee.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "id", "amount", "feeCurrency", "signatureId"]
      },
      "CancelOrSettleAuction": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "id", "amount", "fromPrivateKey"]
      },
      "CancelOrSettleAuctionCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "id", "amount", "feeCurrency", "fromPrivateKey"]
      },
      "CancelOrSettleAuctionKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["nftAddress", "chain", "id", "amount", "signatureId"]
      },
      "CancelOrSettleAuctionCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "id": { "type": "string", "description": "ID of the auction.", "minLength": 1, "maxLength": 200 },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "id", "feeCurrency", "signatureId"]
      },
      "BuyAssetOnMarketplaceTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Optional address of the TRC20 token, which will be used as a selling currency of the NFT.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "buyer": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 listing, it's possible to buy on behalf of someone else. This value is the address of the buyer, which should approve spending of the ERC20 tokens for the Marketplace contract. This could be used for a buying from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "listingId", "fromPrivateKey"]
      },
      "BuyAssetOnMarketplaceTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "buyer": {
            "maxLength": 42,
            "minLength": 42,
            "description": "In case of the ERC20 listing, it's possible to buy on behalf of someone else. This value is the address of the buyer, which should approve spending of the ERC20 tokens for the Marketplace contract. This could be used for a buying from the custodial wallet address.",
            "example": "0x587422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "erc20Address": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Optional address of the TRC20 token, which will be used as a selling currency of the NFT.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent. For ERC-721 tokens, enter 1.",
            "example": "1",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "listingId", "from", "signatureId"]
      },
      "UpdateFeeRecipient": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Recipient address of the marketplace fee.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "feeRecipient", "fromPrivateKey"]
      },
      "UpdateFeeRecipientCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Recipient address of the marketplace fee.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "feeRecipient", "feeCurrency", "fromPrivateKey"]
      },
      "UpdateFeeRecipientKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Recipient address of the marketplace fee.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["nftAddress", "chain", "feeRecipient", "signatureId", "contractAddress"]
      },
      "UpdateFeeRecipientCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "feeRecipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Recipient address of the marketplace fee.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "feeRecipient", "feeCurrency", "signatureId"]
      },
      "UpdateFeeRecipientTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "feeRecipient": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Recipient address of the marketplace fee.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "feeRecipient", "fromPrivateKey"]
      },
      "UpdateFeeRecipientTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "feeRecipient": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Recipient address of the marketplace fee.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "feeRecipient", "from", "signatureId"]
      },
      "UpdateFee": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "marketplaceFee", "fromPrivateKey"]
      },
      "UpdateFeeCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "marketplaceFee", "feeCurrency", "fromPrivateKey"]
      },
      "UpdateFeeKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["nftAddress", "chain", "marketplaceFee", "signatureId", "contractAddress"]
      },
      "UpdateFeeCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "marketplaceFee", "feeCurrency", "signatureId"]
      },
      "UpdateFeeTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "marketplaceFee", "fromPrivateKey"]
      },
      "UpdateFeeTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "marketplaceFee": {
            "type": "number",
            "description": "The percentage of the amount that an NFT was sold for that will be sent to the marketplace as a fee. To set the fee to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.",
            "example": 150,
            "minimum": 0,
            "maximum": 10000
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "marketplaceFee", "from", "signatureId"]
      },
      "CancelSellAssetOnMarketplace": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "listingId", "fromPrivateKey"]
      },
      "CancelSellAssetOnMarketplaceCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "listingId", "feeCurrency", "fromPrivateKey"]
      },
      "CancelSellAssetOnMarketplaceKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "KLAY", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["nftAddress", "chain", "listingId", "signatureId", "contractAddress"]
      },
      "CancelSellAssetOnMarketplaceCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of the marketplace smart contract.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "erc20Address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Optional address of the ERC20 token, which will be used as a selling currency of the NFT.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "listingId": {
            "type": "string",
            "description": "ID of the listing. It's up to the developer to generate unique ID",
            "minLength": 1,
            "maxLength": 200
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "listingId", "feeCurrency", "signatureId"]
      },
      "CancelSellAssetOnMarketplaceTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "erc20Address": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Optional address of the TRC20 token, which will be used as a selling currency of the NFT.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "listingId", "fromPrivateKey"]
      },
      "CancelSellAssetOnMarketplaceTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the marketplace smart contract.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of the recipient of the fee for the trade.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "erc20Address": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Optional address of the TRC20 token, which will be used as a selling currency of the NFT.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          }
        },
        "required": ["feeLimit", "chain", "contractAddress", "listingId", "from", "signatureId"]
      },
      "ApproveTransferCustodialWallet": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE", "XDC"],
            "example": "ETH",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that holds the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to allow the transfer of the asset from the gas pump address",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>2</code> for Multi Tokens (ERC-1155 or equivalent).",
            "example": 0,
            "enum": [0, 1, 2]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the asset to transfer",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token or Multi Token) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "spender", "fromPrivateKey"]
      },
      "ApproveTransferCustodialWalletCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that holds the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to allow the transfer of the asset from the gas pump address",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>2</code> for Multi Tokens (ERC-1155 or equivalent).",
            "example": 0,
            "enum": [0, 1, 2]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the asset to transfer",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token or Multi Token) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "feeCurrency", "spender", "fromPrivateKey"]
      },
      "ApproveTransferCustodialWalletCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that holds the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to allow the transfer of the asset from the gas pump address",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>2</code> for Multi Tokens (ERC-1155 or equivalent).",
            "example": 0,
            "enum": [0, 1, 2]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the asset to transfer",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token or Multi Token) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "feeCurrency", "spender", "signatureId"]
      },
      "ApproveTransferCustodialWalletKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE", "XDC"],
            "example": "ETH",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that holds the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to allow the transfer of the asset from the gas pump address",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>2</code> for Multi Tokens (ERC-1155 or equivalent).",
            "example": 0,
            "enum": [0, 1, 2]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the asset to transfer",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token or Multi Token) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "spender", "signatureId"]
      },
      "TransferCustodialWallet": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE", "XDC"],
            "example": "ETH",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address that receives the asset",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "example": 0,
            "enum": [0, 1, 2, 3]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "(Only if the asset is a fungible token, NFT, or Multi Token) The address of the token to transfer. Do not use if the asset is a native blockchain currency.",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token, Multi Token, or native blockchain currency) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token or native blockchain currency.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "recipient", "fromPrivateKey"]
      },
      "TransferCustodialWalletCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address that receives the asset",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "example": 0,
            "enum": [0, 1, 2, 3]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "(Only if the asset is a fungible token, NFT, or Multi Token) The address of the token to transfer. Do not use if the asset is a native blockchain currency.",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token, Multi Token, or native blockchain currency) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token or native blockchain currency.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "feeCurrency",
          "recipient",
          "fromPrivateKey"
        ]
      },
      "TransferCustodialWalletCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address that receives the asset",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "example": 0,
            "enum": [0, 1, 2, 3]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "(Only if the asset is a fungible token, NFT, or Multi Token) The address of the token to transfer. Do not use if the asset is a native blockchain currency.",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token, Multi Token, or native blockchain currency) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token or native blockchain currency.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "feeCurrency", "recipient", "signatureId"]
      },
      "TransferCustodialWalletKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE", "XDC"],
            "example": "ETH",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the asset",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address that receives the asset",
            "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "example": 0,
            "enum": [0, 1, 2, 3]
          },
          "tokenAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "(Only if the asset is a fungible token, NFT, or Multi Token) The address of the token to transfer. Do not use if the asset is a native blockchain currency.",
            "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token, Multi Token, or native blockchain currency) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is a Multi Token or NFT) The ID of the token to transfer. Do not use if the asset is a fungible token or native blockchain currency.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "recipient", "signatureId"]
      },
      "TransferCustodialWalletTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The gas pump address that transfers the asset",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "The gas pump address that transfers the assets in the Base58 format",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "recipient": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address that receives the asset",
            "example": "TYMcTVBz48okKLRczhwiDu22V6XG3yk6W9",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>3</code> for native blockchain currencies.",
            "example": 0,
            "enum": [0, 1, 3]
          },
          "tokenAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "(Only if the asset is a fungible token or NFT) The address of the token to transfer. Do not use if the asset is a native blockchain currency.",
            "example": "TYMG3ykLRczh6W9cTVBz48wiDu22V6XokK",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token or native blockchain currency) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is an NFT) The ID of the token to transfer. Do not use if the asset is a fungible token or native blockchain currency.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "The maximum amount to be paid as the gas fee (in TRX)",
            "example": 0.01
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "feeLimit",
          "from",
          "recipient",
          "signatureId"
        ]
      },
      "TransferCustodialWalletTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The gas pump address that transfers the asset",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "recipient": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address that receives the asset",
            "example": "TYMcTVBz48okKLRczhwiDu22V6XG3yk6W9",
            "type": "string"
          },
          "contractType": {
            "type": "number",
            "description": "The type of the asset to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>3</code> for native blockchain currencies.",
            "example": 0,
            "enum": [0, 1, 3]
          },
          "tokenAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "(Only if the asset is a fungible token or NFT) The address of the token to transfer. Do not use if the asset is a native blockchain currency.",
            "example": "TYMG3ykLRczh6W9cTVBz48wiDu22V6XokK",
            "type": "string"
          },
          "amount": {
            "description": "(Only if the asset is a fungible token or native blockchain currency) The amount of the asset to transfer. Do not use if the asset is an NFT.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenId": {
            "description": "(Only if the asset is an NFT) The ID of the token to transfer. Do not use if the asset is a fungible token or native blockchain currency.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "The maximum amount to be paid as the gas fee (in TRX)",
            "example": 0.01
          }
        },
        "required": ["custodialAddress", "chain", "contractType", "feeLimit", "recipient", "fromPrivateKey"]
      },
      "TransferCustodialWalletBatch": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE", "XDC"],
            "example": "ETH",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "type": "array",
            "description": "The blockchain address that receives the assets",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
              "type": "string"
            }
          },
          "contractType": {
            "type": "array",
            "description": "The type of the assets to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "items": { "type": "number", "example": 0, "enum": [0, 1, 2, 3] }
          },
          "tokenAddress": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, NFTs, or Multi Tokens, set this parameter to the array of the addresses of the tokens to transfer:<br/>\n<code>\"tokenAddress\": [\"0x782919AFc85eEA2cB736874225456bB5d3e242bA\",\"0x74225456bB5d3e242bA782919AFc85eEA2cB7368\",...,\"0x3e242bA78274225456bB52cB7368d919AFc85eEA\"]</code>\n</li>\n<li>\nIf the assets are a native blockchain currency, set this parameter to the array of zeros, a zero per currency:<br/>\n<code>\"tokenAddress\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
              "type": "string"
            }
          },
          "amount": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, Multi Tokens, or a native blockchain currency, set this parameter to the array of the amounts of the assets to transfer:<br/>\n<code>\"amount\": [\"100000\",\"15000\",...,\"250000\"]</code>\n</li>\n<li>\nIf the assets are NFTs, set this parameter to the array of zeros, a zero per NFT:<br/>\n<code>\"amount\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are Multi Tokens or NFTs, set this parameter to the array of the IDs of the tokens to transfer:<br/>\n<code>\"tokenId\": [\"12\",\"13\",...,\"24\"]</code>\n </li>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of zeros, a zero per fungible token/currency:<br/>\n<code>\"tokenId\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": { "example": "100000", "type": "string", "maxLength": 256 }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "tokenAddress",
          "amount",
          "tokenId",
          "recipient",
          "fromPrivateKey"
        ]
      },
      "TransferCustodialWalletBatchCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "type": "array",
            "description": "The blockchain address that receives the assets",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
              "type": "string"
            }
          },
          "contractType": {
            "type": "array",
            "description": "The type of the assets to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "items": { "type": "number", "example": 0, "enum": [0, 1, 2, 3] }
          },
          "tokenAddress": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, NFTs, or Multi Tokens, set this parameter to the array of the addresses of the tokens to transfer:<br/>\n<code>\"tokenAddress\": [\"0x782919AFc85eEA2cB736874225456bB5d3e242bA\",\"0x74225456bB5d3e242bA782919AFc85eEA2cB7368\",...,\"0x3e242bA78274225456bB52cB7368d919AFc85eEA\"]</code>\n</li>\n<li>\nIf the assets are a native blockchain currency, set this parameter to the array of zeros, a zero per currency:<br/>\n<code>\"tokenAddress\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
              "type": "string"
            }
          },
          "amount": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, Multi Tokens, or a native blockchain currency, set this parameter to the array of the amounts of the assets to transfer:<br/>\n<code>\"amount\": [\"100000\",\"15000\",...,\"250000\"]</code>\n</li>\n<li>\nIf the assets are NFTs, set this parameter to the array of zeros, a zero per NFT:<br/>\n<code>\"amount\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are Multi Tokens or NFTs, set this parameter to the array of the IDs of the tokens to transfer:<br/>\n<code>\"tokenId\": [\"12\",\"13\",...,\"24\"]</code>\n </li>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of zeros, a zero per fungible token/currency:<br/>\n<code>\"tokenId\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": { "example": "100000", "type": "string", "maxLength": 256 }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "tokenAddress",
          "amount",
          "tokenId",
          "feeCurrency",
          "recipient",
          "fromPrivateKey"
        ]
      },
      "TransferCustodialWalletBatchTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The gas pump address that transfers the assets",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "recipient": {
            "type": "array",
            "description": "The blockchain address that receives the assets",
            "items": {
              "maxLength": 34,
              "minLength": 34,
              "example": "TYMcTVBz48okKLRczhwiDu22V6XG3yk6W9",
              "type": "string"
            }
          },
          "contractType": {
            "type": "array",
            "description": "The type of the assets to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>3</code> for native blockchain currencies.",
            "items": { "type": "number", "example": 0, "enum": [0, 1, 3] }
          },
          "tokenAddress": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens or NFTs, set this parameter to the array of the addresses of the tokens to transfer:<br/>\n<code>\"tokenAddress\": [\"0x782919AFc85eEA2cB736874225456bB5d3e242bA\",\"0x74225456bB5d3e242bA782919AFc85eEA2cB7368\",...,\"0x3e242bA78274225456bB52cB7368d919AFc85eEA\"]</code>\n</li>\n<li>\nIf the assets are a native blockchain currency, set this parameter to the array of zeros, a zero per currency:<br/>\n<code>\"tokenAddress\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "maxLength": 34,
              "minLength": 34,
              "example": "TYMG3ykLRczh6W9cTVBz48wiDu22V6XokK",
              "type": "string"
            }
          },
          "amount": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of the amounts of the assets to transfer:<br/>\n<code>\"amount\": [\"100000\",\"15000\",...,\"250000\"]</code>\n</li>\n<li>\nIf the assets are NFTs, set this parameter to the array of zeros, a zero per NFT:<br/>\n<code>\"amount\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are NFTs, set this parameter to the array of the IDs of the tokens to transfer:<br/>\n<code>\"tokenId\": [\"12\",\"13\",...,\"24\"]</code>\n </li>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of zeros, a zero per fungible token/currency:<br/>\n<code>\"tokenId\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": { "example": "100000", "type": "string", "maxLength": 256 }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2648ce5080c2",
            "minLength": 64,
            "description": "The private key of the blockchain address that owns the gas pump address (\"master address\")"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "The maximum amount to be paid as the gas fee (in TRX)",
            "example": 0.01
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "tokenAddress",
          "amount",
          "tokenId",
          "feeLimit",
          "recipient",
          "fromPrivateKey"
        ]
      },
      "TransferCustodialWalletBatchCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "type": "array",
            "description": "The blockchain address that receives the assets",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
              "type": "string"
            }
          },
          "contractType": {
            "type": "array",
            "description": "The type of the assets to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "items": { "type": "number", "example": 0, "enum": [0, 1, 2, 3] }
          },
          "tokenAddress": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, NFTs, or Multi Tokens, set this parameter to the array of the addresses of the tokens to transfer:<br/>\n<code>\"tokenAddress\": [\"0x782919AFc85eEA2cB736874225456bB5d3e242bA\",\"0x74225456bB5d3e242bA782919AFc85eEA2cB7368\",...,\"0x3e242bA78274225456bB52cB7368d919AFc85eEA\"]</code>\n</li>\n<li>\nIf the assets are a native blockchain currency, set this parameter to the array of zeros, a zero per currency:<br/>\n<code>\"tokenAddress\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
              "type": "string"
            }
          },
          "amount": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, Multi Tokens, or a native blockchain currency, set this parameter to the array of the amounts of the assets to transfer:<br/>\n<code>\"amount\": [\"100000\",\"15000\",...,\"250000\"]</code>\n</li>\n<li>\nIf the assets are NFTs, set this parameter to the array of zeros, a zero per NFT:<br/>\n<code>\"amount\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are Multi Tokens or NFTs, set this parameter to the array of the IDs of the tokens to transfer:<br/>\n<code>\"tokenId\": [\"12\",\"13\",...,\"24\"]</code>\n </li>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of zeros, a zero per fungible token/currency:<br/>\n<code>\"tokenId\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": { "example": "100000", "type": "string", "maxLength": 256 }
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "tokenAddress",
          "amount",
          "tokenId",
          "feeCurrency",
          "recipient",
          "signatureId"
        ]
      },
      "TransferCustodialWalletBatchTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The gas pump address that transfers the assets",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh",
            "type": "string"
          },
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "The gas pump address that transfers the assets in the Base58 format",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "recipient": {
            "type": "array",
            "description": "The blockchain address that receives the assets",
            "items": {
              "maxLength": 34,
              "minLength": 34,
              "example": "TYMcTVBz48okKLRczhwiDu22V6XG3yk6W9",
              "type": "string"
            }
          },
          "contractType": {
            "type": "array",
            "description": "The type of the assets to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), or <code>3</code> for native blockchain currencies.",
            "items": { "type": "number", "example": 0, "enum": [0, 1, 3] }
          },
          "tokenAddress": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens or NFTs, set this parameter to the array of the addresses of the tokens to transfer:<br/>\n<code>\"tokenAddress\": [\"0x782919AFc85eEA2cB736874225456bB5d3e242bA\",\"0x74225456bB5d3e242bA782919AFc85eEA2cB7368\",...,\"0x3e242bA78274225456bB52cB7368d919AFc85eEA\"]</code>\n</li>\n<li>\nIf the assets are a native blockchain currency, set this parameter to the array of zeros, a zero per currency:<br/>\n<code>\"tokenAddress\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "maxLength": 34,
              "minLength": 34,
              "example": "TYMG3ykLRczh6W9cTVBz48wiDu22V6XokK",
              "type": "string"
            }
          },
          "amount": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of the amounts of the assets to transfer:<br/>\n<code>\"amount\": [\"100000\",\"15000\",...,\"250000\"]</code>\n</li>\n<li>\nIf the assets are NFTs, set this parameter to the array of zeros, a zero per NFT:<br/>\n<code>\"amount\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are NFTs, set this parameter to the array of the IDs of the tokens to transfer:<br/>\n<code>\"tokenId\": [\"12\",\"13\",...,\"24\"]</code>\n </li>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of zeros, a zero per fungible token/currency:<br/>\n<code>\"tokenId\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": { "example": "100000", "type": "string", "maxLength": 256 }
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "The maximum amount to be paid as the gas fee (in TRX)",
            "example": 0.01
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "tokenAddress",
          "amount",
          "tokenId",
          "feeLimit",
          "from",
          "recipient",
          "signatureId"
        ]
      },
      "TransferCustodialWalletBatchKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE", "XDC"],
            "example": "ETH",
            "type": "string"
          },
          "custodialAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The gas pump address that transfers the assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "recipient": {
            "type": "array",
            "description": "The blockchain address that receives the assets",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0xe242bA5456b782919AFc85687422eEA2cB73B5d3",
              "type": "string"
            }
          },
          "contractType": {
            "type": "array",
            "description": "The type of the assets to transfer. Set <code>0</code> for fungible tokens (ERC-20 or equivalent), <code>1</code> for NFTs (ERC-721 or equivalent), <code>2</code> for Multi Tokens (ERC-1155 or equivalent), or <code>3</code> for native blockchain currencies.",
            "items": { "type": "number", "example": 0, "enum": [0, 1, 2, 3] }
          },
          "tokenAddress": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, NFTs, or Multi Tokens, set this parameter to the array of the addresses of the tokens to transfer:<br/>\n<code>\"tokenAddress\": [\"0x782919AFc85eEA2cB736874225456bB5d3e242bA\",\"0x74225456bB5d3e242bA782919AFc85eEA2cB7368\",...,\"0x3e242bA78274225456bB52cB7368d919AFc85eEA\"]</code>\n</li>\n<li>\nIf the assets are a native blockchain currency, set this parameter to the array of zeros, a zero per currency:<br/>\n<code>\"tokenAddress\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "example": "0x782919AFc85eEA2cB736874225456bB5d3e242bA",
              "type": "string"
            }
          },
          "amount": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are fungible tokens, Multi Tokens, or a native blockchain currency, set this parameter to the array of the amounts of the assets to transfer:<br/>\n<code>\"amount\": [\"100000\",\"15000\",...,\"250000\"]</code>\n</li>\n<li>\nIf the assets are NFTs, set this parameter to the array of zeros, a zero per NFT:<br/>\n<code>\"amount\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "<ul>\n<li>\nIf the assets are Multi Tokens or NFTs, set this parameter to the array of the IDs of the tokens to transfer:<br/>\n<code>\"tokenId\": [\"12\",\"13\",...,\"24\"]</code>\n </li>\n<li>\nIf the assets are fungible tokens or a native blockchain currency, set this parameter to the array of zeros, a zero per fungible token/currency:<br/>\n<code>\"tokenId\": [\"0\",\"0\",...,\"0\"]</code>\n</li>\n</ul>\n",
            "items": { "example": "100000", "type": "string", "maxLength": 256 }
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that owns the gas pump address key (\"master address\")"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": [
          "custodialAddress",
          "chain",
          "contractType",
          "tokenAddress",
          "amount",
          "tokenId",
          "recipient",
          "signatureId"
        ]
      },
      "TransferErc721KMS": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "signatureId", "tokenId"]
      },
      "KmsSignatureIds": {
        "type": "object",
        "properties": {
          "signatureIds": {
            "description": "List of the signature Ids to be used to sign transactions.",
            "example": ["6d78dad2-518f-4e76-8255-8f1df0de6886", "26d3883e-4e17-48b3-a0ee-09a3e484ac83"],
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          }
        }
      },
      "PendingTransaction": {
        "type": "object",
        "properties": {
          "id": {
            "description": "ID of the pending transaction",
            "example": "5e6645712b55823de7ea82f1",
            "type": "string"
          },
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Blockchain of the transaction",
            "enum": [
              "BNB",
              "BTC",
              "ETH",
              "XLM",
              "XRP",
              "BCH",
              "LTC",
              "DOGE",
              "VET",
              "BSC",
              "MATIC",
              "CELO",
              "FLOW",
              "TRON",
              "ONE",
              "XDC",
              "EGLD",
              "KLAY",
              "SOL"
            ]
          },
          "hashes": {
            "type": "array",
            "description": "List of the signature Ids to be used to sign transaction. Those hashes should be in order of signing for the BTC, LTC or BCH blockchains.",
            "items": {
              "type": "string",
              "description": "Signature hash representing wallet or private key managed in the Tatum KMS instance.",
              "example": "1234987askdjfb1o2873ryskajfb1234987askdjfb1o2873ryskajfb1234987askdjfb1o2873ryskajfb"
            }
          },
          "serializedTransaction": {
            "type": "string",
            "example": "alskdjfq8o27fbkasljfbq8o7b4fqo83f7bqejhafbo8q4f",
            "description": "Serialized data of the transaction to be signed. It can be JSON, HEX or any other representation based on the blockchain."
          },
          "withdrawalId": {
            "description": "ID of the pending off-chain withdrawal connected to this transaction",
            "example": "5e6645712b55823de7ea82f1",
            "type": "string"
          },
          "index": {
            "type": "number",
            "description": "In case of mnemonic type of signature Id, this is the index to the specific account that should be used for signature.",
            "example": 1,
            "minimum": 0
          },
          "txId": {
            "description": "TX hash of successful transaction.",
            "example": "c83f8818db43d9ba4accfe454aa44fc33123d47a4f89d47b314d6748eb0e9bc9",
            "type": "string"
          },
          "withdrawalResponses": {
            "items": { "$ref": "#/components/schemas/ResponseData" },
            "type": "array",
            "description": "Additional information used for BTC, LTC, DOGE and BCH off-chain to blockchain transactions."
          }
        },
        "required": ["id", "chain", "serializedTransaction", "hashes"]
      },
      "MintErc721": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "url", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "MintErc721KMS": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "url", "contractAddress", "signatureId", "tokenId"]
      },
      "MintMultipleErc721": {
        "type": "object",
        "properties": {
          "to": {
            "type": "array",
            "description": "Blockchain address to send ERC721 token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "url", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "MintMultipleErc721KMS": {
        "type": "object",
        "properties": {
          "to": {
            "type": "array",
            "description": "Blockchain address to send ERC721 token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "tokenId", "url", "signatureId"]
      },
      "BurnErc721": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "url", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "BurnErc721KMS": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "url", "contractAddress", "tokenId", "signatureId"]
      },
      "TransferEthBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property. Only for ETH transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Ethereum Blockchain Account.",
            "enum": [
              "USDT",
              "LEO",
              "LINK",
              "UNI",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "MKR",
              "USDC",
              "BAT",
              "TUSD",
              "BUSD",
              "PAX",
              "PAXG",
              "MMY",
              "WBTC",
              "XCON",
              "ETH"
            ],
            "example": "ETH",
            "type": "string"
          },
          "fee": { "$ref": "#/components/schemas/CustomFee" },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "currency", "fromPrivateKey", "amount"]
      },
      "EthEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "contractAddress": {
            "description": "Contract address of ERC20 token, if transaction is ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Ether or ERC20.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property. Only for ETH transactions.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "EthEstimateGasArray": {
        "type": "object",
        "required": ["estimations"],
        "properties": {
          "estimations": { "type": "array", "items": { "$ref": "#/components/schemas/EthEstimateGas" } }
        }
      },
      "EthGasEstimation": {
        "type": "object",
        "required": ["gasLimit", "gasPrice", "estimations"],
        "properties": {
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price.",
            "example": "40000"
          },
          "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "20000000000" },
          "estimations": { "$ref": "#/components/schemas/EthGasEstimationDetails" }
        }
      },
      "EthGasEstimationDetails": {
        "type": "object",
        "description": "Detailed estimations for safe (under 30 minutes), standard (under 5 minutes) and fast (under 2 minutes) transaction times.",
        "required": ["safe", "standard", "fast", "baseFee"],
        "properties": {
          "safe": { "type": "string", "description": "Safe gas price in wei.", "example": "20000000000" },
          "standard": {
            "type": "string",
            "description": "Standard gas price in wei.",
            "example": "40000000000"
          },
          "fast": { "type": "string", "description": "Fast gas price in wei.", "example": "55000000000" },
          "baseFee": {
            "type": "string",
            "description": "Base fee for EIP-1559 transactions in wei.",
            "example": "55000000000"
          }
        }
      },
      "EthGasEstimationBatch": {
        "type": "object",
        "required": ["error", "result"],
        "properties": {
          "error": { "type": "boolean", "description": "If all estimations succeeded.", "example": false },
          "result": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EthGasEstimationBatchResult" }
          }
        },
        "example": {
          "error": true,
          "result": [
            {
              "error": true,
              "msg": "Provided address 0xt16360210b423d3a5205923d6e64a2d142d9f426 is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted."
            },
            {
              "error": false,
              "contractAddress": "0xdac17f958d2ee523a2206206994597c13d831ec7",
              "data": {
                "gasLimit": "63185",
                "gasPrice": "119104833751",
                "estimations": {
                  "safe": "100833333333",
                  "standard": "104833333333",
                  "fast": "119104833751",
                  "baseFee": "119104833751"
                }
              }
            }
          ]
        }
      },
      "EthGasEstimationBatchResult": {
        "type": "object",
        "required": ["error"],
        "properties": {
          "error": { "type": "boolean", "description": "If estimation succeeded.", "example": false },
          "contractAddress": {
            "description": "Contract address of ERC20 token, if transaction is ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "data": { "$ref": "#/components/schemas/EthGasEstimationBatchResultData" },
          "msg": {
            "type": "string",
            "description": "Error message. Present only if error - true.",
            "example": "Provided address 0xt16360210b423d3a5205923d6e64a2d142d9f426 is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted."
          }
        }
      },
      "EthGasEstimationBatchResultData": {
        "type": "object",
        "required": ["gasLimit", "gasPrice", "estimations"],
        "properties": {
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price.",
            "example": "40000"
          },
          "gasPrice": { "type": "string", "description": "Gas price in wei.", "example": "20000000000" },
          "estimations": { "$ref": "#/components/schemas/EthGasEstimationDetails" }
        }
      },
      "TransferEthBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property. Only for ETH transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Ethereum Blockchain Account.",
            "enum": [
              "USDT",
              "LEO",
              "LINK",
              "UNI",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "MKR",
              "USDC",
              "BAT",
              "TUSD",
              "BUSD",
              "PAX",
              "PAXG",
              "MMY",
              "WBTC",
              "XCON",
              "ETH"
            ],
            "example": "ETH",
            "type": "string"
          },
          "fee": { "$ref": "#/components/schemas/CustomFee" },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          }
        },
        "required": ["to", "amount", "currency", "signatureId"]
      },
      "CreateRecord": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "minLength": 1,
            "maxLength": 130000,
            "description": "Log data to be stored on a blockchain.",
            "example": "My example log data."
          },
          "chain": {
            "description": "Blockchain, where to store log data.",
            "enum": ["ETH", "ONE", "XDC", "KLAY", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of account, from which the transaction will be initiated. If not present, transaction fee will be debited from Tatum internal account and additional credits will be charged."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to store log on. If not defined, it will be stored on an address, from which the transaction was being made.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          }
        },
        "required": ["data", "chain"]
      },
      "CreateRecordCelo": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "minLength": 1,
            "maxLength": 130000,
            "description": "Log data to be stored on a blockchain.",
            "example": "My example log data."
          },
          "chain": {
            "description": "Blockchain, where to store log data.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of account, from which the transaction will be initiated. If not present, transaction fee will be debited from Tatum internal account and additional credits will be charged."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to store log on. If not defined, it will be stored on an address, from which the transaction was being made.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          }
        },
        "required": ["data", "feeCurrency", "chain"]
      },
      "TransferErc20": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "currency": {
            "description": "ERC20 symbol. Required only for calls.",
            "example": "MY_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "privateKey": {
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "description": "Private key of sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "privateKey", "amount"]
      },
      "TransferErc20Mnemonic": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "currency": {
            "description": "ERC20 symbol. Required only for calls.",
            "example": "MY_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, or privateKey must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "index"]
      },
      "TransferErc20KMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "address": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "currency": {
            "description": "ERC20 symbol. Required only for calls.",
            "example": "MY_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "signatureId"]
      },
      "TransferEth": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum | Polygon | KCS | XDC transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Ether | MATIC | XDC | KCS.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "privateKey": {
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "description": "Private key of sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "amount", "privateKey"]
      },
      "TransferEthMnemonic": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum | Polygon | KCS | XDC transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Ether | MATIC | XDC | KCS.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "index"]
      },
      "TransferEthKMS": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum | Polygon | KCS | XDC transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Ether | MATIC | XDC | KCS.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "signatureId", "amount"]
      },
      "TransferKCS": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to KCS transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in KCS.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "description": "Private key of sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "amount", "fromPrivateKey"]
      },
      "TransferKCSMnemonic": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to KCS transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in KCS.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "index"]
      },
      "TransferKCSKMS": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to KCS transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in KCS.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "signatureId", "amount"]
      },
      "TransferBsc": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Binance Smart Chain transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "description": "Private key of sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "amount", "fromPrivateKey"]
      },
      "TransferBscMnemonic": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Binance Smart Chain transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "index"]
      },
      "TransferBscKMS": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Binance Smart Chain transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "signatureId", "amount"]
      },
      "TransferCelo": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "minLength": 66,
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "description": "Private key of sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub."
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "amount", "feeCurrency", "fromPrivateKey"]
      },
      "TransferCeloMnemonic": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "feeCurrency", "index"]
      },
      "TransferCeloKMS": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          },
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei. If not set, automatic calculation will be used.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        },
        "required": ["senderAccountId", "address", "signatureId", "feeCurrency", "amount"]
      },
      "TransferTron": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Blockchain address to send assets",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "maxLength": 34,
            "minLength": 34,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Tron.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "minLength": 64,
            "example": "e75d702ce00987633f8009fbb1eabb5b187cb5b50fe9179a8d6cee6bab076b66",
            "description": "Private key of sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub."
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 2.5 TRX is used.",
            "example": "2.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "fromPrivateKey"]
      },
      "TransferTronMnemonic": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Blockchain address to send assets",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "maxLength": 34,
            "minLength": 34,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Tron.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 2.5 TRX is used.",
            "example": "2.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "index"]
      },
      "TransferTronKMS": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Blockchain address to send assets to",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "maxLength": 34,
            "minLength": 34,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Tron.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 2.5 TRX is used.",
            "example": "2.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "from": {
            "description": "Blockchain address to send assets from",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW",
            "maxLength": 34,
            "minLength": 34,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "from", "address", "signatureId", "amount"]
      },
      "TransferAdaKeyPair": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 150,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 0.5 ADA is used.",
            "example": "0.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "keyPair": {
            "description": "Array of assigned blockchain addresses with their private keys.\nEither mnemonic, keyPair or signature Id must be present - depends on the type of account and xpub.\nTatum KMS does not support keyPair type of off-chain transaction, only mnemonic based.\n",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "Blockchain address assigned to account withdrawal is made from.",
                  "maxLength": 150,
                  "minLength": 30
                },
                "privateKey": {
                  "type": "string",
                  "description": "Private key of blockchain address.",
                  "maxLength": 192,
                  "example": "7808a501e1bbc9926ac8ac6981e47cb0401288ae331a1f2333d1bed46c5b3051b5f875c39477b05bc3a43a3800b763f616ae3646f21df0ab5d95db944e71f5cfa8082d5c4e6241d49b17b2b6173f01bb3fd03be012cc8908ceea9e559e33e4fc",
                  "minLength": 192
                }
              }
            }
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "keyPair", "attr"],
        "type": "object"
      },
      "TransferAdaMnemonic": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Blockchain address to send assets",
            "example": "addr1qyyxyhaa2e7kxeqcc72w7f747zqlgwwwstlzsg9umuxc40wnhawldxl4nan95rhtlcnju9q2r8j9qz8vslwsmrkj5r4spxhep9",
            "maxLength": 90,
            "minLength": 110,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in ADA.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 1 ADA is used.",
            "example": "2.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key for sender address. Either mnemonic and index, privateKey or signature Id must be present - depends on the type of account and xpub.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. Should be present, when mnemonic is used.",
            "maxLength": 192,
            "minLength": 1,
            "example": "41253768cd7c5831988e580cfc7eeecaa78bf52a1ede2bd2f245406605adfbadd5911ab567bc3dc7713e29c2c14bb898b24bb1f01a4992605343ad14703037b9",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "mnemonic", "xpub", "index"]
      },
      "TransferAdaKMS": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Blockchain address to send assets to",
            "example": "addr1qyyxyhaa2e7kxeqcc72w7f747zqlgwwwstlzsg9umuxc40wnhawldxl4nan95rhtlcnju9q2r8j9qz8vslwsmrkj5r4spxhep9",
            "maxLength": 90,
            "minLength": 110,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in ADA.",
            "maxLength": 38,
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain. If none is set, default value of 1 ADA is used.",
            "example": "2.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "from": {
            "description": "Blockchain address to send assets from",
            "example": "addr1qyyxyhaa2e7kxeqcc72w7f747zqlgwwwstlzsg9umuxc40wnhawldxl4nan95rhtlcnju9q2r8j9qz8vslwsmrkj5r4spxhep9",
            "maxLength": 90,
            "minLength": 110,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the mnemonic / private key associated in signing application.\nWhen hash identifies mnemonic, index must be present to represent specific account to pay from.\nPrivate key, mnemonic or signature Id must be present.\n"
          },
          "xpub": {
            "description": "Extended public key (xpub) of the wallet associated with the accounts. XPub or attr must be used with signatureId.",
            "maxLength": 192,
            "minLength": 1,
            "example": "41253768cd7c5831988e580cfc7eeecaa78bf52a1ede2bd2f245406605adfbadd5911ab567bc3dc7713e29c2c14bb898b24bb1f01a4992605343ad14703037b9",
            "type": "string"
          },
          "attr": {
            "description": "Used to parametrize withdrawal as a change address for left coins from transaction. XPub or attr must be used with signatureId.",
            "maxLength": 256,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "description": "Derivation index of sender address.",
            "maximum": 2147483647,
            "example": 0,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "from", "address", "signatureId", "amount"]
      },
      "TransferXrp": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "maxLength": 100,
            "minLength": 1,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XRP.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "attr": {
            "description": "Destination tag of the recipient account, if any. Must be stringified uint32.",
            "example": "12355",
            "type": "string"
          },
          "sourceTag": {
            "description": "Source tag of sender account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "secret": {
            "maxLength": 29,
            "minLength": 29,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "snSFTHdvSYQKKkYntvEt8cnmZuPJB",
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "amount", "secret"]
      },
      "TransferXrpKMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "maxLength": 100,
            "minLength": 1,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XRP.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "attr": {
            "description": "Destination tag of the recipient account, if any. Must be stringified uint32.",
            "example": "12355",
            "type": "string"
          },
          "sourceTag": {
            "description": "Source tag of sender account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "signatureId", "amount"]
      },
      "TransferBnb": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "tbnb1q82g2h9q0kfe7sysnj5w7nlak92csfjztymp39",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in BNB.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "attr": {
            "description": "Memo of the recipient account, if any.",
            "example": "12355",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "minLength": 64,
            "example": "8ac4b14b38d8a5af58019088ce5a24b764536bccd1981cf79d3e09e9d1f2ad31",
            "description": "Private key of sender address."
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "address", "amount", "fromPrivateKey"]
      },
      "TransferBnbKMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "tbnb1q82g2h9q0kfe7sysnj5w7nlak92csfjztymp39",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in BNB.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "attr": {
            "description": "Memo of the recipient account, if any.",
            "example": "12355",
            "type": "string"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "fromAddress": {
            "description": "Blockchain address to send from.",
            "example": "tbnb1q82g2h9q0kfe7sysnj5w7nlak92csfjztymp39",
            "maxLength": 50,
            "minLength": 42,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["senderAccountId", "fromAddress", "address", "amount", "signatureId"]
      },
      "CreateXlmAsset": {
        "type": "object",
        "properties": {
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets.",
            "example": "GC5LAVZ5UPLIFDH6SI33PNVL5TKWA4ODXTI3WEF5JM6LRM5MNGVJ56TT",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "token": {
            "description": "Asset name.",
            "example": "TOKEN123",
            "type": "string",
            "pattern": "^[a-zA-Z0-9]{1,12}$",
            "maxLength": 12,
            "minLength": 1
          },
          "basePair": {
            "description": "Base pair for Asset. Transaction value will be calculated according to this base pair. e.g. 1 TOKEN123 is equal to 1 EUR, if basePair is set to EUR.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          }
        },
        "required": ["basePair", "issuerAccount", "token"]
      },
      "CreateBnbAsset": {
        "type": "object",
        "properties": {
          "token": {
            "description": "Asset name.",
            "example": "NNB-B90",
            "type": "string",
            "pattern": "^[a-zA-Z0-9\\-]{1,12}$",
            "maxLength": 12,
            "minLength": 1
          },
          "basePair": {
            "description": "Base pair for Asset. Transaction value will be calculated according to this base pair. e.g. 1 TOKEN123 is equal to 1 EUR, if basePair is set to EUR.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          }
        },
        "required": ["basePair", "token"]
      },
      "CreateXrpAsset": {
        "type": "object",
        "properties": {
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets.",
            "example": "rsCZjvenhxsFycrb33gPSfXdrTNAS5uiR1",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "token": {
            "description": "Asset name.",
            "example": "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
            "type": "string",
            "pattern": "^[A-F0-9]{40}$",
            "maxLength": 40,
            "minLength": 40
          },
          "basePair": {
            "description": "Base pair for Asset. Transaction value will be calculated according to this base pair. e.g. 1 TOKEN123 is equal to 1 EUR, if basePair is set to EUR.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          }
        },
        "required": ["basePair", "issuerAccount", "token"]
      },
      "TransferXlm": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "fromAccount": {
            "description": "Blockchain account to send from",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XLM or XLM-based Asset.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "secret": {
            "maxLength": 56,
            "minLength": 56,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "SCVVKNLBHOWBNJYHD3CNROOA2P3K35I5GNTYUHLLMUHMHWQYNEI7LVED",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "attr": {
            "description": "Short message to recipient. Usually used as an account discriminator. It can be either 28 characters long ASCII text, 64 characters long HEX string or uint64 number. When using as an account disciminator in Tatum Offchain ledger, can be in format of destination_acc|source_acc.",
            "example": "12355",
            "pattern": "^[ -~]{0,64}$",
            "type": "string",
            "maxLength": 64
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["fromAccount", "senderAccountId", "address", "secret", "amount"]
      },
      "TransferXlmKMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "fromAccount": {
            "description": "Blockchain account to send from",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XLM or XLM-based Asset.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "attr": {
            "description": "Short message to recipient. Usually used as an account discriminator. It can be either 28 characters long ASCII text, 64 characters long HEX string or uint64 number. When using as an account disciminator in Tatum Offchain ledger, can be in format of destination_acc|source_acc.",
            "example": "12355",
            "pattern": "^[ -~]{0,64}$",
            "type": "string",
            "maxLength": 64
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["fromAccount", "senderAccountId", "address", "amount", "signatureId"]
      },
      "TransferSol": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "from": {
            "description": "Blockchain account to send from",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 43,
            "minLength": 44,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
            "maxLength": 43,
            "minLength": 44,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in SOL / USDC_SOL or custom SPL token based on the senderAccountId currency type.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "privateKey": {
            "maxLength": 128,
            "minLength": 87,
            "description": "Private key for account. Private key, or signature Id must be present.",
            "example": "zgsAKfjuXrAxEyuYRxbbxPM3rdsPbJPnGreaGMbcdUApJ6wHnCqQnf9b1RNPdeZxsRMkezh4VgXQ7YrbpndGtEv",
            "type": "string"
          },
          "fee": {
            "description": "Fee to be charged for the operation. For SOL, fee is decided by the blockchain, but default SOL fee is 0.000005. This fee will be only charged on top of the withdrawal amount to the virtual account.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["from", "senderAccountId", "address", "privateKey", "amount"]
      },
      "TransferSolKMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "from": {
            "description": "Blockchain account to send from",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 43,
            "minLength": 44,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
            "maxLength": 43,
            "minLength": 44,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in SOL.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "fee": {
            "description": "Fee to be charged for the operation. For SOL, fee is decided by the blockchain, but default SOL fee is 0.000005. This fee will be only charged on top of the withdrawal amount to the virtual account.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["from", "senderAccountId", "address", "signatureId", "amount"]
      },
      "TransferFlowPK": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": 10762710243615955000,
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in Flow.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "privateKey": {
            "maxLength": 64,
            "minLength": 64,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "37afa218d41d9cd6a2c6f2b96d9eaa3ad96c598252bc50e4d45d62f9356a51f8",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "privateKey", "amount"]
      },
      "TransferFlowKMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": 10762710243615955000,
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in Flow.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "amount", "signatureId"]
      },
      "TransferAlgo": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "The ID of the virtual account to send Algos from",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "description": "The blockchain address of the Algorand wallet (account) associated with the virtual account",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "address": {
            "description": "The blockchain address to send Algos to",
            "example": "5YVZBUH3STSQ5ABCTLEIEIJ7QOZFILM2DLAEEA4ZL6CU55ODZIQXO5EMYM",
            "maxLength": 58,
            "minLength": 58,
            "type": "string"
          },
          "amount": {
            "description": "The amount to send in Algos",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fee": { "description": "The transaction fee in Algos", "type": "string", "example": "0.001" },
          "privateKey": {
            "maxLength": 103,
            "minLength": 103,
            "description": "The secret of the Algorand wallet (account). Secret, or signature Id must be present.",
            "example": "NBYMCVEEDFYV3TPWVRE6APE7PKHUJD4XAKXCKNCLKGUXOC3LFNJGZQCJCRA53HB7ZAHF6NFJH2QIVQ5USQNWG35QCJLD4KZ5IWMB24Q",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check; if the withdrawal is not compliant, it will not be processed",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "The identifier of the Algo transfer that is shown on the virtual account for the created transaction",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "The note for the recipient; must not contain spaces",
            "example": "Helloworld",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "privateKey", "amount", "fee"]
      },
      "TransferAlgoKMS": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "The ID of the virtual account to send Algos from",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "description": "The blockchain address of the Algorand wallet (account) associated with the virtual account",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "maxLength": 58,
            "minLength": 58,
            "type": "string"
          },
          "address": {
            "description": "The blockchain address to send Algos to",
            "example": "5YVZBUH3STSQ5ABCTLEIEIJ7QOZFILM2DLAEEA4ZL6CU55ODZIQXO5EMYM",
            "maxLength": 58,
            "minLength": 58,
            "type": "string"
          },
          "amount": {
            "description": "The amount to send in Algos",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fee": { "description": "The transaction fee in Algos", "type": "string", "example": "0.001" },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The identifier of the secret of the Algorand wallet (account) in the signing application. Secret, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "compliant": {
            "description": "Compliance check; if the withdrawal is not compliant, it will not be processed",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "The identifier of the Algo transfer that is shown on the virtual account for the created transaction",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "The note for the recipient; must not contain spaces",
            "example": "Helloworld",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "amount", "signatureId", "fee"]
      },
      "TransferFlowMnemonic": {
        "type": "object",
        "properties": {
          "senderAccountId": {
            "maxLength": 24,
            "minLength": 24,
            "description": "Sender account ID",
            "example": "61b3bffddfb389cde19c73be",
            "type": "string"
          },
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets",
            "example": "0x955cd3f17b2fd8ae",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in Flow.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "Index to the specific address from mnemonic."
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "1234",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Note visible to owner of withdrawing account.",
            "example": "Sender note",
            "type": "string"
          }
        },
        "required": ["account", "senderAccountId", "address", "amount", "mnemonic", "index"]
      },
      "FlowTransactionPK": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "currency": { "type": "string", "description": "Type of asset to send", "enum": ["FLOW", "FUSD"] },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x955cd3f17b2fd8ae",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in Flow.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "privateKey": {
            "maxLength": 64,
            "minLength": 64,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "37afa218d41d9cd6a2c6f2b96d9eaa3ad96c598252bc50e4d45d62f9356a51f8",
            "type": "string"
          }
        },
        "required": ["account", "address", "privateKey", "currency", "amount"]
      },
      "FlowTransactionKMS": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "currency": { "type": "string", "description": "Type of asset to send", "enum": ["FLOW", "FUSD"] },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x955cd3f17b2fd8ae",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in Flow.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          }
        },
        "required": ["account", "currency", "address", "amount", "signatureId"]
      },
      "FlowTransactionMnemonic": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "currency": { "type": "string", "description": "Type of asset to send", "enum": ["FLOW", "FUSD"] },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x955cd3f17b2fd8ae",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in Flow.",
            "maxLength": 38,
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "Index to the specific address from mnemonic."
          }
        },
        "required": ["account", "currency", "address", "amount", "mnemonic", "index"]
      },
      "FlowCustomTransactionPK": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "transaction": {
            "description": "Transaction string to send to the chain.",
            "example": "transaction(publicKey: String) {\n  prepare(signer: AuthAccount) {\n    signer.addPublicKey(publicKey.decodeHex())\n  }\n}\n",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "args": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string",
                  "description": "Value of the argument. In case of Array type, it could be list of strings."
                },
                "type": {
                  "description": "Type of the argument",
                  "maxLength": 38,
                  "type": "string",
                  "enum": [
                    "Identity",
                    "UInt",
                    "Int",
                    "UInt8",
                    "Int8",
                    "UInt16",
                    "Int16",
                    "UInt32",
                    "Int32",
                    "UInt64",
                    "Int64",
                    "UInt128",
                    "Int128",
                    "UInt256",
                    "Int256",
                    "Word8",
                    "Word16",
                    "Word32",
                    "Word64",
                    "UFix64",
                    "Fix64",
                    "String",
                    "Character",
                    "Bool",
                    "Address",
                    "Void",
                    "Optional",
                    "Reference",
                    "Array",
                    "Dictionary",
                    "Event",
                    "Resource",
                    "Struct"
                  ]
                },
                "subType": {
                  "description": "Type of the argument",
                  "maxLength": 38,
                  "type": "string",
                  "enum": [
                    "Identity",
                    "UInt",
                    "Int",
                    "UInt8",
                    "Int8",
                    "UInt16",
                    "Int16",
                    "UInt32",
                    "Int32",
                    "UInt64",
                    "Int64",
                    "UInt128",
                    "Int128",
                    "UInt256",
                    "Int256",
                    "Word8",
                    "Word16",
                    "Word32",
                    "Word64",
                    "UFix64",
                    "Fix64",
                    "String",
                    "Character",
                    "Bool",
                    "Address",
                    "Void",
                    "Optional",
                    "Reference",
                    "Array",
                    "Dictionary",
                    "Event",
                    "Resource",
                    "Struct"
                  ]
                }
              },
              "required": ["type", "value"]
            }
          },
          "privateKey": {
            "maxLength": 64,
            "minLength": 64,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "37afa218d41d9cd6a2c6f2b96d9eaa3ad96c598252bc50e4d45d62f9356a51f8",
            "type": "string"
          }
        },
        "required": ["account", "transaction", "privateKey", "currency", "args"]
      },
      "FlowCustomTransactionKMS": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "transaction": {
            "description": "Transaction string to send to the chain.",
            "example": "transaction(publicKey: String) {\n  prepare(signer: AuthAccount) {\n    signer.addPublicKey(publicKey.decodeHex())\n  }\n}\n",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "args": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string",
                  "description": "Value of the argument. In case of Array type, it could be list of strings."
                },
                "type": {
                  "description": "Type of the argument",
                  "maxLength": 38,
                  "type": "string",
                  "enum": [
                    "Identity",
                    "UInt",
                    "Int",
                    "UInt8",
                    "Int8",
                    "UInt16",
                    "Int16",
                    "UInt32",
                    "Int32",
                    "UInt64",
                    "Int64",
                    "UInt128",
                    "Int128",
                    "UInt256",
                    "Int256",
                    "Word8",
                    "Word16",
                    "Word32",
                    "Word64",
                    "UFix64",
                    "Fix64",
                    "String",
                    "Character",
                    "Bool",
                    "Address",
                    "Void",
                    "Optional",
                    "Reference",
                    "Array",
                    "Dictionary",
                    "Event",
                    "Resource",
                    "Struct"
                  ]
                },
                "subType": {
                  "description": "Type of the argument",
                  "maxLength": 38,
                  "type": "string",
                  "enum": [
                    "Identity",
                    "UInt",
                    "Int",
                    "UInt8",
                    "Int8",
                    "UInt16",
                    "Int16",
                    "UInt32",
                    "Int32",
                    "UInt64",
                    "Int64",
                    "UInt128",
                    "Int128",
                    "UInt256",
                    "Int256",
                    "Word8",
                    "Word16",
                    "Word32",
                    "Word64",
                    "UFix64",
                    "Fix64",
                    "String",
                    "Character",
                    "Bool",
                    "Address",
                    "Void",
                    "Optional",
                    "Reference",
                    "Array",
                    "Dictionary",
                    "Event",
                    "Resource",
                    "Struct"
                  ]
                }
              },
              "required": ["type", "value"]
            }
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          }
        },
        "required": ["account", "currency", "transaction", "args", "signatureId"]
      },
      "FlowCustomTransactionMnemonic": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "transaction": {
            "description": "Transaction string to send to the chain.",
            "example": "transaction(publicKey: String) {\n  prepare(signer: AuthAccount) {\n    signer.addPublicKey(publicKey.decodeHex())\n  }\n}\n",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "args": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string",
                  "description": "Value of the argument. In case of Array type, it could be list of strings."
                },
                "type": {
                  "description": "Type of the argument",
                  "maxLength": 38,
                  "type": "string",
                  "enum": [
                    "Identity",
                    "UInt",
                    "Int",
                    "UInt8",
                    "Int8",
                    "UInt16",
                    "Int16",
                    "UInt32",
                    "Int32",
                    "UInt64",
                    "Int64",
                    "UInt128",
                    "Int128",
                    "UInt256",
                    "Int256",
                    "Word8",
                    "Word16",
                    "Word32",
                    "Word64",
                    "UFix64",
                    "Fix64",
                    "String",
                    "Character",
                    "Bool",
                    "Address",
                    "Void",
                    "Optional",
                    "Reference",
                    "Array",
                    "Dictionary",
                    "Event",
                    "Resource",
                    "Struct"
                  ]
                },
                "subType": {
                  "description": "Type of the argument",
                  "maxLength": 38,
                  "type": "string",
                  "enum": [
                    "Identity",
                    "UInt",
                    "Int",
                    "UInt8",
                    "Int8",
                    "UInt16",
                    "Int16",
                    "UInt32",
                    "Int32",
                    "UInt64",
                    "Int64",
                    "UInt128",
                    "Int128",
                    "UInt256",
                    "Int256",
                    "Word8",
                    "Word16",
                    "Word32",
                    "Word64",
                    "UFix64",
                    "Fix64",
                    "String",
                    "Character",
                    "Bool",
                    "Address",
                    "Void",
                    "Optional",
                    "Reference",
                    "Array",
                    "Dictionary",
                    "Event",
                    "Resource",
                    "Struct"
                  ]
                }
              },
              "required": ["type", "value"]
            }
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "Index to the specific address from mnemonic."
          }
        },
        "required": ["account", "transaction", "args", "mnemonic", "index"]
      },
      "FlowCreateAddressFromPubKeySecret": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "publicKey": {
            "description": "Public key to be used",
            "example": "968c3ce11e871cb2b7161b282655ee5fcb051f3c04894705d771bf11c6fbebfc6556ab8a0c04f45ea56281312336d0668529077c9d66891a6cad3db877acbe90",
            "maxLength": 128,
            "minLength": 128,
            "type": "string"
          },
          "privateKey": {
            "maxLength": 64,
            "minLength": 64,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "37afa218d41d9cd6a2c6f2b96d9eaa3ad96c598252bc50e4d45d62f9356a51f8",
            "type": "string"
          }
        },
        "required": ["account", "privateKey", "publicKey"]
      },
      "FlowCreateAddressFromPubKeyKMS": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "publicKey": {
            "description": "Public key to be used",
            "example": "968c3ce11e871cb2b7161b282655ee5fcb051f3c04894705d771bf11c6fbebfc6556ab8a0c04f45ea56281312336d0668529077c9d66891a6cad3db877acbe90",
            "maxLength": 128,
            "minLength": 128,
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          }
        },
        "required": ["account", "publicKey", "signatureId"]
      },
      "FlowCreateAddressFromPubKeyMnemonic": {
        "type": "object",
        "properties": {
          "account": {
            "description": "Blockchain account to send from",
            "example": "0x955cd3f17b2fd8ad",
            "maxLength": 18,
            "minLength": 18,
            "type": "string"
          },
          "publicKey": {
            "description": "Public key to be used",
            "example": "968c3ce11e871cb2b7161b282655ee5fcb051f3c04894705d771bf11c6fbebfc6556ab8a0c04f45ea56281312336d0668529077c9d66891a6cad3db877acbe90",
            "maxLength": 128,
            "minLength": 128,
            "type": "string"
          },
          "weight": {
            "description": "Weight of the key. If not set, default 1000 will be used.",
            "example": 1000,
            "minimum": 0,
            "maximum": 1000,
            "type": "number"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "Index to the specific address from mnemonic."
          }
        },
        "required": ["account", "publicKey", "mnemonic", "index"]
      },
      "TransferXrpBlockchain": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XRP.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromSecret": {
            "maxLength": 29,
            "minLength": 29,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "snSFTHdvSYQKKkYntvEt8cnmZuPJB",
            "type": "string"
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "sourceTag": {
            "description": "Source tag of sender account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "destinationTag": {
            "description": "Destination tag of recipient account, if any.",
            "example": 12355,
            "type": "integer"
          }
        },
        "required": ["fromAccount", "to", "amount", "fromSecret"]
      },
      "TransferXrpBlockchainAsset": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XRP.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromSecret": {
            "maxLength": 29,
            "minLength": 29,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "snSFTHdvSYQKKkYntvEt8cnmZuPJB",
            "type": "string"
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "sourceTag": {
            "description": "Source tag of sender account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "destinationTag": {
            "description": "Destination tag of recipient account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to create trust line for.",
            "example": "rsP3mgGb2tcYUrxiLFiHJiQXhsziegtwBc",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "token": {
            "description": "Asset name. Must be 160bit HEX string, e.g. SHA1.",
            "example": "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
            "type": "string",
            "pattern": "^[A-F0-9]{40}$",
            "maxLength": 40,
            "minLength": 40
          }
        },
        "required": ["fromAccount", "to", "amount", "fromSecret", "issuerAccount", "token"]
      },
      "TransferXrpBlockchainKMS": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XRP.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "sourceTag": {
            "description": "Source tag of sender account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "destinationTag": {
            "description": "Destination tag of recipient account, if any.",
            "example": 12355,
            "type": "integer"
          }
        },
        "required": ["fromAccount", "to", "amount", "signatureId"]
      },
      "TransferXrpBlockchainAssetKMS": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XRP.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "sourceTag": {
            "description": "Source tag of sender account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "destinationTag": {
            "description": "Destination tag of recipient account, if any.",
            "example": 12355,
            "type": "integer"
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to create trust line for.",
            "example": "rsP3mgGb2tcYUrxiLFiHJiQXhsziegtwBc",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "token": {
            "description": "Asset name. Must be 160bit HEX string, e.g. SHA1.",
            "example": "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
            "type": "string",
            "pattern": "^[A-F0-9]{40}$",
            "maxLength": 40,
            "minLength": 40
          }
        },
        "required": ["fromAccount", "to", "amount", "signatureId", "issuerAccount", "token"]
      },
      "TransferXlmBlockchain": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "description": "Blockchain account to send assets from",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XLM.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromSecret": {
            "maxLength": 56,
            "minLength": 56,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "SCVVKNLBHOWBNJYHD3CNROOA2P3K35I5GNTYUHLLMUHMHWQYNEI7LVED",
            "type": "string"
          },
          "initialize": {
            "type": "boolean",
            "default": false,
            "example": false,
            "description": "Set to true, if the destination address is not yet initialized and should be funded for the first time."
          },
          "message": {
            "description": "Short message to recipient. It can be either 28 characters long ASCII text, 64 characters long HEX string or uint64 number.",
            "example": "12355",
            "pattern": "^[ -~]{0,64}$",
            "type": "string",
            "maxLength": 64
          }
        },
        "required": ["fromAccount", "fromSecret", "to", "amount"]
      },
      "TransferXlmBlockchainAsset": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "description": "Blockchain account to send assets from",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XLM.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromSecret": {
            "maxLength": 56,
            "minLength": 56,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "SCVVKNLBHOWBNJYHD3CNROOA2P3K35I5GNTYUHLLMUHMHWQYNEI7LVED",
            "type": "string"
          },
          "initialize": {
            "type": "boolean",
            "default": false,
            "example": false,
            "description": "Set to true, if the destination address is not yet initialized and should be funded for the first time."
          },
          "token": {
            "description": "Asset name. If not defined, transaction is being sent in native XLM asset.",
            "example": "TOKEN123",
            "type": "string",
            "pattern": "^[a-zA-Z0-9]{1,12}$",
            "maxLength": 12,
            "minLength": 1
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to send, if not native XLM asset.",
            "example": "GC5LAVZ5UPLIFDH6SI33PNVL5TKWA4ODXTI3WEF5JM6LRM5MNGVJ56TT",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "message": {
            "description": "Short message to recipient. It can be either 28 characters long ASCII text, 64 characters long HEX string or uint64 number.",
            "example": "12355",
            "pattern": "^[ -~]{0,64}$",
            "type": "string",
            "maxLength": 64
          }
        },
        "required": ["fromAccount", "fromSecret", "token", "issuerAccount", "to", "amount"]
      },
      "TransferXlmBlockchainKMS": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "description": "Blockchain account to send assets from",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XLM.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "initialize": {
            "type": "boolean",
            "default": false,
            "example": false,
            "description": "Set to true, if the destination address is not yet initialized and should be funded for the first time."
          },
          "message": {
            "description": "Short message to recipient. It can be either 28 characters long ASCII text, 64 characters long HEX string or uint64 number.",
            "example": "12355",
            "pattern": "^[ -~]{0,64}$",
            "type": "string",
            "maxLength": 64
          }
        },
        "required": ["fromAccount", "signatureId", "to", "amount"]
      },
      "TransferXlmBlockchainKMSAsset": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "description": "Blockchain account to send assets from",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent, in XLM.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "initialize": {
            "type": "boolean",
            "default": false,
            "example": false,
            "description": "Set to true, if the destination address is not yet initialized and should be funded for the first time."
          },
          "token": {
            "description": "Asset name. If not defined, transaction is being sent in native XLM asset.",
            "example": "TOKEN123",
            "type": "string",
            "pattern": "^[a-zA-Z0-9]{1,12}$",
            "maxLength": 12,
            "minLength": 1
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to send, if not native XLM asset.",
            "example": "GC5LAVZ5UPLIFDH6SI33PNVL5TKWA4ODXTI3WEF5JM6LRM5MNGVJ56TT",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "message": {
            "description": "Short message to recipient. It can be either 28 characters long ASCII text, 64 characters long HEX string or uint64 number.",
            "example": "12355",
            "pattern": "^[ -~]{0,64}$",
            "type": "string",
            "maxLength": 64
          }
        },
        "required": ["fromAccount", "signatureId", "token", "issuerAccount", "to", "amount"]
      },
      "TrustLineXlmBlockchain": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 56,
            "minLength": 56,
            "description": "XLM account address. Must be the one used for generating deposit tags.",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "type": "string"
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to create trust line for.",
            "example": "GC5LAVZ5UPLIFDH6SI33PNVL5TKWA4ODXTI3WEF5JM6LRM5MNGVJ56TT",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "token": {
            "description": "Asset name.",
            "example": "TOKEN123",
            "type": "string",
            "pattern": "^[a-zA-Z0-9]{1,12}$",
            "maxLength": 12,
            "minLength": 1
          },
          "fromSecret": {
            "maxLength": 56,
            "minLength": 56,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "SCVVKNLBHOWBNJYHD3CNROOA2P3K35I5GNTYUHLLMUHMHWQYNEI7LVED",
            "type": "string"
          },
          "limit": {
            "description": "Amount of the assets to be permitted to send over this trust line. 0 means deletion of the trust line. When no limit is specified, maximum amount available is permitted.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromAccount", "issuerAccount", "fromSecret", "token"]
      },
      "TrustLineXlmBlockchainKMS": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 56,
            "minLength": 56,
            "description": "XLM account address. Must be the one used for generating deposit tags.",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H",
            "type": "string"
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to create trust line for.",
            "example": "GC5LAVZ5UPLIFDH6SI33PNVL5TKWA4ODXTI3WEF5JM6LRM5MNGVJ56TT",
            "maxLength": 56,
            "minLength": 56,
            "type": "string"
          },
          "token": {
            "description": "Asset name.",
            "example": "TOKEN123",
            "type": "string",
            "pattern": "^[a-zA-Z0-9]{1,12}$",
            "maxLength": 12,
            "minLength": 1
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "limit": {
            "description": "Amount of the assets to be permitted to send over this trust line. 0 means deletion of the trust line. When no limit is specified, maximum amount available is permitted.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromAccount", "issuerAccount", "signatureId", "token"]
      },
      "TrustLineXrpBlockchain": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to create trust line for.",
            "example": "rsP3mgGb2tcYUrxiLFiHJiQXhsziegtwBc",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "limit": {
            "description": "Amount of the assets to be permitted to send over this trust line. 0 means deletion of the trust line.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "token": {
            "description": "Asset name. Must be 160bit HEX string, e.g. SHA1.",
            "example": "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
            "type": "string",
            "pattern": "^[A-F0-9]{40}$",
            "maxLength": 40,
            "minLength": 40
          },
          "fromSecret": {
            "maxLength": 29,
            "minLength": 29,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "snSFTHdvSYQKKkYntvEt8cnmZuPJB",
            "type": "string"
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromAccount", "issuerAccount", "limit", "token", "fromSecret"]
      },
      "TrustLineXrpBlockchainKMS": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "issuerAccount": {
            "description": "Blockchain address of the issuer of the assets to create trust line for.",
            "example": "rsP3mgGb2tcYUrxiLFiHJiQXhsziegtwBc",
            "maxLength": 34,
            "minLength": 33,
            "type": "string"
          },
          "limit": {
            "description": "Amount of the assets to be permitted to send over this trust line. 0 means deletion of the trust line.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "token": {
            "description": "Asset name. Must be 160bit HEX string, e.g. SHA1.",
            "example": "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
            "type": "string",
            "pattern": "^[A-F0-9]{40}$",
            "maxLength": 40,
            "minLength": 40
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the secret associated in signing application. Secret, or signature Id must be present."
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromAccount", "issuerAccount", "limit", "token", "signatureId"]
      },
      "AccountSettingsXrpBlockchain": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "fromSecret": {
            "maxLength": 29,
            "minLength": 29,
            "description": "Secret for account. Secret, or signature Id must be present.",
            "example": "snSFTHdvSYQKKkYntvEt8cnmZuPJB",
            "type": "string"
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "rippling": {
            "description": "Should be true, if an account is the issuer of assets.",
            "example": true,
            "type": "boolean"
          },
          "requireDestinationTag": {
            "description": "Should be true, if an account should support off-chain processing.",
            "example": true,
            "type": "boolean"
          }
        },
        "required": ["fromAccount", "fromSecret"]
      },
      "AccountSettingsXrpBlockchainKMS": {
        "type": "object",
        "properties": {
          "fromAccount": {
            "maxLength": 34,
            "minLength": 33,
            "description": "XRP account address. Must be the one used for generating deposit tags.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Secret or signature Id must be present."
          },
          "fee": {
            "description": "Fee to be paid, in XRP. If omitted, current fee will be calculated.",
            "example": "10000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "rippling": {
            "description": "Should be true, if an account is the issuer of assets.",
            "example": true,
            "type": "boolean"
          },
          "requireDestinationTag": {
            "description": "Should be true, if an account should support off-chain processing.",
            "example": true,
            "type": "boolean"
          }
        },
        "required": ["fromAccount", "signatureId"]
      },
      "DeployCeloErc20OffchainMnemXpub": {
        "allOf": [
          { "$ref": "#/components/schemas/DeployErc20OffchainMnemXpub" },
          {
            "type": "object",
            "required": ["feeCurrency"],
            "properties": {
              "feeCurrency": {
                "type": "string",
                "description": "Currency to pay for transaction gas",
                "enum": ["CELO", "CUSD", "CEUR"]
              }
            }
          }
        ]
      },
      "DeployCeloErc20OffchainMnemonicAddress": {
        "allOf": [
          { "$ref": "#/components/schemas/DeployErc20OffchainMnemonicAddress" },
          {
            "type": "object",
            "required": ["feeCurrency"],
            "properties": {
              "feeCurrency": {
                "type": "string",
                "description": "Currency to pay for transaction gas",
                "enum": ["CELO", "CUSD", "CEUR"]
              }
            }
          }
        ]
      },
      "DeployCeloErc20OffchainPKXpub": {
        "allOf": [
          { "$ref": "#/components/schemas/DeployErc20OffchainPKXpub" },
          {
            "type": "object",
            "required": ["feeCurrency"],
            "properties": {
              "feeCurrency": {
                "type": "string",
                "description": "Currency to pay for transaction gas",
                "enum": ["CELO", "CUSD", "CEUR"]
              }
            }
          }
        ]
      },
      "DeployCeloErc20OffchainPKAddress": {
        "allOf": [
          { "$ref": "#/components/schemas/DeployErc20OffchainPKAddress" },
          {
            "type": "object",
            "required": ["feeCurrency"],
            "properties": {
              "feeCurrency": {
                "type": "string",
                "description": "Currency to pay for transaction gas",
                "enum": ["CELO", "CUSD", "CEUR"]
              }
            }
          }
        ]
      },
      "DeployCeloErc20OffchainKMSAddress": {
        "allOf": [
          { "$ref": "#/components/schemas/DeployErc20OffchainKMSAddress" },
          {
            "type": "object",
            "required": ["feeCurrency"],
            "properties": {
              "feeCurrency": {
                "type": "string",
                "description": "Currency to pay for transaction gas",
                "enum": ["CELO", "CUSD", "CEUR"]
              }
            }
          }
        ]
      },
      "DeployCeloErc20OffchainKMSXpub": {
        "allOf": [
          { "$ref": "#/components/schemas/DeployErc20OffchainKMSXpub" },
          {
            "type": "object",
            "required": ["feeCurrency"],
            "properties": {
              "feeCurrency": {
                "type": "string",
                "description": "Currency to pay for transaction gas",
                "enum": ["CELO", "CUSD", "CEUR"]
              }
            }
          }
        ]
      },
      "VetEstimateGas": {
        "type": "object",
        "required": ["from", "to", "value"],
        "properties": {
          "from": {
            "description": "Sender account address.",
            "type": "string",
            "maxLength": 50,
            "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e"
          },
          "to": {
            "type": "string",
            "description": "Recipient account address.",
            "maxLength": 50,
            "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e"
          },
          "value": { "type": "string", "description": "Amount to send.", "maxLength": 50, "example": "140" },
          "data": { "type": "string", "description": "Data to send to Smart Contract", "maxLength": 10000 },
          "nonce": { "type": "number", "description": "Nonce", "example": 12345 }
        }
      },
      "TransferVetBlockchain": {
        "type": "object",
        "properties": {
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in VET",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "minLength": 6,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "data": {
            "type": "string",
            "maxLength": 10000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              }
            }
          }
        },
        "required": ["to", "amount", "fromPrivateKey"]
      },
      "TransferVetBlockchainKMS": {
        "type": "object",
        "properties": {
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in VET",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "data": {
            "type": "string",
            "maxLength": 10000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              }
            }
          }
        },
        "required": ["to", "amount", "signatureId"]
      },
      "XlmWallet": {
        "type": "object",
        "required": ["address", "secret"],
        "properties": {
          "address": {
            "description": "Generated account address.",
            "example": "GDKYMXOAJ5MK4EVIHHNWRGAAOUZMNZYAETMHFCD6JCVBPZ77TUAZFPKT",
            "type": "string"
          },
          "secret": {
            "description": "Generated secret for account.",
            "example": "SCVVKNLBHOWBNJYHD3CNROOA2P3K35I5GNTYUHLLMUHMHWQYNEI7LVED",
            "type": "string"
          }
        }
      },
      "BnbWallet": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Generated account address.",
            "example": "tbnb1sfj9981j2eo1ij2e09",
            "type": "string"
          },
          "privateKey": {
            "description": "Generated private key for account.",
            "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
            "type": "string"
          }
        }
      },
      "XlmTx": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for this transaction.",
            "example": "749e4f8933221b9942ef38a02856803f379789ec8d971f1f60535db70135673e"
          },
          "paging_token": {
            "type": "string",
            "description": "A cursor value for use in pagination.",
            "example": "438086668288"
          },
          "successful": {
            "type": "boolean",
            "description": "Indicates if this transaction was successful or not.",
            "example": true
          },
          "hash": {
            "type": "string",
            "description": "A hex-encoded SHA-256 hash of this transaction’s XDR-encoded form.",
            "example": "749e4f8933221b9942ef38a02856803f379789ec8d971f1f60535db70135673e"
          },
          "ledger": {
            "type": "number",
            "description": "The sequence number of the ledger that this transaction was included in.",
            "example": 102
          },
          "created_at": {
            "type": "string",
            "description": "The date this transaction was created.",
            "example": "2019-10-30T09:34:07Z"
          },
          "source_account": {
            "type": "string",
            "description": "The account that originates the transaction.",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H"
          },
          "source_account_sequence": {
            "type": "string",
            "description": "The source account’s sequence number that this transaction consumed.",
            "example": "1"
          },
          "fee_paid": {
            "type": "number",
            "description": "The fee (in stroops) paid by the source account to apply this transaction to the ledger.",
            "example": 1000
          },
          "fee_charged": { "type": "number", "example": 1000 },
          "max_fee": {
            "type": "number",
            "description": "The maximum fee (in stroops) that the source account was willing to pay.",
            "example": 1000
          },
          "operation_count": {
            "type": "number",
            "description": "The number of operations contained within this transaction.",
            "example": 10
          },
          "envelope_xdr": {
            "type": "string",
            "description": "A base64 encoded string of the raw TransactionEnvelope XDR struct for this transaction.",
            "example": "AAAAAGL8HQvQkbK2HA3WVjRrKmjX00fG8sLI7m0ERwJW/AX3AAAD6AAAAAAAAAABAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAEH3Rayw4M0iCLoEe96rPFNGYim8AVHJU0z4ebYZW4JwBY0V4XYoAAAAAAAAAAAAAAAAAAN2+SherpNcNX0imC680fIBdpQfgBwIuqFOgmlobpwLJAAAAF0h26AAAAAAAAAAAAAAAAAAAlRt2go9sp7E1a5ZWvr7vin4UPrFQThpQax1lOFm33AAAABdIdugAAAAAAAAAAAAAAAAAmv+knlR6JR2VqWeU0k/4FgvZ/tSV5DEY4gu0iOTKgpUAAAAXSHboAAAAAAAAAAAAAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bAAAAF0h26AAAAAABAAAAAACVG3aCj2ynsTVrlla+vu+KfhQ+sVBOGlBrHWU4WbfcAAAABgAAAAFURVNUAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bf/////////8AAAABAAAAAJr/pJ5UeiUdlalnlNJP+BYL2f7UleQxGOILtIjkyoKVAAAABgAAAAFURVNUAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bf/////////8AAAABAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bAAAAAQAAAAAAlRt2go9sp7E1a5ZWvr7vin4UPrFQThpQax1lOFm33AAAAAFURVNUAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bAAAJGE5yoAAAAAABAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bAAAAAQAAAACa/6SeVHolHZWpZ5TST/gWC9n+1JXkMRjiC7SI5MqClQAAAAFURVNUAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bAAAJGE5yoAAAAAAAAAAAAAAAAABKBB+2UBMP/abwcm/M1TXO+/JQWhPwkalgqizKmXyRIQx9cN3sY5YAAAAAAAAAAARW/AX3AAAAQDX5vrTLWyUxzrvpeEghwlfZYjb8PhnV+vjXAQE+iCNotx2S0qDtnNppNy9p0qlsXtKKyZqn036kHMFGQ7RxBQ3GYc0bAAAAQOquRvJeUiQ8uDcNGUnIxXT0xaHe91JZHCVjPEm6j9Biii954p9o7Muer9B9ipn6O4Y+4oiF9NbUxyeqh1VJnQw4WbfcAAAAQG/GEctb+uefyEvdeP8V61fCvvdGCW7KoH7iLXxtvanGk9CyydtRGEIxu66hPdUKKbXpXPEKWvnAAp5V+XQqjQnkyoKVAAAAQNTyKwB94kyBjjczpFwMFVtbhHtugo+DYeQKN13jQUjWQDSgistLE+TDrxlxW0qiIhl/GkOdVLMtG6YhfZeVOQU="
          },
          "result_xdr": {
            "type": "string",
            "description": "A base64 encoded string of the raw TransactionResult XDR struct for this transaction.",
            "example": "AAAAAAAAA+gAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAA="
          },
          "result_meta_xdr": {
            "type": "string",
            "description": "A base64 encoded string of the raw TransactionMeta XDR struct for this transaction",
            "example": "AAAAAQAAAAAAAAAKAAAAAwAAAAMAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9w3gtrOnY/wYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9wx9cTtJ2fwYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAAAAAAAAAAQfdFrLDgzSIIugR73qs8U0ZiKbwBUclTTPh5thlbgnAFjRXhdigAAAAAAZgAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAZgAAAAAAAAAAYvwdC9CRsrYcDdZWNGsqaNfTR8bywsjubQRHAlb8BfcMfXE7Sdn8GAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAZgAAAAAAAAAAYvwdC9CRsrYcDdZWNGsqaNfTR8bywsjubQRHAlb8BfcMfXEkAWMUGAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZgAAAAAAAAAA3b5KF6uk1w1fSKYLrzR8gF2lB+AHAi6oU6CaWhunAskAAAAXSHboAAAAAGYAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAADAAAAAwAAAGYAAAAAAAAAAGL8HQvQkbK2HA3WVjRrKmjX00fG8sLI7m0ERwJW/AX3DH1xJAFjFBgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAGYAAAAAAAAAAGL8HQvQkbK2HA3WVjRrKmjX00fG8sLI7m0ERwJW/AX3DH1xDLjsLBgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGYAAAAAAAAAAACVG3aCj2ynsTVrlla+vu+KfhQ+sVBOGlBrHWU4WbfcAAAAF0h26AAAAABmAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAMAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9wx9cQy47CwYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9wx9cPVwdUQYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAAAAAAAAACa/6SeVHolHZWpZ5TST/gWC9n+1JXkMRjiC7SI5MqClQAAABdIdugAAAAAZgAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAZgAAAAAAAAAAYvwdC9CRsrYcDdZWNGsqaNfTR8bywsjubQRHAlb8BfcMfXD1cHVEGAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAZgAAAAAAAAAAYvwdC9CRsrYcDdZWNGsqaNfTR8bywsjubQRHAlb8BfcMfXDeJ/5cGAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZgAAAAAAAAAA2lpYuiO4618LRyYyH4O9BN88OuR9eFuVBN0VesZhzRsAAAAXSHboAAAAAGYAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAADAAAAAwAAAGYAAAAAAAAAAACVG3aCj2ynsTVrlla+vu+KfhQ+sVBOGlBrHWU4WbfcAAAAF0h26AAAAABmAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAGYAAAAAAAAAAACVG3aCj2ynsTVrlla+vu+KfhQ+sVBOGlBrHWU4WbfcAAAAF0h26AAAAABmAAAAAAAAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGYAAAABAAAAAACVG3aCj2ynsTVrlla+vu+KfhQ+sVBOGlBrHWU4WbfcAAAAAVRFU1QAAAAA2lpYuiO4618LRyYyH4O9BN88OuR9eFuVBN0VesZhzRsAAAAAAAAAAH//////////AAAAAQAAAAAAAAAAAAAAAwAAAAMAAABmAAAAAAAAAACa/6SeVHolHZWpZ5TST/gWC9n+1JXkMRjiC7SI5MqClQAAABdIdugAAAAAZgAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAABmAAAAAAAAAACa/6SeVHolHZWpZ5TST/gWC9n+1JXkMRjiC7SI5MqClQAAABdIdugAAAAAZgAAAAAAAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAAAAQAAAACa/6SeVHolHZWpZ5TST/gWC9n+1JXkMRjiC7SI5MqClQAAAAFURVNUAAAAANpaWLojuOtfC0cmMh+DvQTfPDrkfXhblQTdFXrGYc0bAAAAAAAAAAB//////////wAAAAEAAAAAAAAAAAAAAAIAAAADAAAAZgAAAAEAAAAAAJUbdoKPbKexNWuWVr6+74p+FD6xUE4aUGsdZThZt9wAAAABVEVTVAAAAADaWli6I7jrXwtHJjIfg70E3zw65H14W5UE3RV6xmHNGwAAAAAAAAAAf/////////8AAAABAAAAAAAAAAAAAAABAAAAZgAAAAEAAAAAAJUbdoKPbKexNWuWVr6+74p+FD6xUE4aUGsdZThZt9wAAAABVEVTVAAAAADaWli6I7jrXwtHJjIfg70E3zw65H14W5UE3RV6xmHNGwAACRhOcqAAf/////////8AAAABAAAAAAAAAAAAAAACAAAAAwAAAGYAAAABAAAAAJr/pJ5UeiUdlalnlNJP+BYL2f7UleQxGOILtIjkyoKVAAAAAVRFU1QAAAAA2lpYuiO4618LRyYyH4O9BN88OuR9eFuVBN0VesZhzRsAAAAAAAAAAH//////////AAAAAQAAAAAAAAAAAAAAAQAAAGYAAAABAAAAAJr/pJ5UeiUdlalnlNJP+BYL2f7UleQxGOILtIjkyoKVAAAAAVRFU1QAAAAA2lpYuiO4618LRyYyH4O9BN88OuR9eFuVBN0VesZhzRsAAAkYTnKgAH//////////AAAAAQAAAAAAAAAAAAAAAwAAAAMAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9wx9cN4n/lwYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9wAAAAA7msYYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAAAAAAAAABKBB+2UBMP/abwcm/M1TXO+/JQWhPwkalgqizKmXyRIQx9cN3sY5YAAAAAZgAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA=="
          },
          "fee_meta_xdr": {
            "type": "string",
            "description": "A base64 encoded string of the raw LedgerEntryChanges XDR struct produced by taking fees for this transaction.",
            "example": "AAAAAgAAAAMAAAABAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9w3gtrOnZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAABmAAAAAAAAAABi/B0L0JGythwN1lY0aypo19NHxvLCyO5tBEcCVvwF9w3gtrOnY/wYAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA=="
          },
          "memo": {
            "type": "string",
            "description": "The optional memo attached to a transaction. Usually used as an account distiguisher.",
            "example": "12345"
          },
          "memo_type": {
            "type": "string",
            "description": "The type of memo.",
            "example": "MEMO_TEXT",
            "enum": ["MEMO_TEXT", "MEMO_ID", "MEMO_HASH", "MEMO_RETURN"]
          },
          "signatures": {
            "type": "array",
            "description": "An array of signatures used to sign this transaction.",
            "items": { "type": "string" },
            "example": [
              "Nfm+tMtbJTHOu+l4SCHCV9liNvw+GdX6+NcBAT6II2i3HZLSoO2c2mk3L2nSqWxe0orJmqfTfqQcwUZDtHEFDQ==",
              "6q5G8l5SJDy4Nw0ZScjFdPTFod73UlkcJWM8SbqP0GKKL3nin2jsy56v0H2Kmfo7hj7iiIX01tTHJ6qHVUmdDA==",
              "b8YRy1v655/IS914/xXrV8K+90YJbsqgfuItfG29qcaT0LLJ21EYQjG7rqE91Qoptelc8Qpa+cACnlX5dCqNCQ==",
              "1PIrAH3iTIGONzOkXAwVW1uEe26Cj4Nh5Ao3XeNBSNZANKCKy0sT5MOvGXFbSqIiGX8aQ51Usy0bpiF9l5U5BQ=="
            ]
          }
        }
      },
      "XlmAccount": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for this account.",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H"
          },
          "account_id": {
            "type": "string",
            "description": "This account’s public key encoded in a base32 string representation.",
            "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H"
          },
          "sequence": {
            "type": "string",
            "description": "This account’s current sequence number. For use when submitting this account’s next transaction.",
            "example": "1"
          },
          "subentry_count": {
            "type": "number",
            "description": "The number of subentries on this account.",
            "example": 0
          },
          "last_modified_ledger": {
            "type": "number",
            "description": "The ID of the last ledger that included changes to this account.",
            "example": 102
          },
          "thresholds": {
            "properties": {
              "low_threshold": {
                "type": "number",
                "description": "The weight required for a valid transaction including the Allow Trust and Bump Sequence operations.",
                "example": 0
              },
              "med_threshold": {
                "type": "number",
                "description": "The weight required for a valid transaction including the Create Account, Payment, Path Payment, Manage Buy Offer, Manage Sell Offer, Create Passive Sell Offer, Change Trust, Inflation, and Manage Data operations.",
                "example": 0
              },
              "high_threshold": {
                "type": "number",
                "description": "The weight required for a valid transaction including the Account Merge and Set Options operations.",
                "example": 0
              }
            },
            "type": "object",
            "description": "Operations have varying levels of access. This field specifies thresholds for different access levels, as well as the weight of the master key."
          },
          "flags": {
            "properties": {
              "auth_required": {
                "type": "boolean",
                "description": "If set to true, anyone who wants to hold an asset issued by this account must first be approved by this account.",
                "example": false
              },
              "auth_revocable": {
                "type": "boolean",
                "description": "If set to true, this account can freeze the balance of a holder of an asset issued by this account.",
                "example": false
              },
              "auth_immutable": {
                "type": "boolean",
                "description": "If set to true, none of the following flags can be changed.",
                "example": false
              }
            },
            "type": "object",
            "description": "Flags denote the enabling/disabling of certain asset issuer privileges."
          },
          "balances": {
            "type": "array",
            "description": "The assets this account holds.",
            "items": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "string",
                  "description": "The number of units of an asset held by this account.",
                  "example": "99.9999000"
                },
                "limit": {
                  "type": "string",
                  "description": "The maximum amount of this asset that this account is willing to accept. Specified when opening a trustline.",
                  "example": "99.9999000"
                },
                "buying_liabilities": {
                  "type": "string",
                  "description": "The sum of all buy offers owned by this account for this asset.",
                  "example": "0.0000000"
                },
                "selling_liabilities": {
                  "type": "string",
                  "description": "The sum of all sell offers owned by this account for this asset.",
                  "example": "0.0000000"
                },
                "asset_type": {
                  "type": "string",
                  "description": "Either native, credit_alphanum4, or credit_alphanum12.",
                  "example": "native"
                },
                "asset_code": {
                  "type": "string",
                  "description": "The code for this asset.",
                  "example": "EURT"
                },
                "asset_issuer": {
                  "type": "string",
                  "description": "The Stellar address of this asset’s issuer.",
                  "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H"
                }
              }
            }
          },
          "signers": {
            "type": "array",
            "description": "The public keys and associated weights that can be used to authorize transactions for this account. Used for multi-sig.",
            "items": {
              "type": "object",
              "properties": {
                "weight": {
                  "type": "number",
                  "description": "The numerical weight of a signer. Used to determine if a transaction meets the threshold requirements.",
                  "example": 1
                },
                "key": {
                  "type": "string",
                  "description": "A hash of characters dependent on the signer type.",
                  "example": "GBRPYHIL2CI3FNQ4BXLFMNDLFJUNPU2HY3ZMFSHONUCEOASW7QC7OX2H"
                },
                "type": {
                  "type": "string",
                  "description": "The type of hash for this signer.",
                  "example": "ed25519_public_key",
                  "enum": ["sha256_hash", "ed25519_public_key", "preauth_tx"]
                }
              }
            }
          },
          "data": { "properties": {}, "type": "object", "description": "An array of account data fields." }
        }
      },
      "XlmLedger": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for this ledger.",
            "example": "63d98f536ee68d1b27b5b89f23af5311b7569a24faf1403ad0b52b633b07be99"
          },
          "paging_token": {
            "type": "string",
            "description": "A cursor value for use in pagination.",
            "example": "4294967296"
          },
          "hash": {
            "type": "string",
            "description": "A hex-encoded SHA-256 hash of this ledger’s XDR-encoded form.",
            "example": "63d98f536ee68d1b27b5b89f23af5311b7569a24faf1403ad0b52b633b07be99"
          },
          "sequence": {
            "type": "number",
            "description": "The sequence number of this ledger, and the parameter used in Horizon calls that require a ledger number.",
            "example": 1
          },
          "successful_transaction_count": {
            "type": "number",
            "description": "The number of successful transactions in this ledger.",
            "example": 0
          },
          "failed_transaction_count": {
            "type": "number",
            "description": "The number of failed transactions in this ledger.",
            "example": 0
          },
          "operation_count": {
            "type": "number",
            "description": "The number of operations applied in this ledger.",
            "example": 0
          },
          "closed_at": {
            "type": "string",
            "description": "An ISO 8601 formatted string of when this ledger was closed.",
            "example": "1970-01-01T00:00:00Z"
          },
          "total_coins": {
            "type": "string",
            "description": "The total number of lumens in circulation.",
            "example": "100000000000.0000000"
          },
          "fee_pool": {
            "type": "string",
            "description": "The sum of all transaction fees.",
            "example": "0.0000000"
          },
          "base_fee_in_stroops": {
            "type": "number",
            "description": "The fee the network charges per operation in a transaction.",
            "example": 100
          },
          "base_reserve_in_stroops": {
            "type": "number",
            "description": "The reserve the network uses when calculating an account’s minimum balance.",
            "example": 100000000
          },
          "max_tx_set_size": {
            "type": "number",
            "description": "The maximum number of transactions validators have agreed to process in a given ledger.",
            "example": 100
          },
          "protocol_version": {
            "type": "number",
            "description": "The protocol version that the Stellar network was running when this ledger was committed.",
            "example": 0
          },
          "header_xdr": {
            "type": "string",
            "description": "A base64 encoded string of the raw LedgerHeader xdr struct for this ledger.",
            "example": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABXKi4y/ySKB7DnD9H20xjB+s0gtswIwz1XdSWYaBJaFgAAAAEN4Lazp2QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZAX14QAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
          }
        }
      },
      "VetBlock": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "format": "uint32",
            "description": "block number (height)",
            "example": 325324
          },
          "id": {
            "type": "string",
            "format": "bytes32",
            "description": "block identifier",
            "example": "0x0004f6cc88bb4626a92907718e82f255b8fa511453a78e8797eb8cea3393b215"
          },
          "size": {
            "type": "integer",
            "format": "uint32",
            "description": "RLP encoded block size in bytes",
            "example": 373
          },
          "parentID": {
            "type": "string",
            "format": "bytes32",
            "description": "parent block ID",
            "example": "0x0004f6cb730dbd90fed09d165bfdf33cc0eed47ec068938f6ee7b7c12a4ea98d"
          },
          "timestamp": {
            "type": "integer",
            "format": "uint64",
            "description": "block unix timestamp",
            "example": 1533267900
          },
          "gasLimit": {
            "type": "integer",
            "format": "uint64",
            "description": "block gas limit (max allowed accumulative gas usage of transactions)",
            "example": 11253579
          },
          "beneficiary": {
            "type": "string",
            "format": "bytes32",
            "description": "Address of account to receive block reward",
            "example": "0xb4094c25f86d628fdd571afc4077f0d0196afb48"
          },
          "gasUsed": {
            "type": "integer",
            "format": "uint64",
            "description": "accumulative gas usage of transactions",
            "example": 21000
          },
          "totalScore": {
            "type": "integer",
            "format": "uint64",
            "description": "sum of all ancestral blocks' score",
            "example": 1029988
          },
          "txsRoot": {
            "type": "string",
            "format": "bytes32",
            "description": "root hash of transactions in the block",
            "example": "0x89dfd9fcd10c9e53d68592cf8b540b280b72d381b868523223992f3e09a806bb"
          },
          "txsFeatures": {
            "type": "integer",
            "format": "uint32",
            "description": "supported txs features bitset",
            "example": 0
          },
          "stateRoot": {
            "type": "string",
            "format": "bytes32",
            "description": "root hash of accounts state",
            "example": "0x86bcc6d214bc9d8d0dedba1012a63c8317d19ce97f60c8a2ef5c59bbd40d4261"
          },
          "receiptsRoot": {
            "type": "string",
            "format": "bytes32",
            "description": "root hash of transaction receipts",
            "example": "0x15787e2533c470e8a688e6cd17a1ee12d8457778d5f82d2c109e2d6226d8e54e"
          },
          "signer": {
            "type": "string",
            "format": "bytes20",
            "description": "the one who signed this block",
            "example": "0xab7b27fc9e7d29f9f2e5bd361747a5515d0cc2d1"
          },
          "transactions": {
            "type": "array",
            "description": "transactions IDs",
            "items": {
              "type": "string",
              "format": "bytes32",
              "description": "transaction ID",
              "example": "0x284bba50ef777889ff1a367ed0b38d5e5626714477c40de38d71cedd6f9fa477"
            }
          }
        }
      },
      "VetTx": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "0x24f691abab680972437028af22bc7a43c3fbe8d6d7eefc420dea2daf554758a7"
          },
          "chainTag": { "type": "string", "example": "0x27" },
          "blockRef": { "type": "string", "example": "0x0011bbb748852599" },
          "expiration": { "type": "number", "example": 720 },
          "clauses": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "to": { "type": "string", "example": "0xc6a3007e8e0d959ada56eaa003ebd1d61364cb4f" },
                "value": { "type": "string", "example": "115070300000000000000000000" },
                "data": { "type": "string", "example": "0x" }
              }
            }
          },
          "gasPriceCoef": { "type": "number", "example": 120 },
          "gas": { "type": "number", "example": 21000 },
          "origin": { "type": "string", "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e" },
          "nonce": { "type": "string", "example": "0x48ca1882cf3726ee" },
          "size": { "type": "number", "example": 132 },
          "meta": {
            "properties": {
              "blockID": {
                "type": "string",
                "example": "0x0011bbb9925da1b54035e2a870abe336bc79a3b083303646b87a3315c11c963b"
              },
              "blockNumber": { "type": "number", "example": 1162169 },
              "blockTimestamp": { "type": "number", "example": 1541643760 }
            },
            "type": "object"
          },
          "blockNumber": { "type": "number" }
        }
      },
      "VetTxReceipt": {
        "type": "object",
        "properties": {
          "gasUsed": { "type": "number", "example": 21000 },
          "gasPayer": { "type": "string", "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e" },
          "paid": { "type": "string", "example": "0x1ac942860d7100728" },
          "reward": { "type": "string", "example": "0x8092d8e9da1e688c" },
          "reverted": { "type": "boolean", "example": false },
          "meta": {
            "properties": {
              "blockID": {
                "type": "string",
                "example": "0x0011bbb9925da1b54035e2a870abe336bc79a3b083303646b87a3315c11c963b"
              },
              "blockNumber": { "type": "number", "example": 1162169 },
              "blockTimestamp": { "type": "number", "example": 1541643760 },
              "txID": {
                "type": "string",
                "example": "0x24f691abab680972437028af22bc7a43c3fbe8d6d7eefc420dea2daf554758a7"
              },
              "txOrigin": { "type": "string", "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e" }
            },
            "type": "object"
          },
          "outputs": {
            "description": "List of recipient addresses and amounts to send to each of them.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "events": { "type": "array", "items": { "type": "object" }, "example": [] },
                "transfers": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "sender": { "type": "string", "example": "0x5034aa590125b64023a0262112b98d72e3c8e40e" },
                      "recipient": {
                        "type": "string",
                        "example": "0xc6a3007e8e0d959ada56eaa003ebd1d61364cb4f"
                      },
                      "amount": { "type": "string", "example": "0x5f2f157661ad625bf00000" }
                    }
                  }
                }
              }
            }
          },
          "blockNumber": { "type": "number", "example": 1162169 },
          "blockHash": {
            "type": "string",
            "example": "0x0011bbb9925da1b54035e2a870abe336bc79a3b083303646b87a3315c11c963b"
          },
          "transactionHash": {
            "type": "string",
            "example": "0x24f691abab680972437028af22bc7a43c3fbe8d6d7eefc420dea2daf554758a7"
          },
          "status": { "type": "string", "example": "0x1" }
        }
      },
      "GenerateCustodialWalletBatch": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "MATIC", "BSC", "ONE", "XDC", "KLAY"],
            "example": "MATIC",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of account, from which the transaction will be initiated."
          },
          "batchCount": {
            "type": "number",
            "maximum": 270,
            "minimum": 0,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 42,
            "maxLength": 43,
            "description": "Owner of the addresses.",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "fromPrivateKey", "batchCount", "owner"]
      },
      "GenerateCustodialWalletBatchPayer": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "MATIC", "BSC", "ONE", "CELO"],
            "example": "MATIC",
            "type": "string"
          },
          "feesCovered": {
            "type": "boolean",
            "example": true,
            "description": "If set to true, blockchain fees will be covered from credits."
          },
          "batchCount": {
            "type": "number",
            "maximum": 270,
            "minimum": 0,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 42,
            "maxLength": 43,
            "description": "Owner of the addresses.",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
          }
        },
        "required": ["chain", "fromPrivateKey", "batchCount", "owner", "feesCovered"]
      },
      "GenerateCustodialWalletBatchKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["MATIC", "ETH", "ONE", "XDC", "KLAY", "BSC"],
            "example": "MATIC",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "batchCount": {
            "type": "number",
            "maximum": 270,
            "minimum": 0,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 42,
            "maxLength": 43,
            "description": "Owner of the addresses.",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "signatureId", "owner", "batchCount"]
      },
      "GenerateCustodialWalletBatchCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of account, from which the transaction will be initiated."
          },
          "batchCount": {
            "type": "number",
            "maximum": 270,
            "minimum": 0,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 42,
            "maxLength": 43,
            "description": "Owner of the addresses.",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "feeCurrency", "fromPrivateKey", "batchCount", "owner"]
      },
      "GenerateCustodialWalletBatchCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "batchCount": {
            "type": "number",
            "maximum": 270,
            "minimum": 0,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 42,
            "maxLength": 43,
            "description": "Owner of the addresses.",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "feeCurrency", "signatureId", "batchCount", "owner"]
      },
      "GenerateCustodialWalletBatchTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of account, from which the transaction will be initiated."
          },
          "batchCount": {
            "type": "number",
            "example": 50,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Owner of the addresses.",
            "example": "TGXh2YJhfwchMGKuzfEJ27W1VEJRKnMdy9"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 5,
            "example": 100,
            "description": "Fee limit to be set, in TRX"
          }
        },
        "required": ["chain", "feeLimit", "fromPrivateKey", "batchCount", "owner"]
      },
      "GenerateCustodialWalletBatchTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "from": {
            "type": "string",
            "description": "Sender address.",
            "example": "TGXh2YJhfwchMGKuzfEJ27W1VEJRKnMdy9"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "batchCount": {
            "type": "number",
            "example": 50,
            "description": "Number of addresses to generate."
          },
          "owner": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Owner of the addresses.",
            "example": "TGXh2YJhfwchMGKuzfEJ27W1VEJRKnMdy9"
          },
          "feeLimit": {
            "type": "number",
            "example": 100,
            "minimum": 5,
            "description": "Fee limit to be set, in TRX"
          }
        },
        "required": ["chain", "signatureId", "batchCount", "from", "feeLimit", "owner"]
      },
      "GenerateCustodialWalletTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          },
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "enableFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC20 tokens, it should be marked as true."
          },
          "enableNonFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC721 tokens, it should be marked as true."
          },
          "enableSemiFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC1155 tokens, it should be marked as true. Not supported for TRON."
          },
          "enableBatchTransactions": {
            "type": "boolean",
            "example": false,
            "description": "If address should support batch transfers of the assets, it should be marked as true."
          }
        },
        "required": [
          "chain",
          "feeLimit",
          "signatureId",
          "from",
          "enableFungibleTokens",
          "enableNonFungibleTokens",
          "enableSemiFungibleTokens",
          "enableBatchTransactions"
        ]
      },
      "GenerateCustodialWalletCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of account, from which the transaction will be initiated."
          },
          "enableFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC20 tokens, it should be marked as true."
          },
          "enableNonFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC721 tokens, it should be marked as true."
          },
          "enableSemiFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC1155 tokens, it should be marked as true."
          },
          "enableBatchTransactions": {
            "type": "boolean",
            "example": false,
            "description": "If address should support batch transfers of the assets, it should be marked as true."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": [
          "chain",
          "feeCurrency",
          "fromPrivateKey",
          "enableFungibleTokens",
          "enableNonFungibleTokens",
          "enableSemiFungibleTokens",
          "enableBatchTransactions"
        ]
      },
      "GenerateCustodialWallet": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of account, from which the transaction will be initiated."
          },
          "enableFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC20 tokens, it should be marked as true."
          },
          "enableNonFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC721 tokens, it should be marked as true."
          },
          "enableSemiFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC1155 tokens, it should be marked as true."
          },
          "enableBatchTransactions": {
            "type": "boolean",
            "example": false,
            "description": "If address should support batch transfers of the assets, it should be marked as true."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": [
          "chain",
          "fromPrivateKey",
          "enableFungibleTokens",
          "enableNonFungibleTokens",
          "enableSemiFungibleTokens",
          "enableBatchTransactions"
        ]
      },
      "GenerateCustodialWalletKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["ETH", "ONE", "BSC", "MATIC"],
            "example": "ETH",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "enableFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC20 tokens, it should be marked as true."
          },
          "enableNonFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC721 tokens, it should be marked as true."
          },
          "enableSemiFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC1155 tokens, it should be marked as true."
          },
          "enableBatchTransactions": {
            "type": "boolean",
            "example": false,
            "description": "If address should support batch transfers of the assets, it should be marked as true."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": [
          "chain",
          "signatureId",
          "enableFungibleTokens",
          "enableNonFungibleTokens",
          "enableSemiFungibleTokens",
          "enableBatchTransactions"
        ]
      },
      "GenerateCustodialWalletCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["CELO"],
            "example": "CELO",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "enableFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC20 tokens, it should be marked as true."
          },
          "enableNonFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC721 tokens, it should be marked as true."
          },
          "enableSemiFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC1155 tokens, it should be marked as true."
          },
          "enableBatchTransactions": {
            "type": "boolean",
            "example": false,
            "description": "If address should support batch transfers of the assets, it should be marked as true."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to the transaction. If not present, last known nonce will be used."
          }
        },
        "required": [
          "chain",
          "feeCurrency",
          "signatureId",
          "enableFungibleTokens",
          "enableNonFungibleTokens",
          "enableSemiFungibleTokens",
          "enableBatchTransactions"
        ]
      },
      "GenerateCustodialWalletTron": {
        "type": "object",
        "properties": {
          "chain": {
            "description": "Blockchain to work with.",
            "enum": ["TRON"],
            "example": "TRON",
            "type": "string"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of account, from which the transaction will be initiated."
          },
          "enableFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC20 tokens, it should be marked as true."
          },
          "enableNonFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC721 tokens, it should be marked as true."
          },
          "enableSemiFungibleTokens": {
            "type": "boolean",
            "example": false,
            "description": "If address should support ERC1155 tokens, it should be marked as true. Not supported for TRON."
          },
          "enableBatchTransactions": {
            "type": "boolean",
            "example": false,
            "description": "If address should support batch transfers of the assets, it should be marked as true."
          }
        },
        "required": [
          "chain",
          "feeLimit",
          "fromPrivateKey",
          "enableFungibleTokens",
          "enableNonFungibleTokens",
          "enableSemiFungibleTokens",
          "enableBatchTransactions"
        ]
      },
      "TransactionHash": {
        "type": "object",
        "properties": {
          "txId": {
            "description": "TX hash of successful transaction.",
            "example": "c83f8818db43d9ba4accfe454aa44fc33123d47a4f89d47b314d6748eb0e9bc9",
            "type": "string"
          }
        },
        "required": ["txId"]
      },
      "Data": {
        "type": "object",
        "properties": {
          "data": {
            "description": "Result of the method, if the method was read only.",
            "example": 2,
            "oneOf": [
              { "type": "object" },
              { "type": "string" },
              { "type": "number" },
              { "type": "array" },
              { "type": "boolean" }
            ]
          }
        },
        "required": ["data"]
      },
      "SignatureId": {
        "type": "object",
        "properties": {
          "signatureId": {
            "format": "uuid",
            "description": "ID of prepared payment template to sign. This is should be stored on a client side to retrieve ID of the blockchain transaction, when signing application signs the transaction and broadcasts it to the blockchain.",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "required": ["signatureId"]
      },
      "OffchainTransactionResult": {
        "type": "object",
        "properties": {
          "id": {
            "description": "ID of withdrawal. If transaction is not valid in blockchain, use this id to cancel withdrawal.",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "txId": {
            "description": "TX hash of successful transaction.",
            "example": "c83f8818db43d9ba4accfe454aa44fc33123d47a4f89d47b314d6748eb0e9bc9",
            "type": "string"
          },
          "completed": {
            "description": "If set to \"true\", the withdrawal has been completed in the virtual account; if set to \"false\", the withdrawal has not been completed and you have to <a href=\"https://apidoc.tatum.io/tag/Withdrawal#operation/completeWithdrawal\" target=\"_blank\">complete it manually</a>",
            "example": true,
            "type": "boolean"
          }
        },
        "required": ["txId", "id", "completed"]
      },
      "OffchainTransactionSignatureResult": {
        "type": "object",
        "properties": {
          "signatureId": {
            "description": "ID of prepared payment template to sign. This is should be stored on a client side to retrieve ID of the blockchain transaction, when signing application signs the transaction and broadcasts it to the blockchain.",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "format": "uuid",
            "type": "string"
          }
        },
        "required": ["id", "signatureId"]
      },
      "Url": {
        "properties": { "url": { "description": "QR Code as data URL", "type": "string" } },
        "type": "object"
      },
      "VirtualCurrency": {
        "properties": {
          "name": {
            "description": "Virtual currency name. Must be prefixed with 'VC_'.",
            "example": "VC_VIRTUAL",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "supply": {
            "description": "Supply of virtual currency.",
            "maxLength": 38,
            "minLength": 1,
            "example": "1000000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "basePair": {
            "description": "Base pair for virtual currency. Transaction value will be calculated according to this base pair. e.g. 1 VC_VIRTUAL is equal to 1 BTC, if basePair is set to BTC.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WBTC",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "BTC",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "customer": { "$ref": "#/components/schemas/CustomerRegistration" },
          "description": {
            "description": "Used as a description within Tatum system.",
            "example": "My Virtual Token description.",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "accountCode": {
            "description": "For bookkeeping to distinct account purpose.",
            "maxLength": 50,
            "example": "AC_1011_B",
            "minLength": 1,
            "type": "string"
          },
          "accountNumber": {
            "description": "Account number from external system.",
            "example": "1234567890",
            "type": "string",
            "minLength": 1,
            "maxLength": 50
          },
          "accountingCurrency": {
            "description": "All transaction will be billed in this currency for created account associated with this currency. If not set, EUR is used. ISO-4217",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BBD",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LKR",
              "LRD",
              "LSL",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MMK",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "USD",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "XCD",
              "XDR",
              "XOF",
              "XPF",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "USD",
            "maxLength": 3,
            "minLength": 3,
            "type": "string"
          }
        },
        "required": ["basePair", "name", "supply"],
        "type": "object"
      },
      "VC": {
        "properties": {
          "name": {
            "description": "Virtual currency name. Must be prefixed with 'VC_'.",
            "example": "VC_VIRTUAL",
            "type": "string"
          },
          "supply": { "description": "Supply of virtual currency.", "example": "1000000", "type": "string" },
          "accountId": {
            "description": "Virtual currency account.",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "default": 1,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "precision": {
            "type": "number",
            "example": 6,
            "description": "Number of decimal places of this virtual currency."
          },
          "trcType": { "type": "string", "example": "TRC10", "description": "Type of Tron token." },
          "basePair": {
            "description": "Base pair for virtual currency. Transaction value will be calculated according to this base pair. e.g. 1 VC_VIRTUAL is equal to 1 BTC, if basePair is set to BTC.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "WBTC",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "BTC",
            "type": "string"
          },
          "customerId": {
            "description": "ID of customer associated with virtual currency.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "description": {
            "description": "Used as a description within Tatum system.",
            "example": "My Virtual Token description.",
            "type": "string"
          },
          "erc20Address": {
            "description": "Address of ERC20 token, when virtual currency is based on the Ethereum blockchain.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "issuerAccount": {
            "description": "Blockchain account for XLM or XRP based virtual currencies, which is marked as the issuer of the custom blockchain asset.",
            "example": "GDKYMXOAJ5MK4EVIHHNWRGAAOUZMNZYAETMHFCD6JCVBPZ77TUAZFPKT",
            "type": "string"
          },
          "chain": {
            "description": "Blockchain, on which this virtual currency is paired on. Not present, when Tatum's private ledger is used as a base ledger.",
            "example": "ETH",
            "type": "string",
            "enum": ["ETH", "XRP", "XLM"]
          },
          "initialAddress": {
            "description": "Ethereum address, where initial supply was minted, when virtual currency is based on the Ethereum blockchain.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          }
        },
        "required": ["basePair", "baseRate", "name", "accountId", "supply"],
        "type": "object"
      },
      "VirtualCurrencyUpdate": {
        "properties": {
          "name": {
            "description": "Virtual currency name, which will be updated. It is not possible to update the name of the virtual currency.",
            "example": "VC_VIRTUAL",
            "maxLength": 30,
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "type": "string"
          },
          "baseRate": {
            "type": "number",
            "example": 1,
            "default": 1,
            "minimum": 0,
            "description": "Exchange rate of the base pair. Each unit of the created curency will represent value of baseRate*1 basePair."
          },
          "basePair": {
            "description": "Base pair for virtual currency. Transaction value will be calculated according to this base pair. e.g. 1 VC_VIRTUAL is equal to 1 BTC, if basePair is set to BTC.",
            "enum": [
              "AED",
              "AFN",
              "ALL",
              "AMD",
              "ANG",
              "AOA",
              "ARS",
              "AUD",
              "AWG",
              "AZN",
              "BAM",
              "BAT",
              "BBD",
              "BCH",
              "BDT",
              "BGN",
              "BHD",
              "BIF",
              "BMD",
              "BND",
              "BOB",
              "BRL",
              "BSD",
              "BTC",
              "BTN",
              "BWP",
              "BYN",
              "BYR",
              "BZD",
              "CAD",
              "CDF",
              "CHF",
              "CLF",
              "CLP",
              "CNY",
              "COP",
              "CRC",
              "CUC",
              "CUP",
              "CVE",
              "CZK",
              "DJF",
              "DKK",
              "DOP",
              "DOGE",
              "DZD",
              "EGP",
              "ERN",
              "ETB",
              "ETH",
              "EUR",
              "FJD",
              "FKP",
              "FLOW",
              "FUSD",
              "FREE",
              "GMC",
              "GMC_BSC",
              "RMD",
              "GBP",
              "GEL",
              "GGP",
              "GHS",
              "GIP",
              "GMD",
              "GNF",
              "GTQ",
              "GYD",
              "HKD",
              "HNL",
              "HRK",
              "HTG",
              "HUF",
              "IDR",
              "ILS",
              "IMP",
              "INR",
              "IQD",
              "IRR",
              "ISK",
              "JEP",
              "JMD",
              "JOD",
              "JPY",
              "KES",
              "KGS",
              "KHR",
              "KMF",
              "KPW",
              "KRW",
              "KWD",
              "KYD",
              "KZT",
              "LAK",
              "LBP",
              "LEO",
              "LINK",
              "LKR",
              "LRD",
              "LSL",
              "LTC",
              "LTL",
              "LVL",
              "LYD",
              "MAD",
              "MDL",
              "MGA",
              "MKD",
              "MKR",
              "MMK",
              "MMY",
              "MNT",
              "MOP",
              "MRO",
              "MUR",
              "MVR",
              "MWK",
              "MXN",
              "MYR",
              "MZN",
              "NAD",
              "NGN",
              "NIO",
              "NOK",
              "NPR",
              "NZD",
              "OMR",
              "PAB",
              "PAX",
              "PAXG",
              "PEN",
              "PGK",
              "PHP",
              "PKR",
              "PLN",
              "PYG",
              "QAR",
              "RON",
              "RSD",
              "RUB",
              "RWF",
              "SAR",
              "SBD",
              "SCR",
              "SDG",
              "SEK",
              "SGD",
              "SHP",
              "SLL",
              "SOS",
              "SRD",
              "STD",
              "SVC",
              "SYP",
              "SZL",
              "THB",
              "TJS",
              "TMT",
              "TND",
              "TOP",
              "TRY",
              "TTD",
              "TRON",
              "TUSD",
              "BUSD",
              "TWD",
              "TZS",
              "UAH",
              "UGX",
              "UNI",
              "USD",
              "USDC",
              "USDT",
              "USDT_TRON",
              "USDT_MATIC",
              "UYU",
              "UZS",
              "VEF",
              "VND",
              "VUV",
              "WST",
              "XAF",
              "XAG",
              "XAU",
              "WBTC",
              "XCD",
              "XCON",
              "XDR",
              "XLM",
              "XOF",
              "XPF",
              "XRP",
              "YER",
              "ZAR",
              "ZMK",
              "ZMW",
              "ZWL"
            ],
            "example": "EUR",
            "maxLength": 50,
            "minLength": 3,
            "type": "string"
          }
        },
        "required": ["name"],
        "type": "object"
      },
      "VirtualCurrencyOperation": {
        "properties": {
          "accountId": {
            "description": "Ledger account with currency of the virtual currency, on which the operation will be performed.",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "amount": {
            "description": "Amount of virtual currency to operate within this operation.",
            "maxLength": 38,
            "example": "1.5",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "My Payment",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "reference": {
            "description": "Reference of the payment.",
            "example": "akjsndakjsdn-asd-kjasnd-asdkn-asdjnasjkdn",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "transactionCode": {
            "description": "For bookkeeping to distinct transaction purpose.",
            "example": "1_01_EXTERNAL_CODE",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "recipientNote": {
            "description": "Note visible to both, sender and recipient. Available for both Mint and Revoke operations",
            "example": "Private note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          },
          "counterAccount": {
            "description": "External account identifier. By default, there is no counterAccount present in the transaction.",
            "example": "5e6645712b55823de7ea82f1",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to sender. Available in Revoke operation.",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["accountId", "amount"],
        "type": "object"
      },
      "Wallet": {
        "type": "object",
        "properties": {
          "mnemonic": {
            "description": "Generated mnemonic for wallet.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Generated Extended public key for wallet with derivation path according to BIP44. This key can be used to generate addresses.",
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          }
        }
      },
      "GeneratedAddressEth": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Ethereum address",
            "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
          }
        }
      },
      "GeneratedAddressBtc": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Bitcoin address",
            "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
          }
        }
      },
      "Withdrawal": {
        "properties": {
          "senderAccountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "maxLength": 24,
            "minLength": 24,
            "type": "string"
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "attr": {
            "description": "<p>Used to parametrize withdrawal. Used for XRP withdrawal to define destination tag of recipient, or XLM memo of the recipient, if needed.<br/>\nFor Bitcoin, Litecoin, Bitcoin Cash, used as a change address for left coins from transaction.</p>\n",
            "maxLength": 64,
            "minLength": 1,
            "example": "12345",
            "type": "string"
          },
          "compliant": {
            "description": "Compliance check, if withdrawal is not compliant, it will not be processed.",
            "example": false,
            "type": "boolean"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "12345",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "senderAccountId", "address", "fee"],
        "type": "object"
      },
      "WithdrawalObject": {
        "properties": {
          "id": {
            "description": "ID of the withdrawal",
            "example": "5e68c66581f2ee32bc354088",
            "type": "string"
          },
          "txId": {
            "description": "Transaction ID of broadcast transaction",
            "example": "62BD544D1B9031EFC330A3E855CC3A0D51CA5131455C1AB3BCAC6D243F65460D",
            "type": "string"
          },
          "accountId": {
            "description": "Sender account ID",
            "example": "5e68c66581f2ee32bc354087",
            "type": "string"
          },
          "status": {
            "description": "Status of the withdrawal",
            "example": "InProgress",
            "type": "string",
            "enum": ["InProgress", "Done", "Cancelled"]
          },
          "address": {
            "description": "Blockchain address to send assets to. For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain addresses as a comma separated string.",
            "example": "mpTwPdF8up9kidgcAStriUPwRdnE9MRAg7",
            "maxLength": 10000,
            "minLength": 1,
            "type": "string"
          },
          "reference": {
            "description": "Transaction internal reference - unique identifier within Tatum ledger. In order of failure, use this value to search for problems.",
            "example": "0c64cc04-5412-4e57-a51c-ee5727939bcb",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be withdrawn to blockchain.",
            "maxLength": 38,
            "example": "0.001",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "attr": {
            "description": "<p>Used to parametrize withdrawal. Used for XRP withdrawal to define destination tag of recipient, or XLM memo of the recipient, if needed.<br/>\nFor Bitcoin, Litecoin, Bitcoin Cash, used as a change address for left coins from transaction.</p>\n",
            "maxLength": 64,
            "minLength": 1,
            "example": "12345",
            "type": "string"
          },
          "fee": {
            "description": "Fee to be submitted as a transaction fee to blockchain.",
            "example": "0.0005",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "multipleAmounts": {
            "description": "For BTC, LTC, DOGE and BCH, it is possible to enter list of multiple recipient blockchain amounts. List of recipient addresses must be present in the address field and total sum of amounts must be equal to the amount field.",
            "type": "array",
            "items": { "type": "string", "example": "0.1", "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$" }
          },
          "paymentId": {
            "description": "Identifier of the payment, shown for created Transaction within Tatum sender account.",
            "example": "12345",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "senderNote": {
            "description": "Note visible to owner of withdrawing account",
            "example": "Sender note",
            "maxLength": 500,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["amount", "id", "accountId", "address", "reference", "fee"],
        "type": "object"
      },
      "WithdrawalHint": {
        "additionalProperties": {
          "properties": {
            "address": { "$ref": "#/components/schemas/Address" },
            "amount": { "description": "Balance for address.", "type": "string" }
          },
          "type": "object"
        },
        "description": "Object containing information about balance of Ethereum funds on each address linked to the account, from which withdrawal should be processed.",
        "type": "object"
      },
      "ResponseData": {
        "type": "object",
        "properties": {
          "address": { "$ref": "#/components/schemas/Address" },
          "amount": {
            "description": "Amount of unprocessed transaction outputs, that can be used for withdrawal. Bitcoin, Litecoin, Bitcoin Cash only.",
            "type": "number"
          },
          "vIn": {
            "description": "Last used unprocessed transaction output, that can be used. Bitcoin, Litecoin, Bitcoin Cash only. If -1, it indicates prepared vOut with amount to be transferred to pool address.",
            "type": "string"
          },
          "vInIndex": {
            "description": "Index of last used unprocessed transaction output in raw transaction, that can be used. Bitcoin, Litecoin, Bitcoin Cash only.",
            "type": "integer"
          },
          "scriptPubKey": {
            "type": "string",
            "description": "Script of last unprocessed UTXO. Bitcoin SV only."
          }
        }
      },
      "WithdrawalResponse": {
        "properties": {
          "reference": {
            "description": "Transaction reference of the transaction connected to this withdrawal.",
            "example": "5e6be8e9e6aa436299950c41",
            "type": "string"
          },
          "data": { "items": { "$ref": "#/components/schemas/ResponseData" }, "type": "array" },
          "id": { "description": "ID of withdrawal", "example": "5e68c66581f2ee32bc354087", "type": "string" }
        },
        "type": "object"
      },
      "XrpWallet": {
        "type": "object",
        "required": ["address", "secret"],
        "properties": {
          "address": {
            "description": "Generated account address.",
            "example": "rPRxSZzTFd6Yez3UMxFUPJvnhUhjewpjfV",
            "type": "string"
          },
          "secret": {
            "description": "Generated secret for account.",
            "example": "snSFTHdvSYQKKkYntvEt8cnmZuPJB",
            "type": "string"
          }
        }
      },
      "XrpTx": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "The SHA-512 hash of the transaction",
            "example": "1A32A054B04AC9D6814710DDCA416E72C4CD2D78D6C3DFC06CC9369CC4F6B250"
          },
          "ledger_index": {
            "type": "number",
            "description": "The ledger index of the ledger that includes this transaction.",
            "example": 760469
          },
          "Account": {
            "type": "string",
            "description": "The unique address of the account that initiated the transaction.",
            "example": "rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe"
          },
          "Amount": {
            "type": "string",
            "description": "Amount of transaction, in drops. 1 drop = 0.000001 XRP.",
            "example": "1000000000"
          },
          "Destination": {
            "type": "string",
            "description": "Recipient account address.",
            "example": "rDA3DJBUBjA1X3PtLLFAEXxX31oA5nL3QF"
          },
          "Fee": {
            "type": "string",
            "description": "Integer amount of XRP, in drops, to be destroyed as a cost for distributing this transaction to the network. Some transaction types have different minimum requirements.",
            "example": "12"
          },
          "TransactionType": {
            "type": "string",
            "description": "Type of the transaction. XRp supports more than 18 transaction types. For the payment, Payment type is used.",
            "example": "Payment"
          },
          "Flags": {
            "type": "number",
            "description": "Set of bit-flags for this transaction.",
            "example": 2147483648
          },
          "LastLedgerSequence": {
            "type": "number",
            "description": "Last ledger, in which this transaction could have occured.",
            "example": 760473
          },
          "Sequence": {
            "type": "number",
            "description": "The sequence number of the account sending the transaction. A transaction is only valid if the Sequence number is exactly 1 greater than the previous transaction from the same account.",
            "example": 118697
          },
          "date": {
            "type": "number",
            "description": "Timestamp of the transaction, in Ripple epoch (946684800 seconds after Unix Epoch)",
            "example": 622916620
          },
          "inLedger": {
            "type": "number",
            "description": "Ledger, in which transaction took place.",
            "example": 760469
          },
          "SigningPubKey": {
            "type": "string",
            "example": "02356E89059A75438887F9FEE2056A2890DB82A68353BE9C0C0C8F89C0018B37FC"
          },
          "TxnSignature": {
            "type": "string",
            "example": "304402206BB719587C55513515C092122813BC71C0BA28E7061830ABE6395308A1CAA0B302205B8256181965BB1345902597B2D3F1670F5F23A2E62097B3CCAA1F2EE631655E"
          },
          "meta": {
            "properties": {
              "AffectedNodes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "ModifiedNode": {
                      "properties": {
                        "FinalFields": {
                          "properties": {
                            "Account": { "type": "string", "example": "rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe" },
                            "Balance": { "type": "string", "example": "99871289963167439" },
                            "Flags": { "type": "number", "example": 0 },
                            "OwnerCount": { "type": "number", "example": 0 },
                            "Sequence": { "type": "number", "example": 118698 }
                          },
                          "type": "object"
                        },
                        "LedgerEntryType": { "type": "string", "example": "AccountRoot" },
                        "LedgerIndex": {
                          "type": "string",
                          "example": "31CCE9D28412FF973E9AB6D0FA219BACF19687D9A2456A0C2ABC3280E9D47E37"
                        },
                        "PreviousFields": {
                          "required": ["Balance", "Sequence"],
                          "properties": {
                            "Balance": { "type": "string", "example": "99871290963167451" },
                            "Sequence": { "type": "number", "example": 118697 }
                          },
                          "type": "object"
                        },
                        "PreviousTxnID": {
                          "type": "string",
                          "example": "C72E7E2C5D6C123F739689DD6C286910667CC4C2C65F8E6CBBE264E32B08E1B4"
                        },
                        "PreviousTxnLgrSeq": { "type": "number", "example": 760443 }
                      },
                      "type": "object"
                    }
                  }
                }
              },
              "TransactionIndex": { "type": "number", "example": 2 },
              "TransactionResult": { "type": "string", "example": "tesSUCCESS" },
              "delivered_amount": { "type": "string", "example": "1000000000" }
            },
            "type": "object"
          },
          "validated": {
            "type": "boolean",
            "description": "Whether or not the transaction is included in a validated ledger. Any transaction not yet in a validated ledger is subject to change.",
            "example": true
          }
        }
      },
      "XrpLedger": {
        "type": "object",
        "properties": {
          "ledger": {
            "type": "object",
            "description": "The complete header data of this ledger.",
            "properties": {
              "accepted": { "type": "boolean", "example": true },
              "account_hash": {
                "type": "string",
                "description": "Hash of all account state information in this ledger, as hex.",
                "example": "9E081790E520046EBA4B2ED3869C762C16EEAC6817293D40AFFD1F1B602A2321"
              },
              "close_flags": {
                "type": "integer",
                "description": "A bit-map of flags relating to the closing of this ledger. Currently, the ledger has only one flag defined for close_flags: sLCF_NoConsensusTime (value 1). If this flag is enabled, it means that validators were in conflict regarding the correct close time for the ledger, but build otherwise the same ledger, so they declared consensus while \"agreeing to disagree\" on the close time. In this case, the consensus ledger contains a close_time that is 1 second after that of the previous ledger. (In this case, there is no official close time, but the actual real-world close time is probably 3-6 seconds later than the specified close_time.)",
                "example": 0
              },
              "close_time": {
                "type": "integer",
                "description": "The time this ledger was closed, in seconds since the Ripple Epoch",
                "example": 640976331
              },
              "close_time_human": {
                "description": "The time this ledger was closed, in human-readable format. Always uses the UTC time zone.",
                "type": "string",
                "example": "2020-Apr-23 16:58:51.000000000 UTC"
              },
              "close_time_resolution": {
                "description": "Ledger close times are rounded to within this many seconds.",
                "type": "integer",
                "example": 10
              },
              "closed": {
                "description": "Whether or not this ledger has been closed.",
                "type": "boolean",
                "example": true
              },
              "hash": {
                "type": "string",
                "example": "198E3A43EFD03F61CF11EAD6585E8C82A21C1B91CCF782A3264973867E697906"
              },
              "ledger_hash": {
                "description": "Unique identifying hash of the entire ledger.",
                "type": "string",
                "example": "198E3A43EFD03F61CF11EAD6585E8C82A21C1B91CCF782A3264973867E697906"
              },
              "ledger_index": {
                "description": "The Ledger Index of this ledger, as a quoted integer.",
                "type": "string",
                "example": "6543210"
              },
              "parent_close_time": {
                "description": "The time at which the previous ledger was closed.",
                "type": "integer",
                "example": 640976330
              },
              "parent_hash": {
                "description": "Unique identifying hash of the ledger that came immediately before this one.",
                "type": "string",
                "example": "02860E47A797340505B51DE00E21AA576B1E50509C0C7FF8D5475954DA5FE7B5"
              },
              "seqNum": { "type": "string", "example": "6543210" },
              "totalCoins": { "type": "string", "example": "99999971496551645" },
              "total_coins": {
                "type": "string",
                "description": "Total number of XRP drops in the network, as a quoted integer. (This decreases as transaction costs destroy XRP.)",
                "example": "99999971496551645"
              },
              "transaction_hash": {
                "type": "string",
                "description": "Hash of the transaction information included in this ledger, as hex.",
                "example": "F415CCAB1ED22B2E81C8BE588A0521634F1CBC478BE3A5563B1E09D283A082C9"
              },
              "transactions": { "type": "array", "items": { "$ref": "#/components/schemas/XrpTx" } }
            }
          },
          "ledger_hash": {
            "type": "string",
            "description": "Unique identifying hash of the entire ledger.",
            "example": "198E3A43EFD03F61CF11EAD6585E8C82A21C1B91CCF782A3264973867E697906"
          },
          "ledger_index": {
            "type": "integer",
            "description": "The Ledger Index of this ledger.",
            "example": 6543210
          },
          "validated": {
            "type": "boolean",
            "description": "True if this data is from a validated ledger version; if omitted or set to false, this data is not final.",
            "example": true
          }
        }
      },
      "XrpAccountTx": {
        "type": "object",
        "properties": {
          "account": {
            "type": "string",
            "description": "Unique Address identifying the related account.",
            "example": "rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe"
          },
          "ledger_index_max": {
            "type": "number",
            "description": "The ledger index of the earliest ledger actually searched for transactions.",
            "example": 760762
          },
          "ledger_index_min": {
            "type": "number",
            "description": "The ledger index of the most recent ledger actually searched for transactions.",
            "example": 614
          },
          "marker": {
            "description": "Server-defined value indicating the response is paginated. Pass this to the next call to resume where this call left off.",
            "properties": {
              "ledger": { "type": "number", "example": 759571 },
              "seq": { "type": "number", "example": 2 }
            },
            "type": "object"
          },
          "transactions": {
            "type": "array",
            "description": "Array of transactions matching the request's criteria, as explained below.",
            "items": {
              "type": "object",
              "properties": {
                "meta": {
                  "description": "Transaction metadata included in JSON format.",
                  "properties": {
                    "AffectedNodes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "CreatedNode": {
                            "properties": {
                              "LedgerEntryType": { "type": "string", "example": "AccountRoot" },
                              "LedgerIndex": {
                                "type": "string",
                                "example": "0C9EDA0CDF11B0ACBF4B356C329607E5DDC25B7FCCC51A12579B58220AF6AF54"
                              },
                              "NewFields": {
                                "properties": {
                                  "Account": {
                                    "type": "string",
                                    "example": "rGenhJmoWHqD6tgmUyxQHLQH8sPuRGtUcv"
                                  },
                                  "Balance": { "type": "string", "example": "1000000000" },
                                  "Sequence": { "type": "number", "example": 1 }
                                },
                                "type": "object"
                              }
                            },
                            "type": "object"
                          }
                        }
                      }
                    },
                    "TransactionIndex": { "type": "number", "example": 2 },
                    "TransactionResult": { "type": "string", "example": "tesSUCCESS" },
                    "delivered_amount": { "type": "string", "example": "1000000000" }
                  },
                  "type": "object"
                },
                "tx": { "$ref": "#/components/schemas/XrpTx" },
                "validated": {
                  "type": "boolean",
                  "description": "True if this data is from a validated ledger version; if omitted or set to false, this data is not final.",
                  "example": true
                }
              }
            }
          }
        }
      },
      "XrpAccount": {
        "type": "object",
        "properties": {
          "account_data": {
            "properties": {
              "Account": {
                "type": "string",
                "description": "The identifying address of this account, such as rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn.",
                "example": "rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn"
              },
              "Balance": {
                "type": "string",
                "description": "The account's current XRP balance in drops, represented as a string.",
                "example": "1000000000"
              },
              "Flags": {
                "type": "number",
                "description": "A bit-map of boolean flags enabled for this account.",
                "example": 0
              },
              "LedgerEntryType": {
                "type": "string",
                "description": "The value 0x0061, mapped to the string AccountRoot, indicates that this is an AccountRoot object.",
                "example": "AccountRoot"
              },
              "OwnerCount": {
                "type": "number",
                "description": "The number of objects this account owns in the ledger, which contributes to its owner reserve.",
                "example": 0
              },
              "PreviousTxnID": {
                "type": "string",
                "description": "The identifying hash of the transaction that most recently modified this object.",
                "example": "1A32A054B04AC9D6814710DDCA416E72C4CD2D78D6C3DFC06CC9369CC4F6B250"
              },
              "PreviousTxnLgrSeq": {
                "type": "number",
                "description": "The index of the ledger that contains the transaction that most recently modified this object.",
                "example": 760469
              },
              "Sequence": {
                "type": "number",
                "description": "The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.)",
                "example": 1
              },
              "index": {
                "type": "string",
                "example": "BB899D5C7C5E13AFFD702514FC78BE59313AC72AF02A3FC94E5F54F05EB2E20D"
              }
            },
            "type": "object",
            "description": "The AccountRoot ledger object with this account's information, as stored in the ledger."
          },
          "ledger_current_index": {
            "type": "number",
            "description": "The Ledger Index of the current open ledger these stats describe.",
            "example": 760476
          },
          "validated": {
            "type": "boolean",
            "description": "True if this data is from a validated ledger version; if omitted or set to false, this data is not final.",
            "example": false
          }
        }
      },
      "XrpAccountBalance": {
        "type": "object",
        "properties": {
          "assets": {
            "type": "array",
            "description": "Different assets other then XRP available on the account.",
            "items": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "string",
                  "description": "Balance of the asset.",
                  "example": "1000000000"
                },
                "currency": {
                  "type": "string",
                  "description": "Asset identifier.",
                  "example": "015841551A748AD2C1F76FF6ECB0CCCD00000000"
                }
              }
            }
          },
          "balance": { "type": "string", "description": "Balance of XRP, in drops.", "example": "1000000000" }
        }
      },
      "XrpFee": {
        "type": "object",
        "properties": {
          "current_ledger_size": {
            "type": "string",
            "description": "Number of transactions provisionally included in the in-progress ledger.",
            "example": "8"
          },
          "current_queue_size": {
            "type": "string",
            "description": "Number of transactions currently queued for the next ledger.",
            "example": "0"
          },
          "drops": {
            "description": "Various information about the transaction cost (the Fee field of a transaction), in drops of XRP.",
            "properties": {
              "base_fee": {
                "type": "string",
                "description": "The transaction cost required for a reference transaction to be included in a ledger under minimum load, represented in drops of XRP.",
                "example": "10"
              },
              "median_fee": {
                "type": "string",
                "description": "An approximation of the median transaction cost among transactions included in the previous validated ledger, represented in drops of XRP.",
                "example": "5000"
              },
              "minimum_fee": {
                "type": "string",
                "description": "The minimum transaction cost for a reference transaction to be queued for a later ledger, represented in drops of XRP. If greater than base_fee, the transaction queue is full.",
                "example": "10"
              },
              "open_ledger_fee": {
                "type": "string",
                "description": "The minimum transaction cost that a reference transaction must pay to be included in the current open ledger, represented in drops of XRP.",
                "example": "10"
              }
            },
            "type": "object"
          },
          "expected_ledger_size": {
            "type": "string",
            "description": "The approximate number of transactions expected to be included in the current ledger. This is based on the number of transactions in the previous ledger.",
            "example": "67"
          },
          "ledger_current_index": {
            "type": "number",
            "description": "The Ledger Index of the current open ledger these stats describe.",
            "example": 760411
          },
          "levels": {
            "description": "Various information about the transaction cost, in fee levels. The ratio in fee levels applies to any transaction relative to the minimum cost of that particular transaction.",
            "properties": {
              "median_level": {
                "type": "string",
                "description": "The median transaction cost among transactions in the previous validated ledger, represented in fee levels.",
                "example": "128000"
              },
              "minimum_level": {
                "type": "string",
                "description": "The minimum transaction cost required to be queued for a future ledger, represented in fee levels.",
                "example": "256"
              },
              "open_ledger_level": {
                "type": "string",
                "description": "The minimum transaction cost required to be included in the current open ledger, represented in fee levels.",
                "example": "256"
              },
              "reference_level": {
                "type": "string",
                "description": "The equivalent of the minimum transaction cost, represented in fee levels.",
                "example": "256"
              }
            },
            "type": "object"
          },
          "max_queue_size": {
            "type": "string",
            "description": "The maximum number of transactions that the transaction queue can currently hold.",
            "example": "2000"
          }
        }
      },
      "XrpInfo": {
        "type": "object",
        "properties": {
          "ledger_hash": {
            "type": "string",
            "description": "Current ledger hash.",
            "example": "20C40AAF14D52FB614E41625218AF6C97B43076C30060E85AEFB38D54A99050F"
          },
          "ledger_index": { "type": "number", "description": "Current ledger index.", "example": 760383 }
        }
      },
      "ListOderBookActiveSellBody": {
        "type": "object",
        "required": ["pageSize"],
        "properties": {
          "id": {
            "type": "string",
            "description": "Account ID. If present, list current active sell trades for that account.",
            "example": "5e68c66581f2ee32bc354087"
          },
          "customerId": {
            "description": "Customer ID. If present, list current active buy trades for that customer.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "pageSize": {
            "description": "Max number of items per page is 50.",
            "type": "number",
            "example": 10,
            "maximum": 50,
            "minimum": 1
          },
          "offset": {
            "description": "Offset to obtain next page of the data.",
            "type": "number",
            "example": 0
          },
          "pair": {
            "description": "Trade pair. If present, list current active sell trades for that pair.",
            "type": "string",
            "example": "BTC/EUR",
            "minLength": 3,
            "maxLength": 30,
            "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
          },
          "count": {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "example": true,
            "type": "boolean"
          },
          "tradeType": {
            "description": "Trade type.",
            "example": "SELL",
            "type": "string",
            "enum": ["FUTURE_SELL", "SELL"]
          },
          "amount": {
            "type": "array",
            "description": "Amount of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "fill": {
            "type": "array",
            "description": "Fill of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "price": {
            "type": "array",
            "description": "Price of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "created": {
            "type": "array",
            "description": "Created date of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "sort": { "$ref": "#/components/schemas/OrderBookSort" }
        }
      },
      "ListOderBookActiveBuyBody": {
        "type": "object",
        "required": ["pageSize"],
        "properties": {
          "id": {
            "type": "string",
            "description": "Account ID. If present, list current active sell trades for that account.",
            "example": "5e68c66581f2ee32bc354087"
          },
          "customerId": {
            "description": "Customer ID. If present, list current active buy trades for that customer.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "pageSize": {
            "description": "Max number of items per page is 50.",
            "type": "number",
            "example": 10,
            "maximum": 50,
            "minimum": 1
          },
          "offset": {
            "description": "Offset to obtain next page of the data.",
            "type": "number",
            "example": 0
          },
          "pair": {
            "description": "Trade pair. If present, list current active sell trades for that pair.",
            "type": "string",
            "example": "BTC/EUR",
            "minLength": 3,
            "maxLength": 30,
            "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
          },
          "count": {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "example": true,
            "type": "boolean"
          },
          "tradeType": {
            "description": "Trade type.",
            "example": "BUY",
            "type": "string",
            "enum": ["FUTURE_BUY", "BUY"]
          },
          "amount": {
            "type": "array",
            "description": "Amount of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "fill": {
            "type": "array",
            "description": "Fill of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "price": {
            "type": "array",
            "description": "Price of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "created": {
            "type": "array",
            "description": "Created date of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "sort": { "$ref": "#/components/schemas/OrderBookSort" }
        }
      },
      "ListOderBookMatchedBody": {
        "type": "object",
        "required": ["pageSize"],
        "properties": {
          "id": {
            "type": "string",
            "description": "Account ID. If present, list matched FUTURE_BUY/FUTURE_SELL orders trades for that account.",
            "example": "5e68c66581f2ee32bc354087"
          },
          "customerId": {
            "description": "Customer ID. If present, list matched FUTURE_BUY/FUTURE_SELL orders trades for that customer.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "pageSize": {
            "description": "Max number of items per page is 50.",
            "type": "number",
            "example": 10,
            "maximum": 50,
            "minimum": 1
          },
          "offset": {
            "description": "Offset to obtain next page of the data.",
            "type": "number",
            "example": 0
          },
          "pair": {
            "description": "Trade pair. If present, list matched FUTURE_BUY/FUTURE_SELL orders trades for that pair.",
            "type": "string",
            "example": "BTC/EUR",
            "minLength": 3,
            "maxLength": 30,
            "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
          },
          "count": {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "example": true,
            "type": "boolean"
          },
          "type": {
            "description": "Trade type.",
            "example": "FUTURE_SELL",
            "type": "string",
            "enum": ["FUTURE_SELL", "FUTURE_BUY"]
          },
          "amount": {
            "type": "array",
            "description": "Amount of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "fill": {
            "type": "array",
            "description": "Fill of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "price": {
            "type": "array",
            "description": "Price of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "created": {
            "type": "array",
            "description": "Created date of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "sort": { "$ref": "#/components/schemas/OrderBookSort" }
        }
      },
      "ListOderBookHistoryBody": {
        "type": "object",
        "required": ["pageSize"],
        "properties": {
          "id": {
            "description": "Account ID. If present, only closed trades for given account will be present.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "customerId": {
            "description": "Customer ID. If present, only closed trades for given customer will be present.",
            "type": "string",
            "example": "5e68c66581f2ee32bc354087"
          },
          "pageSize": {
            "description": "Max number of items per page is 50.",
            "type": "number",
            "example": 10,
            "maximum": 50,
            "minimum": 1
          },
          "offset": {
            "description": "Offset to obtain next page of the data.",
            "type": "number",
            "example": 0
          },
          "pair": {
            "description": "Trade pair. If present, list historical trades for that pair.",
            "type": "string",
            "example": "BTC/EUR",
            "minLength": 3,
            "maxLength": 30,
            "pattern": "^[A-a-zZ0-9_\\-]+\\/[A-Za-z0-9_\\-]+$"
          },
          "count": {
            "description": "Get the total trade pair count based on the filter. Either count or pageSize is accepted.",
            "example": true,
            "type": "boolean"
          },
          "types": {
            "description": "Trade types.",
            "type": "array",
            "items": {
              "type": "string",
              "example": "BUY",
              "enum": ["FUTURE_BUY", "FUTURE_SELL", "BUY", "SELL"]
            }
          },
          "amount": {
            "type": "array",
            "description": "Amount of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "fill": {
            "type": "array",
            "description": "Fill of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "price": {
            "type": "array",
            "description": "Price of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "created": {
            "type": "array",
            "description": "Created date of the trade. AND is used between filter options.",
            "items": {
              "type": "object",
              "properties": {
                "op": {
                  "type": "string",
                  "description": "Filtering operation.",
                  "example": "gte",
                  "enum": ["gte", "lte", "gt", "lt", "eq", "neq"]
                },
                "value": { "type": "string", "description": "Value of the operation.", "example": "1.5" }
              },
              "required": ["op", "value"]
            }
          },
          "sort": { "$ref": "#/components/schemas/OrderBookSort" }
        }
      },
      "OrderBookSort": {
        "description": "Sorts the result by selected property. The priority of the items is determined by order of the sort properties in array.",
        "items": {
          "type": "string",
          "enum": [
            "PRICE_ASC",
            "PRICE_DESC",
            "CREATED_ASC",
            "CREATED_DESC",
            "AMOUNT_ASC",
            "AMOUNT_DESC",
            "FILL_ASC",
            "FILL_DESC",
            "FEE_ASC",
            "FEE_DESC"
          ],
          "example": "PRICE_ASC"
        }
      },
      "GasPumpAddress": {
        "type": "string",
        "description": "A gas pump address",
        "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
      },
      "Activated": {
        "type": "object",
        "properties": {
          "activated": {
            "type": "boolean",
            "description": "If set to \"true\", the gas pump address has been activated",
            "example": true
          }
        },
        "example": { "activated": true }
      },
      "ActivateGasPump": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that will pay the gas fee for the activation transaction"
          }
        },
        "required": ["chain", "owner", "from", "to", "fromPrivateKey"]
      },
      "ActivateGasPumpTatum": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["BSC", "CELO", "ETH", "MATIC", "KLAY", "ONE"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "feesCovered": {
            "type": "boolean",
            "example": true,
            "description": "Set to \"true\" to cover the gas fee by credits from your monthly credit allowance."
          }
        },
        "required": ["chain", "owner", "from", "to", "feesCovered"]
      },
      "ActivateGasPumpKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["BSC", "ETH", "KLAY", "MATIC", "ONE"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the gas fee for the activation transaction"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          }
        },
        "required": ["chain", "owner", "from", "to", "signatureId"]
      },
      "ActivateGasPumpCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": ["CELO"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee; if not set, defaults to CELO",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that will pay the gas fee for the activation transaction"
          }
        },
        "required": ["chain", "owner", "from", "to", "fromPrivateKey"]
      },
      "ActivateGasPumpCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": ["CELO"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency to pay for the gas fee; if not set, defaults to CELO",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the gas fee for the activation transaction"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          }
        },
        "required": ["chain", "owner", "from", "to", "signatureId"]
      },
      "ActivateGasPumpTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": ["TRON"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the gas fee (in TRX)",
            "example": 600
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "e26c1595086cd52f2bc61774c7228b841db66b4b9b0ed36dc29dbc90595dd5b6",
            "minLength": 64,
            "description": "The private key of the blockchain address that will pay the gas fee for the activation transaction"
          }
        },
        "required": ["chain", "owner", "from", "to", "feeLimit", "fromPrivateKey"]
      },
      "ActivateGasPumpTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": ["TRON"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that owns the precalculated gas pump addresses and is used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to activate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to activate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 200
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the gas fee (in TRX)",
            "example": 600
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the gas fee for the activation transaction"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          }
        },
        "required": ["chain", "owner", "from", "to", "feeLimit", "signatureId"]
      },
      "CreateGasPump": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["BSC", "CELO", "ETH", "MATIC", "KLAY", "ONE", "TRON"]
          },
          "owner": {
            "type": "string",
            "description": "The blockchain address that will own the precalculated gas pump addresses and will be used to pay gas fees for operations made on the gas pump addresses; can be referred to as \"master address\"",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "from": {
            "type": "integer",
            "description": "The start index of the range of gas pump addresses to precalculate",
            "minimum": 0,
            "example": 0
          },
          "to": {
            "type": "integer",
            "description": "The end index of the range of gas pump addresses to precalculate; must be greater than or equal to the value in the <code>from</code> parameter",
            "minimum": 0,
            "example": 1000
          }
        },
        "required": ["chain", "owner", "from", "to"]
      },
      "GasPumpTrxOut": {
        "type": "object",
        "properties": {
          "valid": {
            "type": "array",
            "description": "Activated gas pump addresses",
            "items": { "$ref": "#/components/schemas/ValidGasPumpAddress" }
          },
          "invalid": {
            "type": "array",
            "description": "Not activated gas pump addresses",
            "items": { "$ref": "#/components/schemas/InvalidGasPumpAddress" }
          }
        }
      },
      "ValidGasPumpAddress": {
        "type": "object",
        "properties": {
          "index": {
            "type": "number",
            "description": "The index of the activated gas pump address",
            "example": 1
          },
          "address": {
            "type": "string",
            "description": "The activated gas pump address",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea"
          }
        }
      },
      "InvalidGasPumpAddress": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "The not activated gas pump address",
            "example": "0x2b5a0bE5940B63dE1eDdCCCa7bd977357e2488eD"
          },
          "reason": {
            "type": "string",
            "description": "The reason why the gas pump address did not get activated",
            "example": "Wallet already exists"
          }
        }
      },
      "TransferManagedAddress": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to work on",
            "example": "SOL",
            "enum": ["SOL"]
          },
          "txData": {
            "type": "string",
            "minLength": 1,
            "maxLength": 500000,
            "description": "Hex serialized data representing transaction, which should be signed using one of the managed wallets.",
            "example": "020001044a22af97a838a504e6f7c0b18d779afcea612da50794cc1dac641861fc1ab14afa5cacaf91c298694e64bb5496916c3c68a32affb92d4bcd2736fbb00169d57bd840de2a454960308f688cd3ee308c1fa01ecfa0b03770aaaf3b52d71d46c31d000000000000000000000000000000000000000000000000000000000000000060d38e0da20dc5900b7e902c918eae6a95e2d90af154b53a422f4ab26b050f4f01030201020c02000000e803000000000000"
          },
          "walletIds": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["key", "type"],
              "properties": {
                "key": {
                  "type": "string",
                  "description": "Wallet ID of wallet, which should be used for signing. In case of RAW type of the wallet, this represents the private key which will be used for signatures.",
                  "example": "0b1eae3d-2520-4903-8bbf-5dec3ad2a5d4"
                },
                "type": {
                  "type": "string",
                  "example": "MANAGED",
                  "description": "Type of the wallet to be used - RAW represents native private key, MANAGED represents ID of the managed wallet.",
                  "enum": ["MANAGED", "RAW"]
                }
              }
            }
          }
        },
        "required": ["chain", "txData", "walletIds"]
      },
      "CustodialManagedAddress": {
        "type": "object",
        "required": ["address", "walletId", "chain"],
        "properties": {
          "address": {
            "type": "string",
            "description": "Blockchain address",
            "example": "8oJ8KRL87ja7DjPSsmBG1KtfrpsfLGDMJDGzev68DGqx"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "example": "52901013-94ab-4124-8645-acba4ee90bb8",
            "description": "Unique identifier of the managed address"
          },
          "chain": {
            "type": "string",
            "description": "Blockchain of the address",
            "example": "SOL",
            "enum": ["BSC", "ETH", "KLAY", "ONE", "CELO", "MATIC", "SOL", "LTC", "BTC"]
          },
          "privateKey": {
            "type": "string",
            "example": "4jCFiqh3tLxKxt3vYW478qodivkCkSzqtpG4wqEaYkgdVC1o79a1VJTc5UiCmCmZBwoJmjaenfYH1ML7ra8vbNpA",
            "description": "Private key of the address. Not present by default."
          }
        }
      },
      "TransferNftCelo": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "tokenId", "fromPrivateKey"]
      },
      "TransferNftTron": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to send NFT token to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "to", "contractAddress", "tokenId", "fromPrivateKey", "feeLimit"]
      },
      "FlowMintedMultipleResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "Transaction ID",
            "example": "d67787399d205139f4d6f42c2aa4fffdf6f247411fae3706e874fbba0ce04b1b"
          },
          "tokenId": {
            "type": "array",
            "items": { "type": "number", "description": "ID of the minted token", "example": 12345 }
          }
        }
      },
      "FlowMintedResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "Transaction ID",
            "example": "d67787399d205139f4d6f42c2aa4fffdf6f247411fae3706e874fbba0ce04b1b"
          },
          "tokenId": { "type": "number", "description": "ID of the minted token", "example": 12345 }
        }
      },
      "SolanaMintedResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "The ID of the transaction",
            "example": "4kiRkAWjjr5t3rBKmYQ5d2e3xjgnRRttB5GtUz2F4sz5wwC7NnV74qCZ1KN1b37qsnjkKknsJPGXdcPhzHpkiMAs"
          },
          "nftAddress": {
            "type": "string",
            "description": "The blockchain address of the minted NFT",
            "example": "4afZBmAneN2j6gDHH8zdrNWkCqfMC3XPH2cpFKtYMSVe"
          },
          "nftAccountAddress": {
            "type": "string",
            "description": "The blockchain address that received the minted NFT; this address was created under the recipient's account address (the one in the <code>to</code> parameter of the request body), is owned by the recipient's address, and has the same private key",
            "example": "A8BSHPJcB5ZGCT6yo6pz2RYqnypTSpzTAFSBhtTQmsEE"
          }
        }
      },
      "AlgorandMintedResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "The ID of the transaction",
            "example": "HQ32RQPJ7EAASLHPG5TTQEGETOEMN7BPND2TQMUMZWLIZBJWJ23A"
          },
          "assetIndex": { "type": "number", "description": "The ID of the minted NFT", "example": 88885810 },
          "confirmed": {
            "type": "boolean",
            "description": "If set to <code>true</code>, the transaction was included in the block within five rounds; otherwise, returned set to <code>false</code>. <code>false</code> does not mean that the transaction was not included in the block; the Tatum API just does not wait for that much time to return the response.",
            "example": true
          }
        }
      },
      "MintMultipleNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "type": "array",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency CELO.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "url", "fromPrivateKey", "feeCurrency", "tokenId"]
      },
      "MintMultipleNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"],
            "items": { "maxLength": 34, "minLength": 34, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "type": "array",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "to", "contractAddress", "url", "fromPrivateKey", "feeLimit", "tokenId"]
      },
      "DeployNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "name", "symbol", "feeCurrency", "fromPrivateKey"]
      },
      "DeployNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX. For deploy, around 580 TRX is consumed.",
            "example": 600
          }
        },
        "required": ["chain", "name", "symbol", "feeLimit", "fromPrivateKey"]
      },
      "DeployNftCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": { "type": "number", "minimum": 0 },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "name", "symbol", "feeCurrency", "signatureId"]
      },
      "DeployNftTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX. For deploy, around 580 TRX is consumed.",
            "example": 600
          }
        },
        "required": ["chain", "name", "account", "symbol", "feeLimit", "signatureId"]
      },
      "MintMultipleNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "type": "array",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency CELO.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "feeCurrency", "tokenId", "url", "signatureId"]
      },
      "MintMultipleNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"],
            "items": { "maxLength": 34, "minLength": 34, "type": "string" }
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "type": "array",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "to", "account", "contractAddress", "feeLimit", "tokenId", "url", "signatureId"]
      },
      "BurnNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "contractAddress", "feeCurrency", "fromPrivateKey", "tokenId"]
      },
      "BurnNftAlgo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": ["ALGO"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The ID of the NFT to burn; this is the ID from the <code>assetIndex</code> parameter returned in the response body of the <a href=\"#operation/NftMintErc721\">minting call</a>",
            "example": "116363571",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "46OPDKNDLB35M3QMRRZEAW2HDTDT2LFHRUCHDE5FJZAJOV7GDPCC6AYZ6KCUULTHA4QL6YPHN2PNEXHPJMUZGHYJXQK6SUL2HQ2MLXQ",
            "minLength": 103,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          }
        },
        "required": ["chain", "contractAddress", "fromPrivateKey"]
      },
      "BurnNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "contractAddress", "feeLimit", "fromPrivateKey", "tokenId"]
      },
      "BurnNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "feeCurrency", "contractAddress", "tokenId", "signatureId"]
      },
      "BurnNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "feeLimit", "contractAddress", "tokenId", "signatureId", "account"]
      },
      "BurnNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": ["chain", "contractAddress", "account", "privateKey", "tokenId"]
      },
      "BurnNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "mnemonic", "index", "tokenId"]
      },
      "BurnNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "signatureId", "tokenId"]
      },
      "MintMultipleNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0xc1b45bc27b9c61c3"],
            "items": { "maxLength": 18, "minLength": 18, "type": "string" }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": ["chain", "contractAddress", "account", "privateKey", "to", "url"]
      },
      "MintMultipleNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0xc1b45bc27b9c61c3"],
            "items": { "maxLength": 18, "minLength": 18, "type": "string" }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "mnemonic", "index", "to", "url"]
      },
      "MintMultipleNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0xc1b45bc27b9c61c3"],
            "items": { "maxLength": 18, "minLength": 18, "type": "string" }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "signatureId", "to", "url"]
      },
      "MintNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "url": {
            "type": "string",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": ["chain", "contractAddress", "account", "privateKey", "to", "url"]
      },
      "MintNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "url": {
            "type": "string",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "mnemonic", "index", "to", "url"]
      },
      "MintNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "url": {
            "type": "string",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "signatureId", "to", "url"]
      },
      "DeployNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": ["chain", "account", "privateKey"]
      },
      "DeployNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "account", "mnemonic", "index"]
      },
      "DeployNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "account", "signatureId"]
      },
      "TransferNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "tokenId": {
            "description": "ID of token to be sent.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": ["chain", "contractAddress", "account", "privateKey", "to", "tokenId"]
      },
      "TransferNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "tokenId": {
            "description": "ID of token to be sent.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "mnemonic", "index", "to", "tokenId"]
      },
      "TransferNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "Chain to work with.",
            "enum": ["FLOW"]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "tokenId": {
            "description": "ID of token to be sent.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": ["chain", "contractAddress", "account", "signatureId", "to", "tokenId"]
      },
      "NftTx": {
        "type": "object",
        "properties": {
          "blockNumber": { "type": "number", "example": 6541235, "description": "Block number" },
          "txId": {
            "type": "string",
            "example": "0x955c1037608c7aecb6d1a3f150ce7d0a80536bcabb0deb69d62f55292cc4c372",
            "description": "Transaction ID"
          },
          "contractAddress": {
            "type": "string",
            "example": "0x4f54fAD27F7F46C102Cd49b8E75C5593397cd9c3",
            "description": "Contract address"
          },
          "tokenId": { "type": "string", "example": "1", "description": "ID of the token" },
          "from": {
            "type": "string",
            "example": "0x780c3de0aba1b51f04cfe8a5d9d277d4ad032b8d",
            "description": "Sender"
          },
          "to": {
            "type": "string",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea",
            "description": "recipient"
          }
        },
        "required": ["blockNumber", "txId", "contractAddress", "tokenId", "from", "to"]
      },
      "UpdateCashbackValueForAuthorNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be updated.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "cashbackValue": {
            "type": "string",
            "description": "New royalty cashback to be set for the author of token with tokenId. If set to 0, royalty is disabled for this token.",
            "example": "0.1"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "contractAddress", "feeCurrency", "fromPrivateKey", "tokenId", "cashbackValue"]
      },
      "UpdateCashbackValueForAuthorNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "tokenId": {
            "description": "ID of token to be updated.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "cashbackValue": {
            "type": "string",
            "description": "New royalty cashback to be set for the author of token with tokenId. If set to 0, royalty is disabled for this token.",
            "example": "0.1"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "contractAddress", "feeLimit", "fromPrivateKey", "tokenId", "cashbackValue"]
      },
      "UpdateCashbackValueForAuthorNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be updated.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "cashbackValue": {
            "type": "string",
            "description": "New royalty cashback to be set for the author of token with tokenId. If set to 0, royalty is disabled for this token.",
            "example": "0.1"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "feeCurrency", "contractAddress", "tokenId", "signatureId", "cashbackValue"]
      },
      "UpdateCashbackValueForAuthorNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be updated.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "cashbackValue": {
            "type": "string",
            "description": "New royalty cashback to be set for the author of token with tokenId. If set to 0, royalty is disabled for this token.",
            "example": "0.1"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": [
          "chain",
          "feeLimit",
          "contractAddress",
          "account",
          "tokenId",
          "signatureId",
          "cashbackValue"
        ]
      },
      "TransferNftKMSCelo": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "feeCurrency", "signatureId", "tokenId"]
      },
      "TransferNftKMSTron": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to send NFT token to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "to", "contractAddress", "feeLimit", "signatureId", "tokenId", "account"]
      },
      "MintNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of custom ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency CELO.",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "description": "Blockchain address to send royalties to",
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency and percentage value in case of provenance",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fixedValues": {
            "type": "array",
            "description": "List of fixed values, if fixed value is greater than cashback value, it will be transferred to the authors instead.This is exact value in native blockhain currency.",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "url", "feeCurrency"]
      },
      "MintNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to send NFT token to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency TRON.",
            "items": {
              "type": "string",
              "minLength": 34,
              "maxLength": 34,
              "description": "Blockchain address to send royalties to",
              "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency.",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "to", "url", "feeLimit", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "MintNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of custom ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency CELO.",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "description": "Blockchain address to send royalties to",
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency and percentage value in case of provenance",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fixedValues": {
            "type": "array",
            "description": "List of fixed values, if fixed value is greater than cashback value, it will be transferred to the authors instead.This is exact value in native blockhain currency.",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "url", "feeCurrency", "contractAddress", "signatureId", "tokenId"]
      },
      "MintNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "Chain to work with.",
            "enum": ["TRON"]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to send NFT token to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency TRON.",
            "items": {
              "type": "string",
              "minLength": 34,
              "maxLength": 34,
              "description": "Blockchain address to send royalties to",
              "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency.",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "Max limit for fee to be paid, in TRX.",
            "example": 600
          }
        },
        "required": ["chain", "account", "to", "url", "feeLimit", "contractAddress", "signatureId", "tokenId"]
      },
      "TransferNft": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "to": {
            "maxLength": 58,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 1,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used. Setting nonce is not necessary in Algorand"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically. Setting fee is not necessary in Algorand.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "tokenId", "fromPrivateKey"]
      },
      "TransferNftAlgo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "to": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "description": "AssetID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "72TCV5BRQPBMSAFPYO3CPWVDBYWNGAYNMTW5QHENOMQF7I6QLNMJWCJZ7A3V5YKD7QD6ZZPEHG2PV2ZVVEDDO6BCRGXWIL3DIUMSUCI",
            "minLength": 106,
            "description": "Private key of sender address."
          }
        },
        "required": ["to", "chain", "contractAddress", "fromPrivateKey"]
      },
      "TransferNftAlgoExpress": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "to": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "description": "AssetID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          }
        },
        "required": ["to", "chain", "contractAddress"]
      },
      "TransferNftSolana": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockhain to work with",
            "enum": ["SOL"]
          },
          "from": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT from; this is the address that you used in the <code>to</code> parameter in the request body of the <a href=\"#operation/NftMintErc721\">minting call</a>; from this address, the transaction fee will be paid",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "to": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address of the NFT; this is the address from the <code>nftAddress</code> parameter returned in the response body of the <a href=\"#operation/NftMintErc721\">minting call</a>",
            "example": "3tzudv5KaoqmieWiBUqzWokKEtTvx1wQMapVKeH7CHaq",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 128,
            "description": "The private key of the blockchain address that you are sending the NFT from (the address that you specified in the <code>from</code> parameter)"
          }
        },
        "required": ["to", "from", "chain", "contractAddress", "fromPrivateKey"]
      },
      "TransferNftAlgoKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "from": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token from",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "to": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "description": "AssetID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "chain", "contractAddress", "from", "signatureId"]
      },
      "TransferNftSolanaKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockhain to work with",
            "enum": ["SOL"]
          },
          "from": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT from; this is the address that you used in the <code>to</code> parameter in the request body of the <a href=\"#operation/NftMintErc721\">minting call</a>; from this address, the transaction fee will be paid",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "to": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address of the NFT; this is the address from the <code>nftAddress</code> parameter returned in the response body of the <a href=\"#operation/NftMintErc721\">minting call</a>",
            "example": "3tzudv5KaoqmieWiBUqzWokKEtTvx1wQMapVKeH7CHaq",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that you are sending the NFT from (the address that you specified in the <code>from</code> parameter)"
          }
        },
        "required": ["to", "from", "chain", "contractAddress", "signatureId"]
      },
      "DeployNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "chain", "symbol", "fromPrivateKey"]
      },
      "DeployNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources avaiable here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "chain", "symbol", "signatureId"]
      },
      "TransferNftKMS": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "signatureId", "tokenId"]
      },
      "MintNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of custom ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency, like BSC or ETH.",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "description": "Blockchain address to send royalties to",
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency and percentage value in case of provenance",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fixedValues": {
            "type": "array",
            "description": "List of fixed values, if fixed value is greater than cashback value, it will be transferred to the authors instead.This is exact value in native blockhain currency.",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "fromPrivateKey", "tokenId"]
      },
      "MintNftMinter": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["BSC", "CELO", "ETH", "KLAY", "MATIC", "ONE"]
          },
          "tokenId": {
            "description": "The token ID of the NFT",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "The link to the NFT metadata (see https://eips.ethereum.org/EIPS/eip-721#specification for more details)",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          }
        },
        "required": ["to", "chain", "url", "minter", "tokenId", "contractAddress"]
      },
      "MintNftExpress": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "CELO", "ONE", "KLAY", "BSC"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          }
        },
        "required": ["to", "chain", "url"]
      },
      "MintNftExpressAlgorand": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": ["ALGO"]
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "name": {
            "description": "The name of the NFT",
            "example": "My Crazy NFT",
            "maxLength": 32,
            "minLength": 1,
            "type": "string"
          },
          "attr": {
            "type": "object",
            "properties": {
              "assetUnit": {
                "description": "The unit name of the NFT",
                "example": "USDT",
                "type": "string",
                "maxLength": 8,
                "minLength": 1
              },
              "clawback": {
                "description": "The address of the clawback account that can claw back holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "manager": {
                "description": "The address of the manager account that can manage the configuration of the NFT or burn it; specify this parameter if you want to be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFT</a> any time later",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "reserve": {
                "description": "The address of the reserve account that holds the reserve (non-minted) units of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "freeze": {
                "description": "The address of the freeze account that is used to freeze holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              }
            }
          }
        },
        "required": ["name", "chain", "url"]
      },
      "MintNftAlgorand": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": ["ALGO"]
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "name": {
            "description": "The name of the NFT",
            "example": "My Crazy NFT",
            "maxLength": 32,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "EPD5VYFGXWNZ2PY4AQNPD3E3LMAXISKNMGR4IJ44YI74QL5AMNTAIJNQ6Q373RDANF2YERVFQY3C5CKK7VUJDJR4DT6EPP5HZQUPORQ",
            "minLength": 103,
            "description": "The private key of the minting account; the transaction fee will be paid from this account"
          },
          "attr": {
            "type": "object",
            "properties": {
              "assetUnit": {
                "description": "The unit name of the NFT",
                "example": "USDT",
                "type": "string",
                "maxLength": 8,
                "minLength": 1
              },
              "clawback": {
                "description": "The address of the clawback account that can claw back holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "manager": {
                "description": "The address of the manager account that can manage the configuration of the NFT or burn it; specify this parameter if you want to be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFT</a> any time later",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "reserve": {
                "description": "The address of the reserve account that holds the reserve (non-minted) units of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "freeze": {
                "description": "The address of the freeze account that is used to freeze holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              }
            }
          }
        },
        "required": ["name", "chain", "url", "fromPrivateKey"]
      },
      "MintNftAlgorandKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": ["ALGO"]
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "name": {
            "description": "The name of the NFT",
            "example": "My Crazy NFT",
            "maxLength": 32,
            "minLength": 1,
            "type": "string"
          },
          "from": {
            "description": "The address of the minting account",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string",
            "maxLength": 58,
            "minLength": 58
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the minting account; the transaction fee will be paid from this account"
          },
          "attr": {
            "type": "object",
            "properties": {
              "assetUnit": {
                "description": "The unit name of the NFT",
                "example": "USDT",
                "type": "string",
                "maxLength": 8,
                "minLength": 1
              },
              "clawback": {
                "description": "The address of the clawback account that can claw back holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "manager": {
                "description": "The address of the manager account that can manage the configuration of the NFT or burn it; specify this parameter if you want to be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFT</a> any time later",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "reserve": {
                "description": "The address of the reserve account that holds the reserve (non-minted) units of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "freeze": {
                "description": "The address of the freeze account that is used to freeze holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              }
            }
          }
        },
        "required": ["name", "chain", "url", "from", "signatureId"]
      },
      "MintNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "erc20": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of custom ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency, like BSC or ETH.",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "description": "Blockchain address to send royalties to",
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency and percentage value in case of provenance",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "fixedValues": {
            "type": "array",
            "description": "List of fixed values, if fixed value is greater than cashback value, it will be transferred to the authors instead.This is exact value in native blockhain currency.",
            "items": { "type": "string", "description": "Value of the royalty to be paid.", "example": "0.5" }
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "signatureId", "tokenId"]
      },
      "MintNftSolana": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": ["SOL"]
          },
          "to": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to mint the NFT from. The transaction fee will be paid from this address.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 64,
            "description": "The private key of the sender's address"
          },
          "collectionVerifierPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 64,
            "description": "The private key of the collection verifier (owner) who will verify the NFT in the NFT collection where the NFT is minted in. The blockchain address of this collection is specified in the <code>collection</code> parameter in the <code>metadata</code> section of the request body. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>."
          },
          "metadata": { "$ref": "#/components/schemas/SolanaNftMetadata" }
        },
        "required": ["to", "chain", "fromPrivateKey", "from", "metadata"]
      },
      "VerifySolanaNFT": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": ["SOL"]
          },
          "nftAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT to verify",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "collectionAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT should be verified in. The collection must be a sized collection that was introduced in <a href=\"https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\" target=\"_blank\">Version 1.3</a> of the Metaplex Token Metadata program.",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the collection verifier on behalf of whom the transaction will be originated. The transaction fee will be paid from this address.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 64,
            "description": "The private key of the collection verifier's address"
          }
        },
        "required": ["collectionAddress", "chain", "fromPrivateKey", "from", "nftAddress"]
      },
      "VerifySolanaNFTKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": ["SOL"]
          },
          "nftAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT to verify",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "collectionAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT should be verified in. The collection must be a sized collection that was introduced in <a href=\"https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\" target=\"_blank\">Version 1.3</a> of the Metaplex Token Metadata program.",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the collection verifier on behalf of whom the transaction will be originated. The transaction fee will be paid from this address.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["collectionAddress", "chain", "signatureId", "from", "nftAddress"]
      },
      "MintNftExpressSolana": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "Chain to work with.",
            "enum": ["SOL"]
          },
          "to": {
            "maxLength": 44,
            "minLength": 43,
            "description": "Blockchain address to send NFT token to",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "metadata": { "$ref": "#/components/schemas/SolanaNftExpressMetadata" }
        },
        "required": ["to", "chain", "metadata"]
      },
      "MintNftSolanaKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": ["SOL"]
          },
          "to": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to mint the NFT from. The transaction fee will be paid from this address.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the sender's address"
          },
          "metadata": { "$ref": "#/components/schemas/SolanaNftMetadataKMS" }
        },
        "required": ["to", "chain", "signatureId", "metadata", "from"]
      },
      "SolanaNftMetadataCreator": {
        "type": "object",
        "required": ["address", "verified", "share"],
        "properties": {
          "address": {
            "type": "string",
            "description": "The blockchain address of the NFT creator",
            "maxLength": 44,
            "minLength": 43,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ"
          },
          "verified": {
            "type": "boolean",
            "description": "If set to <code>true</code>, the NFT creator was verified. Only the address whose private key was used during the minting of the NFT can be a verified creator. If you are minting the NFT using NFT Express, set this parameter to <code>false</code>.",
            "example": true
          },
          "share": {
            "type": "number",
            "description": "The share to be sent to the NFT creator (in %)",
            "example": 100
          }
        }
      },
      "SolanaNftMetadata": {
        "type": "object",
        "required": ["name", "symbol", "uri", "sellerFeeBasisPoints"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the NFT token.",
            "example": "My NFT.",
            "maxLength": 255
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the NFT token.",
            "example": "NFT_SYMBOL",
            "maxLength": 255
          },
          "sellerFeeBasisPoints": {
            "type": "number",
            "description": "Basis points of the seller fee.",
            "example": 0
          },
          "uri": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 500
          },
          "collection": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT will be minted in. Specify the private key of the collection verifier in the <code>collectionVerifierPrivateKey</code> parameter of the request body to get the NFT verified in the collection after the NFT has been minted. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "mutable": {
            "type": "boolean",
            "default": true,
            "description": "If NFT metadata are mutable or not. Defaults to true."
          },
          "creators": {
            "type": "array",
            "description": "Royalty receivers for NFT transfers.",
            "items": { "$ref": "#/components/schemas/SolanaNftMetadataCreator" }
          }
        }
      },
      "SolanaNftMetadataKMS": {
        "type": "object",
        "required": ["name", "symbol", "uri", "sellerFeeBasisPoints"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the NFT token.",
            "example": "My NFT.",
            "maxLength": 255
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the NFT token.",
            "example": "NFT_SYMBOL",
            "maxLength": 255
          },
          "sellerFeeBasisPoints": {
            "type": "number",
            "description": "Basis points of the seller fee.",
            "example": 0
          },
          "uri": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 500
          },
          "collection": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT will be minted in. The minted NFT will get verified in the collection on behalf of the blockchain address specified in the <code>from</code> parameter. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a> and <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftVerifyInCollection\" target=\"_blank\">NFT verification API</a>.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "mutable": {
            "type": "boolean",
            "default": true,
            "description": "If NFT metadata are mutable or not. Defaults to true."
          },
          "creators": {
            "type": "array",
            "description": "Royalty receivers for NFT transfers.",
            "items": { "$ref": "#/components/schemas/SolanaNftMetadataCreator" }
          }
        }
      },
      "SolanaNftExpressMetadata": {
        "type": "object",
        "required": ["name", "symbol", "uri", "sellerFeeBasisPoints"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the NFT token.",
            "example": "My NFT.",
            "maxLength": 255
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the NFT token.",
            "example": "NFT_SYMBOL",
            "maxLength": 255
          },
          "sellerFeeBasisPoints": {
            "type": "number",
            "description": "Basis points of the seller fee.",
            "example": 0
          },
          "uri": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 500
          },
          "collection": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT will be minted in. By default, the NFT is minted as not verified (is not considered a part of the collection). To verify the NFT in the collection, use the <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftVerifyInCollection\" target=\"_blank\">NFT verification API</a>. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "mutable": {
            "type": "boolean",
            "default": true,
            "description": "If NFT metadata are mutable or not. Defaults to true."
          },
          "creators": {
            "type": "array",
            "description": "Royalty receivers for NFT transfers.",
            "items": { "$ref": "#/components/schemas/SolanaNftMetadataCreator" }
          }
        }
      },
      "MintMultipleNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency, ETH or BSC.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "MintMultipleNftMinter": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "CELO", "KCS", "ONE", "KLAY", "BSC"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "minter": {
            "maxLength": 42,
            "minLength": 43,
            "description": "Address of NFT minter, which will be used to mint the tokens. From this address, transaction fees will be deducted.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas, only valid for CELO chain.",
            "enum": ["CELO"]
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "minter", "tokenId"]
      },
      "MintMultipleNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "type": "array",
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency, ETH or BSC.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockhain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "tokenId", "url", "signatureId"]
      },
      "BurnNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "tokenId": {
            "description": "The ID of the NFT to burn",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 1,
            "description": "The blockchain address of the NFT to burn",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "AddNftMinter": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "CELO", "ONE", "KLAY", "BSC"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas, only valid for CELO chain.",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["minter", "chain", "url", "contractAddress", "fromPrivateKey"]
      },
      "UpdateCashbackValueForAuthorNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "tokenId": {
            "description": "ID of token to be updated.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "cashbackValue": {
            "type": "string",
            "description": "New royalty cashback to be set for the author of token with tokenId. If set to 0, royalty is disabled for this token.",
            "example": "0.1"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "tokenId", "cashbackValue", "signatureId"]
      },
      "UpdateCashbackValueForAuthorNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "tokenId": {
            "description": "ID of token to be updated.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "cashbackValue": {
            "type": "string",
            "description": "New royalty cashback to be set for the author of token with tokenId. If set to 0, royalty is disabled for this token.",
            "example": "0.1"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "cashbackValue", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "BurnNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": ["ETH", "MATIC", "KCS", "ONE", "KLAY", "BSC"]
          },
          "tokenId": {
            "description": "The ID of the NFT to burn",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT to burn",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the specific address from the mnemonic"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transfer transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "description": "The custom defined fee; if not present, will be calculated automatically",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "tokenId", "signatureId"]
      },
      "AddNftMinterKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "CELO", "ONE", "KLAY", "BSC"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas, only valid for CELO chain.",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "url", "contractAddress", "minter", "signatureId"]
      },
      "NftGetBalanceSc": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "description": "The array returning the ID of the NFTs",
            "items": { "type": "string", "description": "The ID of the NFT", "example": "10" }
          }
        }
      },
      "NftGetBalanceScAlgo": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "required": ["contractAddress", "balances"],
            "items": {
              "type": "object",
              "properties": {
                "contractAddress": {
                  "type": "string",
                  "description": "The asset ID (the ID of the NFT)",
                  "example": "116227380"
                },
                "balances": {
                  "type": "array",
                  "description": "The array returning <code>1</code> to indicate that the NFT with the specified ID exists",
                  "items": { "type": "string", "example": "1" }
                },
                "metadata": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "url": {
                        "description": "The URL pointing to the NFT metadata; may not be present",
                        "example": "ipfs://QmXFpaS3S7CkLZvihLFA9JbawKdqhjg8dJeDkPntmkD2Pc",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "ChainDeployErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "XDC", "ONE"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "fromPrivateKey", "digits"]
      },
      "ChainDeploySolanaSpl": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "Chain to work with.",
            "enum": ["SOL"]
          },
          "supply": {
            "description": "Initial supply of SPL token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "address": {
            "description": "Address on Solana blockchain, where all created SPL tokens will be transferred.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "from": {
            "description": "Address on Solana blockchain, from which the fee for the deployment of SPL will be paid.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Solana account address, from which the fee for the deployment of SPL will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "maxLength": 103,
            "minLength": 128
          }
        },
        "required": ["chain", "from", "address", "supply", "fromPrivateKey", "digits"]
      },
      "ChainDeploySolanaSplKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "Chain to work with.",
            "enum": ["SOL"]
          },
          "supply": {
            "description": "Initial supply of SPL token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "address": {
            "description": "Address on Solana blockchain, where all created SPL tokens will be transferred.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "from": {
            "description": "Address on Solana blockchain, from which the fee for the deployment of SPL will be paid.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["chain", "from", "address", "supply", "signatureId", "digits"]
      },
      "FungibleTx": {
        "type": "object",
        "properties": {
          "blockNumber": { "type": "number", "example": 6541235, "description": "Block number" },
          "txId": {
            "type": "string",
            "example": "0x955c1037608c7aecb6d1a3f150ce7d0a80536bcabb0deb69d62f55292cc4c372",
            "description": "Transaction ID"
          },
          "contractAddress": {
            "type": "string",
            "example": "0x4f54fAD27F7F46C102Cd49b8E75C5593397cd9c3",
            "description": "Contract address"
          },
          "amount": {
            "type": "string",
            "example": "1",
            "description": "Amount of tokens transferred, in smallest decimals"
          },
          "from": {
            "type": "string",
            "example": "0x780c3de0aba1b51f04cfe8a5d9d277d4ad032b8d",
            "description": "Sender"
          },
          "to": {
            "type": "string",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea",
            "description": "recipient"
          }
        },
        "required": ["txId", "blockNumber", "contractAddress", "amount", "from", "to"]
      },
      "ChainDeployErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "XDC", "ONE"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "signatureId", "digits"]
      },
      "ChainDeployKcsErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "fromPrivateKey", "digits"]
      },
      "ChainDeployKcsErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "signatureId", "digits"]
      },
      "ChainDeployAlgoErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 8,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 32,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 19,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 58,
            "minLength": 42,
            "example": "52NRXAHUDA5RKC7Q6YYJHBINGTJB7NXLUVY3CSKOBLLNLTKCN2NGPRGTN0",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "GDNQECUM2JDPTA4KXNSXHQBAYL56FDZ73NXCQ2OLB32PN2G5BLNO5GY3QD2BQOYVBPYPMMETQUGTJUQ7W3V2K4NRJFHAVVWVZVBG5G2",
            "maxLength": 103,
            "minLength": 103
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "fromPrivateKey", "digits"]
      },
      "ChainDeployAlgoErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 8,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 32,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 19,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 58,
            "minLength": 42,
            "example": "52NRXAHUDA5RKC7Q6YYJHBINGTJB7NXLUVY3CSKOBLLNLTKCN2NGPRGTN0",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "signatureId", "digits"]
      },
      "ChainDeployCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "fromPrivateKey",
          "digits",
          "feeCurrency"
        ]
      },
      "ChainDeployCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "name", "symbol", "address", "supply", "signatureId", "digits", "feeCurrency"]
      },
      "ChainMintErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "XDC", "ONE"]
          },
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "to", "amount", "contractAddress", "fromPrivateKey"]
      },
      "ChainMintKcsErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "to", "amount", "contractAddress", "fromPrivateKey"]
      },
      "ChainMintErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "XDC"]
          },
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "to", "amount", "contractAddress", "signatureId"]
      },
      "ChainMintKcsErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "to", "amount", "contractAddress", "signatureId"]
      },
      "ChainMintCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "amount", "feeCurrency", "contractAddress", "fromPrivateKey"]
      },
      "ChainMintCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "amount", "feeCurrency", "contractAddress", "signatureId"]
      },
      "ApproveErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "ONE"]
          },
          "amount": {
            "description": "Amount to be approved for the spender.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "spender": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address of the new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "spender", "amount", "contractAddress", "fromPrivateKey"]
      },
      "ApproveErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "ONE"]
          },
          "amount": {
            "description": "Amount to be approved for the spender.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "spender": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address of the new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "spender", "amount", "contractAddress", "signatureId"]
      },
      "ApproveCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "amount": {
            "description": "Amount to be approved for the spender.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address of the new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "spender", "amount", "feeCurrency", "contractAddress", "fromPrivateKey"]
      },
      "ApproveCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "amount": {
            "description": "Amount to be approved for the spender.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address of the new spender.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "spender", "amount", "feeCurrency", "contractAddress", "signatureId"]
      },
      "ChainBurnErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "XDC", "ONE", "ALGO"]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "contractAddress", "fromPrivateKey", "amount"]
      },
      "ChainBurnErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "XDC", "ALGO"]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "contractAddress", "signatureId", "amount"]
      },
      "ChainBurnKcsErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "contractAddress", "fromPrivateKey", "amount"]
      },
      "ChainBurnKcsErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          }
        },
        "required": ["chain", "contractAddress", "signatureId", "amount"]
      },
      "ChainBurnCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "contractAddress", "feeCurrency", "fromPrivateKey", "amount"]
      },
      "ChainBurnCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "contractAddress", "feeCurrency", "signatureId", "amount"]
      },
      "ChainTransferAlgoErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "to": {
            "maxLength": 58,
            "minLength": 42,
            "description": "Blockchain address to send ERC20 token to",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 1,
            "description": "assetIndex - asset index uniquely specifying the asset",
            "example": "1",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "72TCV5BRQPBMSAFPYO3CPWVDBYWNGAYNMTW5QHENOMQF7I6QLNMJWCJZ7A3V5YKD7QD6ZZPEHG2PV2ZVVEDDO6BCRGXWIL3DIUMSUCI",
            "minLength": 103,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "fromPrivateKey", "amount"]
      },
      "ChainTransferAlgoErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "Chain to work with.",
            "enum": ["ALGO"]
          },
          "to": {
            "maxLength": 58,
            "minLength": 42,
            "description": "Blockchain address to send ERC20 token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 1,
            "description": "assetIndex - asset index uniquely specifying the asset",
            "example": "1",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "from": {
            "maxLength": 58,
            "minLength": 42,
            "description": "Blockchain address to send ERC20 token to",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "signatureId", "amount", "from"]
      },
      "ChainTransferEthErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "XDC", "ONE"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "digits", "fromPrivateKey", "amount"]
      },
      "ChainTransferSolanaSpl": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "Chain to work with.",
            "enum": ["SOL"]
          },
          "to": {
            "description": "Address on Solana blockchain, where SPL tokens will be transferred.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 44,
            "description": "Address of SPL token",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that SPL token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "from": {
            "description": "Address on the Solana blockchain, from which the token will be transferred.",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 87,
            "example": "YdQ1iy2NYs93dtkHdz3ijDuhRJj6uXYAUZmixirCrgCsTMj42BN1Q1buYcGZaMxw5buk9VU5ogQ6zuzn8DMsGaf",
            "minLength": 128,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feePayer": {
            "description": "Address on the Solana blockchain, from which the fee will be paid for transaction. Defaults to from.",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "feePayerPrivateKey": {
            "type": "string",
            "maxLength": 87,
            "example": "YdQ1iy2NYs93dtkHdz3ijDuhRJj6uXYAUZmixirCrgCsTMj42BN1Q1buYcGZaMxw5buk9VU5ogQ6zuzn8DMsGaf",
            "minLength": 128,
            "description": "Private key of the fee payer address."
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "fromPrivateKey",
          "from",
          "amount"
        ]
      },
      "ChainTransferSolanaSplKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "Chain to work with.",
            "enum": ["SOL"]
          },
          "to": {
            "description": "Address on Solana blockchain, where SPL tokens will be transferred.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 44,
            "description": "Address of SPL token",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that SPL token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "from": {
            "description": "Address on the Solana blockchain, from which the token will be transferred.",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feePayer": {
            "description": "Blockchain address to pay the fee for the transaction from",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 44,
            "minLength": 43,
            "type": "string"
          },
          "feePayerSignatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key used for paying the gas costs in signing application. Defaults to the signatureId."
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "digits", "signatureId", "from", "amount"]
      },
      "ChainTransferEthErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "MATIC", "KLAY", "XDC", "ONE"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "digits", "signatureId", "amount"]
      },
      "ChainTransferKcsEthErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "digits", "fromPrivateKey", "amount"]
      },
      "ChainTransferKcsEthErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "Chain to work with.",
            "enum": ["KCS"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "currency", "to", "contractAddress", "digits", "signatureId", "amount"]
      },
      "ChainTransferBscBep20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "BSC",
            "description": "Chain to work with.",
            "enum": ["BSC"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send BEP20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of BEP20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that BEP20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to BSC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "to", "contractAddress", "digits", "fromPrivateKey", "amount"]
      },
      "ChainTransferBscBep20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "BSC",
            "description": "Chain to work with.",
            "enum": ["BSC"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send BEP20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of BEP20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that BEP20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to BSC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "to", "contractAddress", "digits", "signatureId", "amount"]
      },
      "ChainTransferCeloErc20Token": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "digits", "feeCurrency", "fromPrivateKey", "amount"]
      },
      "ChainTransferCeloErc20TokenKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "digits", "feeCurrency", "signatureId", "amount"]
      },
      "ChainCallSmartContractMethod": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "BSC", "XDC"]
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["chain", "contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallCeloSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName", "feeCurrency"]
      },
      "TransferMultiTokenCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "amount": {
            "description": "Amount of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "tokenId", "fromPrivateKey", "amount", "feeCurrency"]
      },
      "MultiTx": {
        "type": "object",
        "properties": {
          "blockNumber": { "type": "number", "example": 6541235, "description": "Block number" },
          "txId": {
            "type": "string",
            "example": "0x955c1037608c7aecb6d1a3f150ce7d0a80536bcabb0deb69d62f55292cc4c372",
            "description": "Transaction ID"
          },
          "contractAddress": {
            "type": "string",
            "example": "0x4f54fAD27F7F46C102Cd49b8E75C5593397cd9c3",
            "description": "Contract address"
          },
          "tokenId": { "type": "string", "example": "1", "description": "ID of the token" },
          "amount": { "type": "string", "example": "1", "description": "Amount of tokens transferred." },
          "from": {
            "type": "string",
            "example": "0x780c3de0aba1b51f04cfe8a5d9d277d4ad032b8d",
            "description": "Sender"
          },
          "operator": {
            "type": "string",
            "example": "0x780c3de0aba1b51f04cfe8a5d9d277d4ad032b8d",
            "description": "Operator"
          },
          "to": {
            "type": "string",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea",
            "description": "recipient"
          }
        },
        "required": ["blockNumber", "txId", "contractAddress", "tokenId", "from", "to", "amount", "operator"]
      },
      "TransferMultiTokenBatchCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string", "maxLength": 32 }
          },
          "amounts": {
            "description": "Amount of token to be transferred",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string", "maxLength": 32 }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "tokenId", "amounts", "fromPrivateKey"]
      },
      "DeployMultiTokenCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "uri": {
            "description": "URI of the Multi Token contract",
            "example": "example.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type",
            "example": true,
            "type": "boolean"
          },
          "fromPrivateKey": {
            "description": "Private key of account address, from which gas for deployment of ERC1155 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "uri", "feeCurrency", "fromPrivateKey"]
      },
      "DeployMultiTokenCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "uri": {
            "description": "URI of the Multi Token contract",
            "example": "example.com",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type",
            "example": true,
            "type": "boolean"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": { "type": "number", "minimum": 0 },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "uri", "feeCurrency", "signatureId"]
      },
      "MintMultiTokenBatchKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "type": "array",
            "description": "The blockchain address to send the Multi Tokens to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "The IDs of the Multi Tokens to be created.",
            "example": [["100000", "100001"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "amounts": {
            "type": "array",
            "description": "The amounts of the Multi Tokens to be created.",
            "example": [["100", "100"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "feeCurrency", "tokenId", "amounts", "signatureId"]
      },
      "BurnMultiTokenCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "amount": {
            "description": "amount of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeCurrency",
          "fromPrivateKey",
          "tokenId",
          "amount",
          "account"
        ]
      },
      "BurnMultiTokenBatchCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "The IDs of the Multi Tokens to be destroyed.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string", "maxLength": 32 }
          },
          "amounts": {
            "description": "The amounts of the Multi Tokens to be destroyed.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string" }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeCurrency",
          "fromPrivateKey",
          "tokenId",
          "amounts",
          "account"
        ]
      },
      "BurnMultiTokenKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "amount": {
            "description": "amount of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "feeCurrency", "contractAddress", "tokenId", "amount", "signatureId", "account"]
      },
      "AddMultiTokenMinterKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "KLAY", "CELO", "ONE", "BSC"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of MultiToken token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of MultiToken minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas, only valid for CELO chain.",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "url", "contractAddress", "minter", "signatureId"]
      },
      "AddMultiTokenMinter": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "MATIC", "KCS", "KLAY", "CELO", "ONE", "BSC"]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of MultiToken token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of MultiToken minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Ethereum transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas, only valid for CELO chain.",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["minter", "chain", "url", "contractAddress", "fromPrivateKey"]
      },
      "BurnMultiTokenBatchKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "The IDs of the Multi Tokens to be destroyed.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string", "maxLength": 32 }
          },
          "amounts": {
            "description": "The amounts of the Multi Tokens to be destroyed.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string" }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": [
          "chain",
          "feeCurrency",
          "contractAddress",
          "tokenId",
          "amounts",
          "account",
          "signatureId"
        ]
      },
      "TransferMultiTokenKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "amount": {
            "description": "amount of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "feeCurrency", "signatureId", "tokenId", "amount"]
      },
      "TransferMultiTokenBatchKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string" }
          },
          "amounts": {
            "description": "amounts of token.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string" }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "contractAddress", "feeCurrency", "signatureId", "tokenId", "amounts"]
      },
      "MintMultiTokenCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "amount": {
            "description": "amount of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "tokenId", "amount", "feeCurrency", "contractAddress", "fromPrivateKey"]
      },
      "MintMultiTokenBatchCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "type": "array",
            "description": "The IDs of the Multi Tokens to be created.",
            "example": [["100000", "100001"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "amounts": {
            "type": "array",
            "description": "The amounts of the Multi Tokens to be created.",
            "example": [["100", "100"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the Multi Tokens to",
            "example": ["0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f"],
            "type": "array",
            "items": { "type": "string" }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "tokenId", "amounts", "feeCurrency", "contractAddress", "fromPrivateKey"]
      },
      "MintMultiTokenKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "Chain to work with.",
            "enum": ["CELO"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "amount": {
            "description": "amount of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["chain", "to", "tokenId", "amount", "feeCurrency", "contractAddress", "signatureId"]
      },
      "TransferMultiToken": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC", "ALGO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "amount": {
            "description": "amount of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "tokenId", "fromPrivateKey", "amount"]
      },
      "TransferMultiTokenBatch": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string", "maxLength": 256 }
          },
          "amounts": {
            "description": "amounts of token.",
            "example": ["100000"],
            "type": "array",
            "maxLength": 256,
            "items": { "type": "string", "maxLength": 32 }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "tokenId", "amounts", "fromPrivateKey"]
      },
      "DeployMultiToken": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "uri": {
            "description": "URI of the Multi Token token",
            "example": "example.com",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of account address, from which gas for deployment of ERC1155 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "publicMint": {
            "description": "True if the contract is publicMint type",
            "example": true,
            "type": "boolean"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["uri", "chain", "fromPrivateKey"]
      },
      "DeployMultiTokenKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "uri": {
            "description": "URI of the Multi Token token",
            "example": "example.com",
            "type": "string"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type",
            "example": true,
            "type": "boolean"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["uri", "chain", "signatureId"]
      },
      "TransferMultiTokenKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC", "ALGO"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "amount": {
            "description": "amount of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "signatureId", "tokenId", "amount"]
      },
      "TransferMultiTokenBatchKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": ["100000"],
            "type": "array",
            "items": { "type": "string", "maxLength": 256 }
          },
          "amount": {
            "description": "amount of token.",
            "example": ["100000"],
            "type": "array",
            "maxLength": 256,
            "items": { "type": "string", "maxLength": 32 }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "signatureId", "tokenId", "amount"]
      },
      "MintMultiToken": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC", "ALGO"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "amount of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "fromPrivateKey", "tokenId", "amount"]
      },
      "MintMultiTokenKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC", "ALGO"]
          },
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send Multi Token token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "amount of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "signatureId", "tokenId", "amount"]
      },
      "MintMultiTokenBatch": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "to": {
            "type": "array",
            "description": "The blockchain address to send the Multi Tokens to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "The IDs of the Multi Tokens to be created.",
            "example": [["100000", "100001"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "amounts": {
            "type": "array",
            "description": "The amounts of the Multi Tokens to be created.",
            "example": [["100", "100"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "url", "contractAddress", "fromPrivateKey", "tokenId", "amounts"]
      },
      "MintMultiTokenBatchKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "to": {
            "type": "array",
            "description": "The blockchain address to send the Multi Tokens to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "The IDs of the Multi Tokens to be created.",
            "example": [["100000", "100001"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "amounts": {
            "type": "array",
            "description": "The amounts of the Multi Tokens to be created.",
            "example": [["100", "100"]],
            "items": { "type": "array", "items": { "type": "string", "maxLength": 32 } }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "chain", "contractAddress", "tokenId", "url", "signatureId", "amounts"]
      },
      "BurnMultiToken": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC", "ALGO"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "amount": {
            "description": "amount of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["account", "chain", "contractAddress", "fromPrivateKey", "tokenId", "amount"]
      },
      "BurnMultiTokenBatch": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "The IDs of the Multi Tokens to be destroyed.",
            "example": ["1000", "1001"],
            "type": "array",
            "items": { "type": "string", "maxLength": 32 }
          },
          "amounts": {
            "description": "The amounts of the Multi Tokens to be destroyed.",
            "example": ["10", "10"],
            "type": "array",
            "items": { "type": "string" }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["account", "amounts", "chain", "url", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "BurnMultiTokenKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC", "ALGO"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "amount": {
            "description": "amount of token to be destroyed.",
            "example": "100",
            "type": "string",
            "maxLength": 32
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of Multi Token token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["account", "chain", "amount", "contractAddress", "tokenId", "signatureId"]
      },
      "BurnMultiTokenBatchKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "Chain to work with.",
            "enum": ["ETH", "ONE", "MATIC", "KCS", "KLAY", "BSC"]
          },
          "account": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of holder",
            "example": "0x4b812a77b109A150C2Fc89eD133EaBC78bC9EC8f",
            "type": "string"
          },
          "tokenId": {
            "description": "The IDs of the Multi Tokens to be destroyed.",
            "example": ["100", "101"],
            "type": "array",
            "items": { "type": "string", "maxLength": 32 }
          },
          "amounts": {
            "description": "The amounts of the Multi Tokens to be destroyed.",
            "example": ["10", "10"],
            "type": "array",
            "items": { "type": "string" }
          },
          "data": { "description": "Data in bytes", "example": "0x1234", "type": "string" },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the Multi Token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["account", "chain", "amounts", "contractAddress", "tokenId", "signatureId"]
      },
      "SolanaBlock": {
        "type": "object",
        "properties": {
          "blockHeight": { "type": "number", "example": 94778421 },
          "blockTime": { "type": "number", "example": 1638279333 },
          "blockhash": { "type": "string", "example": "Ch7qVhCkSqEvhWE8xzJZbJKRcsH6wtTjfiMJdt9eKiD7" },
          "parentSlot": { "type": "number", "example": 97742681 },
          "previousBlockhash": {
            "type": "string",
            "example": "C3vsoVwVWx7yPRhsNoKpcm2CJTrnVcvimdC4bd3jTPbj"
          },
          "rewards": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "commission": { "type": "string", "format": "nullable" },
                "lamports": { "type": "number", "example": 7 },
                "postBalance": { "type": "number", "example": 10149491708073344 },
                "pubkey": { "type": "string", "example": "ETSKPSzESbVdmtUn67LA2p9J1gPCSEgYvmJS9pNNWQqR" },
                "rewardType": { "type": "string", "example": "Rent" }
              }
            }
          },
          "transactions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "meta": {
                  "type": "object",
                  "properties": {
                    "err": { "type": "string", "format": "nullable" },
                    "fee": { "type": "number", "example": 5000 },
                    "innerInstructions": { "type": "array", "items": { "type": "object" } },
                    "logMessages": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "example": "Program Vote111111111111111111111111111111111111111 invoke [1]"
                      }
                    },
                    "postBalances": {
                      "type": "array",
                      "items": { "type": "number", "example": 1101768559544744 }
                    },
                    "postTokenBalances": {
                      "type": "array",
                      "items": { "type": "number", "example": 1101768559549744 }
                    },
                    "preBalances": {
                      "type": "array",
                      "items": { "type": "number", "example": 1101768559549744 }
                    },
                    "preTokenBalances": {
                      "type": "array",
                      "items": { "type": "number", "example": 1101768559549744 }
                    }
                  }
                },
                "transaction": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "object",
                      "properties": {
                        "header": {
                          "type": "object",
                          "properties": {
                            "numReadonlySignedAccounts": { "type": "number", "example": 0 },
                            "numReadonlyUnsignedAccounts": { "type": "number", "example": 3 },
                            "numRequiredSignatures": { "type": "number", "example": 1 }
                          }
                        },
                        "accountKeys": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "_bn": {
                                "type": "string",
                                "example": "0974de54f77afa9ad3d474909f6ce095b9623a359a5d08cc807b8a92dd5e1f96"
                              }
                            }
                          }
                        },
                        "recentBlockhash": {
                          "type": "string",
                          "example": "C3vsoVwVWx7yPRhsNoKpcm2CJTrnVcvimdC4bd3jTPbj"
                        },
                        "instructions": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "accounts": { "type": "array", "items": { "type": "number", "example": 1 } },
                              "data": {
                                "type": "string",
                                "example": "2ZjTR1vUs2pHXyTM4rXnJowxekwfBcBJwsE4EameG3Sapvgfit27vrBd8k8QYCoTtMgfHEJLDqWEWBYUYVd"
                              },
                              "programIdIndex": { "type": "number", "example": 4 }
                            }
                          }
                        },
                        "indexToProgramIds": { "type": "object" }
                      }
                    },
                    "signatures": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "example": "5FPSzkTsjZDBigU3ZagvkcwSPimt4K6voqrN9uUNVzWDBeRXWVH3uMarDPpSfrS7sFQeyKyDd5KpbdCrL3EWEP59"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "SolanaTx": {
        "type": "object",
        "properties": {
          "blockTime": { "type": "number", "example": 1638279975 },
          "meta": {
            "type": "object",
            "properties": {
              "err": { "type": "string", "format": "nullable" },
              "fee": { "type": "number", "example": 5000 },
              "innerInstructions": { "type": "array", "items": { "type": "object" } },
              "logMessages": {
                "type": "array",
                "items": {
                  "type": "string",
                  "example": "Program 11111111111111111111111111111111 invoke [1]"
                }
              },
              "postBalances": { "type": "array", "items": { "type": "number", "example": 987013800 } },
              "postTokenBalances": { "type": "array", "items": { "type": "number", "example": 12345321 } },
              "preBalances": { "type": "array", "items": { "type": "number", "example": 988018800 } },
              "preTokenBalances": { "type": "array", "items": { "type": "number", "example": 12345321 } },
              "rewards": { "type": "array", "items": { "type": "object" } },
              "status": {
                "type": "object",
                "properties": { "Ok": { "type": "string", "format": "nullable" } }
              }
            }
          },
          "slot": { "type": "number", "example": 97744333 },
          "transaction": {
            "type": "object",
            "properties": {
              "message": {
                "type": "object",
                "properties": {
                  "header": {
                    "type": "object",
                    "properties": {
                      "numReadonlySignedAccounts": { "type": "number", "example": 0 },
                      "numReadonlyUnsignedAccounts": { "type": "number", "example": 1 },
                      "numRequiredSignatures": { "type": "number", "example": 1 }
                    }
                  },
                  "accountKeys": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "_bn": {
                          "type": "string",
                          "example": "de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad"
                        }
                      }
                    }
                  },
                  "recentBlockhash": {
                    "type": "string",
                    "example": "4pMdFUHg8bqTv19So2ZdvorGWqHwzFBmZL5wf8gDJ8Eh"
                  },
                  "instructions": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "accounts": { "type": "array", "items": { "type": "number", "example": 0 } },
                        "data": { "type": "string", "example": "3Bxs4Bc3VYuGVB19" },
                        "programIdIndex": { "type": "number", "example": 2 }
                      }
                    }
                  },
                  "indexToProgramIds": { "type": "object" }
                }
              },
              "signatures": {
                "type": "array",
                "items": {
                  "type": "string",
                  "example": "2ast4sMbp796obAKq5XDZnKf2truXdxC2u75c6UnzBeK5bZ7BjjZoE5uMy9pyr3dzxoakE67NvB7Cdgn21zE3BVG"
                }
              }
            }
          }
        }
      },
      "Error403SolanaBroadcast": {
        "properties": {
          "errorCode": {
            "description": "solana.broadcast.failed",
            "example": "Solana.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SolanaBroadcastConfirm": {
        "properties": {
          "errorCode": {
            "description": "solana.broadcast.confirm.failed",
            "example": "Solana.broadcast.confirm.failed",
            "type": "string"
          },
          "message": {
            "description": "Unexpected error occurred. Reason: ${error}.",
            "example": "Unexpected error occurred. Reason: ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SolanaBep20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such ERC20 currency ${name}.",
            "example": "No such ERC20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SolanaTxHash": {
        "properties": {
          "errorCode": {
            "description": "solana.transaction.hash",
            "example": "solana.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SolanaTxSign": {
        "properties": {
          "errorCode": {
            "description": "solana.transaction.sign",
            "example": "solana.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403SolanaTxBody": {
        "properties": {
          "errorCode": {
            "description": "solana.transaction.body",
            "example": "Solana.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TransferSolanaBlockchain": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Blockchain address to send assets from",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 44,
            "minLength": 44,
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets to",
            "example": "FZAS4mtPvswgVxbpc117SqfNgCDLTCtk5CoeAtt58FWU",
            "maxLength": 44,
            "minLength": 44,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in SOL.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "zgsAKfjuXrAxEyuYRxbbxPM3rdsPbJPnGreaGMbcdUApJ6wHnCqQnf9b1RNPdeZxsRMkezh4VgXQ7YrbpndGtEv",
            "minLength": 87,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feePayer": {
            "description": "Address on the Solana blockchain, from which the fee will be paid for transaction. Defaults to from.",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "feePayerPrivateKey": {
            "type": "string",
            "maxLength": 87,
            "example": "YdQ1iy2NYs93dtkHdz3ijDuhRJj6uXYAUZmixirCrgCsTMj42BN1Q1buYcGZaMxw5buk9VU5ogQ6zuzn8DMsGaf",
            "minLength": 128,
            "description": "Private key of the fee payer address."
          }
        },
        "required": ["to", "amount", "from", "fromPrivateKey"]
      },
      "TransferSolanaBlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Blockchain address to send assets from",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 44,
            "minLength": 43,
            "type": "string"
          },
          "to": {
            "description": "Blockchain address to send assets to",
            "example": "FZAS4mtPvswgVxbpc117SqfNgCDLTCtk5CoeAtt58FWU",
            "maxLength": 44,
            "minLength": 43,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in SOL.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feePayer": {
            "description": "Blockchain address to pay the fee for the transaction from",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 44,
            "minLength": 43,
            "type": "string"
          },
          "feePayerSignatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key used for paying the gas costs in signing application. Defaults to the signatureId."
          }
        },
        "required": ["to", "amount", "from", "signatureId"]
      },
      "SolanaBroadcastConfirm": {
        "properties": {
          "txData": {
            "description": "Raw signed transaction to be published to network.",
            "example": "01de391b34567fc65080dfe9e27170e2f9ac1cd1719878719feb74bb422d1795201df71fcf7349f5",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "options": {
            "description": "Options for sending and waiting for a transaction",
            "type": "object",
            "properties": {
              "commitment": {
                "type": "string",
                "description": "Commitment to waiting for transaction confirmation",
                "example": "confirmed",
                "enum": ["confirmed", "finalized"]
              },
              "preflightCommitment": {
                "type": "string",
                "description": "Preflight Commitment.",
                "example": "finalized",
                "enum": ["confirmed", "finalized", "processed", "recent", "single", "singleGossip", "max"]
              }
            }
          }
        },
        "required": ["txData"],
        "type": "object"
      },
      "SolanaTransactionHashWithConfirm": {
        "type": "object",
        "properties": {
          "txId": {
            "description": "TX hash of successful transaction.",
            "example": "5Sh63rNFg6iR9YUGPwEkbAg4kYSWnf5eRS2wcLG1Gc6psj27SGK3LNuN9jNSPKn3JoChgmq8pSirHWsPPWzy2PFw",
            "type": "string"
          },
          "confirmed": {
            "description": "Indicates whether or not the transferred commitment has been fulfilled",
            "example": false,
            "type": "boolean"
          }
        },
        "required": ["txId", "confirmed"]
      },
      "BscBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BscTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "BscTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "blockNumber": {
                  "type": "number",
                  "description": "Block number where this transaction was in.",
                  "example": 6470854
                },
                "blockHash": {
                  "description": "Hash of the block.",
                  "type": "string",
                  "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      },
      "Error403BscBroadcast": {
        "properties": {
          "errorCode": {
            "description": "bsc.broadcast.failed",
            "example": "bsc.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscBep20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such BEP20 currency ${name}.",
            "example": "No such BEP20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscBep20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "BEP20 address was already set.",
            "example": "BEP20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscBep20Unsupported": {
        "properties": {
          "errorCode": {
            "description": "bsc.bep20.unsupported",
            "example": "bsc.bep20.unsupported",
            "type": "string"
          },
          "message": {
            "description": "Unsupported ETH BEP20 blockchain.",
            "example": "Unsupported ETH BEP20 blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscTxHash": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.hash",
            "example": "bsc.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscTxSign": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.sign",
            "example": "bsc.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscErc20TxSign": {
        "properties": {
          "errorCode": { "description": "bsc.bep20.sign", "example": "bsc.bep20.sign", "type": "string" },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.gas",
            "example": "bsc.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscTxBody": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.body",
            "example": "bsc.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscScBody": {
        "properties": {
          "errorCode": { "description": "bsc.sc.invalid", "example": "bsc.sc.invalid", "type": "string" },
          "message": {
            "description": "Invalid parameters for smart contract invocation.",
            "example": "Invalid parameters for smart contract invocation.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403BscGasPrice": {
        "properties": {
          "errorCode": { "description": "gas.price.failed", "example": "gas.price.failed", "type": "string" },
          "message": {
            "description": "Unable to obtain current GAS price.",
            "example": "Unable to obtain current GAS price.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TransferBep20Blockchain": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "digits", "fromPrivateKey", "amount"]
      },
      "TransferBep20BlockchainKMS": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "signatureId", "digits", "amount"]
      },
      "CallBscSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to BSC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallBscSmartContractReadMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallBscSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to BSC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferBscBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for BSC transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to BSC transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from BSC Blockchain Account. BEP20 tokens BETH, BBTC, BADA, WBNB, BDOT, BXRP, BLTC, BBCH are available only for mainnet use.",
            "enum": [
              "BSC",
              "BETH",
              "BBTC",
              "RMD",
              "USDC_BSC",
              "B2U_BSC",
              "BADA",
              "WBNB",
              "GMC_BSC",
              "BDOT",
              "BXRP",
              "BLTC",
              "BBCH",
              "HAG",
              "CAKE",
              "BUSD_BSC"
            ],
            "example": "BSC",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "fromPrivateKey"]
      },
      "BscEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in BSC.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "TransferBscBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for BSC transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to BSC transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from BSC Blockchain Account. BEP20 tokens BETH, BBTC, BADA, WBNB, BDOT, BXRP, BLTC, BBCH are available only for mainnet use.",
            "enum": ["BETH", "BBTC", "BADA", "WBNB", "BDOT", "BXRP", "BLTC", "BBCH", "BSC"],
            "example": "BSC",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "signatureId"]
      },
      "DeployBep20": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Kcs blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Kcs account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "symbol", "address", "supply", "fromPrivateKey", "digits"]
      },
      "DeployBep20KMS": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Kcs blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["name", "symbol", "address", "supply", "signatureId", "digits"]
      },
      "PolygonBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/PolygonTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "PolygonTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "blockNumber": {
                  "type": "number",
                  "description": "Block number where this transaction was in.",
                  "example": 6470854
                },
                "blockHash": {
                  "description": "Hash of the block.",
                  "type": "string",
                  "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      },
      "Error403PolygonBroadcast": {
        "properties": {
          "errorCode": {
            "description": "polygon.broadcast.failed",
            "example": "polygon.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonBep20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such ERC20 currency ${name}.",
            "example": "No such ERC20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonBep20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "ERC20 address was already set.",
            "example": "ERC20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonBep20Unsupported": {
        "properties": {
          "errorCode": {
            "description": "polygon.bep20.unsupported",
            "example": "polygon.bep20.unsupported",
            "type": "string"
          },
          "message": {
            "description": "Unsupported ETH ERC20 blockchain.",
            "example": "Unsupported ETH ERC20 blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonTxHash": {
        "properties": {
          "errorCode": {
            "description": "polygon.transaction.hash",
            "example": "polygon.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonTxSign": {
        "properties": {
          "errorCode": {
            "description": "polygon.transaction.sign",
            "example": "polygon.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonErc20TxSign": {
        "properties": {
          "errorCode": {
            "description": "polygon.bep20.sign",
            "example": "polygon.bep20.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "polygon.transaction.gas",
            "example": "polygon.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonTxBody": {
        "properties": {
          "errorCode": {
            "description": "polygon.transaction.body",
            "example": "polygon.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonScBody": {
        "properties": {
          "errorCode": {
            "description": "polygon.sc.invalid",
            "example": "polygon.sc.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid parameters for smart contract invocation.",
            "example": "Invalid parameters for smart contract invocation.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403PolygonGasPrice": {
        "properties": {
          "errorCode": { "description": "gas.price.failed", "example": "gas.price.failed", "type": "string" },
          "message": {
            "description": "Unable to obtain current GAS price.",
            "example": "Unable to obtain current GAS price.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "CallPolygonSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallPolygonSmartContractMethodCaller": {
        "type": "object",
        "properties": {
          "caller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the account, which will be sender and fee payer of this transaction",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName", "caller"]
      },
      "CallPolygonSmartContractReadMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallPolygonSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferPolygonBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for MATIC transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Polygon Blockchain Account. ERC20 tokens USDC and USDT are available only for mainnet use.",
            "enum": ["MATIC", "USDC_MATIC", "USDT_MATIC"],
            "example": "MATIC",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "fromPrivateKey"]
      },
      "PolygonEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in MATIC.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "TransferPolygonBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for MATIC transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Polygon Blockchain Account. ERC20 tokens BETH, BBTC, BADA, WMATIC, BDOT, BXRP, BLTC, BBCH are available only for mainnet use.",
            "enum": ["BETH", "BBTC", "BADA", "WMATIC", "BDOT", "BXRP", "BLTC", "BBCH", "MATIC"],
            "example": "MATIC",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "signatureId"]
      },
      "Error403Celo": {
        "properties": {
          "errorCode": { "description": "celo.error", "example": "celo.error", "type": "string" },
          "message": {
            "description": "Unexpected error occurred. Reason: ${reason}",
            "example": "Unexpected error occurred. Reason: ${reason}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TransferErc721Celo": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "contractAddress", "tokenId", "fromPrivateKey"]
      },
      "TransferErc721KMSCelo": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "contractAddress", "feeCurrency", "signatureId", "tokenId"]
      },
      "MintErc721Celo": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "url", "feeCurrency", "contractAddress", "fromPrivateKey", "tokenId"]
      },
      "MintErc721KMSCelo": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be created.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC721 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "url", "feeCurrency", "contractAddress", "signatureId", "tokenId"]
      },
      "MintErc20Celo": {
        "type": "object",
        "properties": {
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "amount", "feeCurrency", "contractAddress", "fromPrivateKey"]
      },
      "MintErc20KMSCelo": {
        "type": "object",
        "properties": {
          "amount": {
            "description": "Amount to be minted and transfered to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "amount", "feeCurrency", "contractAddress", "signatureId"]
      },
      "MintMultipleErc721Celo": {
        "type": "object",
        "properties": {
          "to": {
            "type": "array",
            "description": "Blockchain address to send ERC721 token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "type": "array",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "contractAddress", "url", "fromPrivateKey", "feeCurrency", "tokenId"]
      },
      "MintMultipleErc721KMSCelo": {
        "type": "object",
        "properties": {
          "to": {
            "type": "array",
            "description": "Blockchain address to send ERC721 token to.",
            "example": ["0x687422eEA2cB73B5d3e242bA5456b782919AFc85"],
            "items": { "maxLength": 42, "minLength": 42, "type": "string" }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": ["100000"],
            "items": { "type": "string", "maxLength": 32 }
          },
          "url": {
            "description": "Metadata of the token. See https://eips.ethereum.org/EIPS/eip-721#specification for more details.",
            "type": "array",
            "example": ["https://my_token_data.com"],
            "items": { "type": "string", "maxLength": 256 }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "contractAddress", "feeCurrency", "tokenId", "url", "signatureId"]
      },
      "BurnErc721Celo": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["contractAddress", "feeCurrency", "fromPrivateKey", "tokenId"]
      },
      "BurnErc721KMSCelo": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "example": "100000",
            "type": "string",
            "maxLength": 32
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["feeCurrency", "contractAddress", "tokenId", "signatureId"]
      },
      "BurnErc20Celo": {
        "type": "object",
        "properties": {
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["contractAddress", "feeCurrency", "fromPrivateKey", "amount"]
      },
      "BurnErc20KMSCelo": {
        "type": "object",
        "properties": {
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC721 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["feeCurrency", "contractAddress", "tokenId", "amount"]
      },
      "TransferCeloBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property. Only for ETH transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "type": "string",
            "description": "Currency of the transaction",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "amount": {
            "description": "Amount to be sent in Celoer.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "fromPrivateKey", "currency", "feeCurrency"]
      },
      "TransferCeloBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property. Only for ETH transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "currency": {
            "type": "string",
            "description": "Currency of the transaction",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          },
          "amount": {
            "description": "Amount to be sent in Celoer.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "feeCurrency", "currency", "amount", "signatureId"]
      },
      "CeloEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "CeloBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/CeloTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "CeloTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      },
      "DeployErc721Celo": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the ERC721 token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the ERC721 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Celo account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["name", "symbol", "feeCurrency", "fromPrivateKey"]
      },
      "DeployErc721CeloKMS": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the ERC721 token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the ERC721 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": { "type": "number", "minimum": 0 },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["name", "symbol", "feeCurrency", "signatureId"]
      },
      "DeployErc20Celo": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Celo blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Celo account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["name", "symbol", "address", "supply", "fromPrivateKey", "digits", "feeCurrency"]
      },
      "DeployErc20KMSCelo": {
        "type": "object",
        "properties": {
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Celo blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["name", "symbol", "address", "supply", "signatureId", "digits", "feeCurrency"]
      },
      "CallCeloReadSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallCeloSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName", "feeCurrency"]
      },
      "TransferErc20Celo": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "contractAddress", "digits", "feeCurrency", "fromPrivateKey", "amount"]
      },
      "TransferErc20CeloKMS": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Celo transaction. If not present, last known nonce will be used."
          },
          "feeCurrency": {
            "type": "string",
            "description": "Currency to pay for transaction gas",
            "enum": ["CELO", "CUSD", "CEUR"]
          }
        },
        "required": ["to", "contractAddress", "signatureId", "digits", "amount", "feeCurrency"]
      },
      "Error403CeloGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "celo.transaction.gas",
            "example": "celo.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403CeloTxBody": {
        "properties": {
          "errorCode": {
            "description": "celo.transaction.body",
            "example": "celo.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "EgldBlock": {
        "type": "object",
        "properties": {
          "nonce": { "description": "The block height.", "type": "number", "example": 5440076 },
          "round": { "description": "The round number.", "type": "number", "example": 186582 },
          "hash": {
            "description": "Hash of the block.",
            "type": "string",
            "example": "bd2de3618929b696807f6ef8a619f93d29d639aec9277f9c6f8569a8487141b1"
          },
          "prevBlockHash": {
            "description": "Hash of the previous block.",
            "type": "string",
            "example": "2a11aad21e933be58200839ff875f0ca7e955b8c483a0e117cb92409e5d2a5da"
          },
          "epoch": {
            "description": "An epoch is a sequence of consecutive rounds during which the configuration of the network does not change (currently aprox. 24 hrs in length).",
            "type": "number",
            "example": 18
          },
          "numTxs": {
            "description": "Number of transactions in current block.",
            "type": "number",
            "example": 8
          },
          "shardBlocks": {
            "description": "Array of shard blocks",
            "type": "array",
            "items": { "$ref": "#/components/schemas/EgldShardBlock" }
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/EgldTx" }
          }
        }
      },
      "EgldShardBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "description": "The block hash.",
            "type": "string",
            "example": "a6f2ac15a6b1bafdde9afff2297cef49c4c523c516f8ee12fed54be070e9512b"
          },
          "nonce": { "description": "The block height.", "type": "number", "example": 5440070 },
          "shard": { "description": "The shard number.", "type": "number", "example": 1 }
        }
      },
      "EgldTx": {
        "type": "object",
        "properties": {
          "type": { "type": "string", "description": "Type of transaction.", "example": null },
          "nonce": { "type": "number", "description": "Nonce of the transaction.", "example": 2 },
          "round": { "type": "number", "description": "The round number.", "example": 186580 },
          "epoch": {
            "type": "number",
            "description": "An epoch is a sequence of consecutive rounds during which the configuration of the network does not change (currently aprox. 24 hrs in length).",
            "example": 12
          },
          "value": {
            "type": "string",
            "description": "Transferred value.",
            "example": "1000000000000000000"
          },
          "receiver": {
            "type": "string",
            "description": "Address of the receiver.",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7"
          },
          "sender": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq1"
          },
          "gasPrice": {
            "type": "number",
            "description": "Gas price provided by the sender",
            "example": 1000000000
          },
          "gasLimit": { "type": "number", "description": "Gas provided by the sender", "example": 70000 },
          "data": {
            "type": "string",
            "description": "Data field in transaction.",
            "example": "Zm9yIHRlc3Rz"
          },
          "signature": {
            "type": "string",
            "description": "Signature of the transaction.",
            "example": "c6ab10b401f14b122caf9d2ef80d532b986aa82b589dac77d77929da27ae2382c6ab10b401f14b122caf9d2ef80d532b986aa82b589dac77d77929da27ae238"
          },
          "sourceShard": { "type": "number", "description": "Source shard.", "example": 2 },
          "destinationShard": { "type": "number", "description": "Destination shard.", "example": 1 },
          "blockNonce": {
            "type": "number",
            "description": "Nonce of block which contains current transaction.",
            "example": 186535
          },
          "blockHash": {
            "type": "string",
            "description": "Hash of block which contains current transaction.",
            "example": "bd2de3618929b696807f6ef8a619f93d29d639aec9277f9c6f8569a8487141b1"
          },
          "miniblockHash": {
            "type": "string",
            "description": "Miniblock hash.",
            "example": "7cb0a10cf9e9ec9ff719ffe99349db3feac3ec217b6de62f6cf7756647194bbf"
          },
          "timestamp": {
            "type": "number",
            "description": "The unix timestamp for when the block was collated.",
            "example": 1569600592
          },
          "status": { "type": "string", "description": "Status of the transaction.", "example": "Success" },
          "hyperblockNonce": {
            "type": "number",
            "description": "Nonce of the hyperblockwhere this transaction was in.",
            "example": 123321
          },
          "hyperblockHash": {
            "type": "string",
            "description": "Hash of the hyperblock where this transaction was in.",
            "example": "715224f1f7d8330e3837500d1f82431954e30db6149f3ee4644d0950576d8dfe"
          }
        }
      },
      "Error403EgldBroadcast": {
        "properties": {
          "errorCode": {
            "description": "egld.broadcast.failed",
            "example": "egld.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EgldTxHash": {
        "properties": {
          "errorCode": {
            "description": "egld.transaction.hash",
            "example": "egld.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403EgldTxSign": {
        "properties": {
          "errorCode": {
            "description": "egld.transaction.sign",
            "example": "egld.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TransferEgldBlockchain": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Account address of the sender",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7",
            "maxLength": 62,
            "minLength": 62,
            "type": "string"
          },
          "to": {
            "description": "Account address of the receiver or smart contract",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq6",
            "maxLength": 62,
            "minLength": 62,
            "type": "string"
          },
          "amount": { "type": "string", "description": "Value to be sent.", "example": "0" },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction. If transfer to a smart contract, then 500000 + an appropriate amount for the method call",
                "example": "500000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price.",
                "example": "1000000000",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "data": {
            "description": "Additinal data, that will be passed to blockchain transaction as data property.",
            "type": "string",
            "example": "Hello world"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "minLength": 64,
            "example": "0cd8e6217b4a218807b858ffb508483cdcdadbb7a21196727f764a510a692760",
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["fromPrivateKey", "from", "to", "amount"]
      },
      "TransferEgldBlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Account address of the sender",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq7",
            "maxLength": 62,
            "minLength": 62,
            "type": "string"
          },
          "to": {
            "description": "Account address of the receiver or smart contract",
            "example": "erd17k95m339aqzxzyvjjjfa3lka0yyeqgcsda50tw5z9g73ycfe2caq9e6jq6",
            "maxLength": 62,
            "minLength": 62,
            "type": "string"
          },
          "amount": { "type": "string", "description": "Value to be sent.", "example": "0" },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction.",
                "example": "500000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price.",
                "example": "1000000000",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "data": {
            "description": "Additinal data, that will be passed to blockchain transaction as data property.",
            "type": "string",
            "example": "Hello world"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["signatureId", "from", "to", "amount"]
      },
      "AlgoWallet": {
        "type": "object",
        "properties": {
          "address": {
            "maxLength": 58,
            "minLength": 58,
            "description": "address of Algorand account.",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "secret": {
            "maxLength": 103,
            "minLength": 103,
            "description": "secretKey can generate Mnemonic, similar to private Key.",
            "type": "string",
            "example": "NBYMCVEEDFYV3TPWVRE6APE7PKHUJD4XAKXCKNCLKGUXOC3LFNJGZQCJCRA53HB7ZAHF6NFJH2QIVQ5USQNWG35QCJLD4KZ5IWMB24Q"
          }
        }
      },
      "AlgoBlock": {
        "type": "object",
        "properties": {
          "genesisHash": {
            "description": "hash to which this block belongs",
            "type": "string",
            "example": "SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI="
          },
          "genesisId": {
            "description": "ID to which this block belongs",
            "type": "string",
            "example": "testnet-v1.0"
          },
          "previousBlockHash": {
            "description": "Previous block hash",
            "type": "string",
            "example": "JeLGQTbqnBsD3NXE8Bf1TpPFMFadEVVyHhkcD61ljAU="
          },
          "rewards": {
            "description": "rewards",
            "type": "object",
            "example": {
              "fee-sink": "A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE",
              "rewards-calculation-round": 17000000,
              "rewards-level": 27521,
              "rewards-pool": "7777777777777777777777777777777777777777777777777774MSJUVU",
              "rewards-rate": 0,
              "rewards-residue": 2020197303
            }
          },
          "round": {
            "description": "Current round on which this block was appended to the chain",
            "type": "number",
            "example": 16775567
          },
          "seed": {
            "description": "Sortition seed.",
            "type": "string",
            "example": "VPBpyrHyqbfqrHqJ3l39LXGN4qgEdNnE5kpJfk3vJtA="
          },
          "timestamp": {
            "description": "Block creation timestamp in seconds since eposh",
            "type": "number",
            "example": 1632167753
          },
          "txns": {
            "description": "Array of transactions",
            "type": "array",
            "items": { "$ref": "#/components/schemas/AlgoTx" }
          },
          "txn": {
            "description": "TransactionsRoot authenticates the set of transactions appearing in the block.",
            "type": "string",
            "example": "++MWW82yIvYQ0AEoPP0aDGGHGk/dSp5WHlbkf9SVU1U="
          },
          "txnc": {
            "description": "TxnCounter counts the number of transations committed in the ledger",
            "type": "number",
            "example": 27814470
          },
          "upgradeState": {
            "description": "upgrade state",
            "type": "object",
            "example": {
              "current-protocol": "https://github.com/algorandfoundation/specs/tree/abc54f79f9ad679d2d22f0fb9909fb005c16f8a1",
              "next-protocol-approvals": 0,
              "next-protocol-switch-on": 0,
              "next-protocol-vote-before": 0
            }
          },
          "upgradeVote": {
            "description": "upgrade vote",
            "type": "object",
            "example": { "upgrade-approve": false, "upgrade-delay": 0 }
          }
        }
      },
      "AlgoTx": {
        "type": "object",
        "properties": {
          "closeRewards": {
            "description": "rewards applied to close-remainder-to account.",
            "type": "number",
            "example": 0
          },
          "closingAmount": {
            "description": "closing amount for transaction.",
            "type": "number",
            "example": 0
          },
          "confirmedRound": {
            "description": "Round when the transaction was confirmed.",
            "type": "number",
            "example": 16775567
          },
          "fee": { "description": "Transaction fee", "type": "number", "example": 0.001 },
          "firstValid": {
            "description": "First valid round for this transaction.",
            "type": "number",
            "example": 16775565
          },
          "genesisHash": {
            "description": "Hash of genesis block",
            "type": "string",
            "example": "SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI="
          },
          "genesisId": { "description": "genesis block ID.", "type": "string", "example": "testnet-v1.0" },
          "id": {
            "description": "transaction ID",
            "type": "string",
            "example": "HNIQ76UTJYPOLZP5FWODYABBJPYPGJNEM2QEJSMDMQRWEKHEYJHQ"
          },
          "intraRoundOffset": {
            "description": "Offset into the round where this transaction was confirmed.",
            "type": "number",
            "example": 1
          },
          "lastValid": {
            "description": "Last valid round for this transaction.",
            "type": "number",
            "example": 16775571
          },
          "note": {
            "description": "Free form data",
            "type": "string",
            "example": "cGluZ3Bvbmf0Jyl21QrtLw=="
          },
          "paymentTransaction": { "description": "payment Transaction", "type": "object" },
          "receiverRewards": {
            "description": "rewards applied to receiver account.",
            "type": "number",
            "example": 0
          },
          "roundTime": {
            "description": "Time when the block this transaction is in was confirmed.",
            "type": "number",
            "example": 1632167753
          },
          "sender": {
            "description": "Sender's address",
            "type": "string",
            "example": "U6QEM4KM7KKGCLH4FELZBGJEVVSF556ELXHUOZC4ESPFS4O4V4VQXKQRXQ"
          },
          "senderRewards": {
            "description": "rewards applied to sender account.",
            "type": "number",
            "example": 0
          },
          "signature": { "description": "signature", "type": "object" },
          "txType": {
            "description": "indicates what type of transaction this is. Different types have differnet fields.",
            "type": "string",
            "example": "pay"
          }
        }
      },
      "AlgoTxsWithPagination": {
        "type": "object",
        "properties": {
          "nextToken": {
            "description": "Used for pagination, when making another request provide this token with the next parameter.",
            "type": "string",
            "example": "ywAAAAAAAAAAAAAA"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/AlgoTx" }
          }
        }
      },
      "TransferAlgorandBlockchain": {
        "type": "object",
        "properties": {
          "from": {
            "description": "The blockchain address of the sender",
            "type": "string",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4"
          },
          "to": {
            "description": "The blockchain address of the recipient",
            "type": "string",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y"
          },
          "fee": { "description": "The transaction fee in Algos", "type": "string", "example": "0.001" },
          "amount": { "description": "The amount to send in Algos", "type": "string", "example": "1" },
          "note": {
            "description": "The note for the recipient; must not contain spaces",
            "type": "string",
            "example": "Helloworld"
          },
          "fromPrivateKey": {
            "description": "Private key of sender address. Private key, or signature Id must be present.",
            "type": "string",
            "example": "72TCV5BRQPBMSAFPYO3CPWVDBYWNGAYNMTW5QHENOMQF7I6QLNMJWCJZ7A3V5YKD7QD6ZZPEHG2PV2ZVVEDDO6BCRGXWIL3DIUMSUCI"
          }
        },
        "required": ["from", "to", "amount", "fromPrivateKey", "fee"]
      },
      "ReceiveAlgorandAsset": {
        "type": "object",
        "properties": {
          "assetId": {
            "description": "AssetID of the asset you wanna enable for the sender.",
            "type": "number",
            "example": 116363571
          },
          "fromPrivateKey": {
            "description": "Private key of sender address. Private key, or signature Id must be present.",
            "type": "string",
            "example": "72TCV5BRQPBMSAFPYO3CPWVDBYWNGAYNMTW5QHENOMQF7I6QLNMJWCJZ7A3V5YKD7QD6ZZPEHG2PV2ZVVEDDO6BCRGXWIL3DIUMSUCI"
          }
        },
        "required": ["assetId", "fromPrivateKey"]
      },
      "ReceiveAlgorandAssetKMS": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Blockchain sender address.",
            "type": "string",
            "minLength": 58,
            "maxLength": 58,
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4"
          },
          "assetId": {
            "description": "AssetID of the asset you wanna enable for the sender.",
            "type": "number",
            "example": 98745612
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["assetId", "from", "signatureId"]
      },
      "AlgoTransactionHashKMS": {
        "type": "object",
        "properties": {
          "txId": {
            "description": "TX hash of transaction.",
            "example": "GTNOIDCIHZLESKNQPJXOXE476ODYDNNQBA3N2Q75MYQ4SI4XL5SA",
            "type": "string"
          },
          "assetIndex": {
            "description": "If transaction created new ASA asset, this value is the index of the asset on the network.",
            "example": 87751984,
            "type": "number"
          },
          "confirmed": {
            "example": false,
            "type": "boolean",
            "description": "If transaction was not confirmed within 5 rounds, result is false.",
            "default": false
          },
          "failed": {
            "description": "In case of the transaction was broadcast to the blockchain, but it was not possible to complete Tatum KMS signature, reponse is marked as failed and must be marked manually.",
            "example": false,
            "type": "boolean"
          }
        },
        "required": ["txId"]
      },
      "TransferAlgorandBlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "description": "The blockchain address of the sender",
            "type": "string",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4"
          },
          "to": {
            "description": "The blockchain address of the recipient",
            "type": "string",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y"
          },
          "fee": { "description": "The transaction fee in Algos", "type": "string", "example": "0.001" },
          "amount": { "description": "The amount to send in Algos", "type": "string", "example": "1" },
          "note": {
            "description": "The note for the recipient; must not contain spaces",
            "type": "string",
            "example": "Helloworld"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["from", "to", "amount", "signatureId", "fee"]
      },
      "TransferTronBlockchain": {
        "type": "object",
        "properties": {
          "fromPrivateKey": {
            "type": "string",
            "minLength": 64,
            "maxLength": 64,
            "description": "Private key of the address, from which the TRX will be sent.",
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701"
          },
          "to": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "amount": {
            "description": "Amount to be sent in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromPrivateKey", "to", "amount"]
      },
      "TransferTronBlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "minimum": 36,
            "maximum": 36,
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "to": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "amount": {
            "description": "Amount to be sent in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          }
        },
        "required": ["from", "signatureId", "to", "amount", "index"]
      },
      "TransferTronTrc10Blockchain": {
        "type": "object",
        "properties": {
          "fromPrivateKey": {
            "type": "string",
            "minLength": 64,
            "maxLength": 64,
            "description": "Private key of the address, from which the TRX will be sent.",
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701"
          },
          "to": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "tokenId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "ID of the token to transfer.",
            "example": "1000538"
          },
          "amount": {
            "description": "Amount to be sent in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromPrivateKey", "tokenId", "to", "amount"]
      },
      "TransferTronTrc10BlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "minimum": 36,
            "maximum": 36,
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "to": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "tokenId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "ID of the token to transfer.",
            "example": "1000538"
          },
          "amount": {
            "description": "Amount to be sent in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["from", "signatureId", "index", "tokenId", "to", "amount"]
      },
      "TransferTronTrc20Blockchain": {
        "type": "object",
        "properties": {
          "fromPrivateKey": {
            "type": "string",
            "minLength": 64,
            "maxLength": 64,
            "description": "Private key of the address, from which the TRX will be sent.",
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701"
          },
          "to": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "tokenAddress": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Address of the TRC20 token to transfer.",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          },
          "amount": {
            "description": "Amount to be sent in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromPrivateKey", "tokenAddress", "to", "amount", "feeLimit"]
      },
      "TransferTronTrc20BlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "minimum": 36,
            "maximum": 36,
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "to": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "tokenAddress": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Address of the TRC20 token to transfer.",
            "example": "TVAEYCmc15awaDRAjUZ1kvcHwQQaoPw2CW"
          },
          "feeLimit": {
            "type": "number",
            "minimum": 0,
            "description": "Fee in TRX to be paid.",
            "example": 0.01
          },
          "amount": {
            "description": "Amount to be sent in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["from", "signatureId", "index", "tokenAddress", "to", "amount", "feeLimit"]
      },
      "CreateTronTrc20Blockchain": {
        "type": "object",
        "properties": {
          "fromPrivateKey": {
            "type": "string",
            "minLength": 64,
            "maxLength": 64,
            "description": "Private key of the address, from which the TRX will be sent.",
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701"
          },
          "recipient": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of created TRC20 tokens.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Name of the token.",
            "example": "My token"
          },
          "symbol": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Symbol of the token.",
            "example": "SYM"
          },
          "totalSupply": {
            "type": "number",
            "minimum": 0,
            "description": "Total supply of the tokens.",
            "example": 100000
          },
          "decimals": {
            "type": "number",
            "minimum": 0,
            "maximum": 30,
            "description": "Number of decimal places of the token.",
            "example": 10
          }
        },
        "required": ["fromPrivateKey", "name", "recipient", "symbol", "totalSupply", "decimals"]
      },
      "CreateTronTrc20BlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "minimum": 36,
            "maximum": 36,
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "recipient": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of created TRC20 tokens.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Name of the token.",
            "example": "My token"
          },
          "symbol": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Symbol of the token.",
            "example": "SYM"
          },
          "totalSupply": {
            "type": "number",
            "minimum": 0,
            "description": "Total supply of the tokens.",
            "example": 100000
          },
          "decimals": {
            "type": "number",
            "minimum": 0,
            "maximum": 30,
            "description": "Number of decimal places of the token.",
            "example": 10
          }
        },
        "required": ["from", "signatureId", "index", "name", "recipient", "symbol", "totalSupply", "decimals"]
      },
      "CreateTronTrc10Blockchain": {
        "type": "object",
        "properties": {
          "fromPrivateKey": {
            "type": "string",
            "minLength": 64,
            "maxLength": 64,
            "description": "Private key of the address, from which the TRX will be sent.",
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701"
          },
          "recipient": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of created TRC 10 tokens.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Name of the token.",
            "example": "My token"
          },
          "abbreviation": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Abbreviation of the token.",
            "example": "SYM"
          },
          "description": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Description of the token.",
            "example": "My short description"
          },
          "url": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "URL of the token.",
            "example": "https://mytoken.com"
          },
          "totalSupply": {
            "type": "number",
            "minimum": 0,
            "description": "Total supply of the tokens.",
            "example": 100000
          },
          "decimals": {
            "type": "number",
            "minimum": 0,
            "maximum": 5,
            "description": "Number of decimal places of the token.",
            "example": 10
          }
        },
        "required": [
          "fromPrivateKey",
          "recipient",
          "name",
          "abbreviation",
          "description",
          "url",
          "totalSupply",
          "decimals"
        ]
      },
      "CreateTronTrc10BlockchainKMS": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "minimum": 36,
            "maximum": 36,
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "recipient": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of created TRC 10 tokens.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Name of the token.",
            "example": "My token"
          },
          "abbreviation": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Abbreviation of the token.",
            "example": "SYM"
          },
          "description": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Description of the token.",
            "example": "My short description"
          },
          "url": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "URL of the token.",
            "example": "https://mytoken.com"
          },
          "totalSupply": {
            "type": "number",
            "minimum": 0,
            "description": "Total supply of the tokens.",
            "example": 100000
          },
          "decimals": {
            "type": "number",
            "minimum": 0,
            "maximum": 5,
            "description": "Number of decimal places of the token.",
            "example": 10
          }
        },
        "required": [
          "from",
          "signatureId",
          "index",
          "recipient",
          "name",
          "abbreviation",
          "description",
          "url",
          "totalSupply",
          "decimals"
        ]
      },
      "TronTrc10Detail": {
        "type": "object",
        "properties": {
          "ownerAddress": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "The address of the TRC-10 token's owner in the hexadecimal format",
            "example": "41d2803f9c22aa429d71554c9427e97ffedcec17c7"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "The name of the TRC-10 token",
            "example": "My token"
          },
          "abbr": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "The abbreviated name of the TRC-10 token",
            "example": "SYM"
          },
          "description": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "The description of the TRC-10 token",
            "example": "My short description"
          },
          "url": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "The URL of the TRC-10 token",
            "example": "https://mytoken.com"
          },
          "totalSupply": {
            "type": "number",
            "minimum": 0,
            "description": "The total supply of tokens in the TRC-10 token",
            "example": 100000
          },
          "precision": {
            "type": "number",
            "minimum": 0,
            "maximum": 5,
            "description": "The number of decimal places",
            "example": 10
          },
          "id": { "type": "number", "description": "The ID of the TRC-10 token", "example": 1000540 }
        }
      },
      "FreezeTron": {
        "type": "object",
        "properties": {
          "fromPrivateKey": {
            "type": "string",
            "minLength": 64,
            "maxLength": 64,
            "description": "Private key of the address, from which the TRX will be sent.",
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701"
          },
          "receiver": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of frozen BANDWIDTH or ENERGY.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "duration": {
            "type": "number",
            "description": "Duration of frozen funds, in days.",
            "example": 3,
            "minimum": 3
          },
          "resource": {
            "type": "string",
            "description": "Resource to obtain, BANDWIDTH or ENERGY.",
            "example": "ENERGY",
            "enum": ["BANDWIDTH", "ENERGY"]
          },
          "amount": {
            "description": "Amount to be frozen in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["fromPrivateKey", "receiver", "resource", "duration", "amount"]
      },
      "FreezeTronKMS": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Sender address of TRON account in Base58 format.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "signatureId": {
            "type": "string",
            "minimum": 36,
            "maximum": 36,
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "receiver": {
            "type": "string",
            "minLength": 34,
            "maxLength": 34,
            "description": "Recipient address of frozen BANDWIDTH or ENERGY.",
            "example": "TYMwiDu22V6XG3yk6W9cTVBz48okKLRczh"
          },
          "duration": {
            "type": "number",
            "description": "Duration of frozen funds, in days.",
            "example": 3,
            "minimum": 3
          },
          "resource": {
            "type": "string",
            "description": "Resource to obtain, BANDWIDTH or ENERGY.",
            "example": "ENERGY",
            "enum": ["BANDWIDTH", "ENERGY"]
          },
          "amount": {
            "description": "Amount to be frozen in TRX.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["from", "signatureId", "index", "receiver", "resource", "duration", "amount"]
      },
      "Error403Tron": {
        "properties": {
          "errorCode": { "description": "tron.failed", "example": "tron.failed", "type": "string" },
          "message": {
            "description": "Unable to communicate to blockchain. ${error}",
            "example": "Unable to communicate to blockchain. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TronWallet": {
        "type": "object",
        "required": ["mnemonic", "xpub"],
        "properties": {
          "mnemonic": {
            "description": "Generated mnemonic for wallet.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Generated Extended public key for wallet with derivation path according to BIP44. This key can be used to generate addresses.",
            "example": "0244b3f40c6e570ae0032f6d7be87737a6c4e5314a4a1a82e22d0460a0d0cd794936c61f0c80dc74ace4cd04690d4eeb1aa6555883be006e1748306faa7ed3a26a",
            "type": "string"
          }
        }
      },
      "TronBlock": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Block hash",
            "example": "000000000195a8cfe2ea4ca60ce921b30e95980a96c6bb1da4a35aa03da9c5a8"
          },
          "blockNumber": { "type": "number", "description": "Block number.", "example": 26585295 },
          "timestamp": {
            "type": "number",
            "description": "Time of the block in UTC millis.",
            "example": 1610134209000
          },
          "parentHash": {
            "type": "string",
            "description": "Hash of the parent block.",
            "example": "000000000195a8ce6003aa8b6443c52734b80aefdcd079bf40e7f165b046370e"
          },
          "witnessAddress": {
            "type": "string",
            "description": "Witness address.",
            "example": "4118e2e1c6cdf4b74b7c1eb84682e503213a174955"
          },
          "witnessSignature": {
            "type": "string",
            "description": "Witness signature.",
            "example": "e20cb7a1f01d279ebe9c20baa0d747bea160042639ba0be63460cbb21ae63f072520e7766cb7aa1bd4e74bebbdea64be431ecf52c2aa2123ca0b1d7495bd581d00"
          },
          "transactions": {
            "type": "array",
            "description": "Transactions that occurs in this block.",
            "items": { "$ref": "#/components/schemas/TronTx" }
          }
        }
      },
      "TronBroadcast": {
        "type": "object",
        "required": ["txData"],
        "properties": {
          "txData": {
            "type": "string",
            "description": "Raw signed transaction to be published to network.",
            "minLength": 1,
            "maxLength": 50000,
            "example": "{\"raw_data\": \"{\\\"contract\\\":[{\\\"parameter\\\":{\\\"value\\\":{\\\"amount\\\":1000,\\\"owner_address\\\":\\\"41608f8da72479edc7dd921e4c30bb7e7cddbe722e\\\",\\\"to_address\\\":\\\"41e9d79cc47518930bc322d9bf7cddd260a0260a8d\\\"},\\\"type_url\\\":\\\"type.googleapis.com/protocol.TransferContract\\\"},\\\"type\\\":\\\"TransferContract\\\"}],\\\"ref_block_bytes\\\":\\\"5e4b\\\",\\\"ref_block_hash\\\":\\\"47c9dc89341b300d\\\",\\\"expiration\\\":1591089627000,\\\"timestamp\\\":1591089567635}\",\"raw_data_hex\": \"0a025e4b220847c9dc89341b300d40f8fed3a2a72e5a66080112620a2d747970652e676f6f676c65617069732e636f6d2f70726f746f636f6c2e5472616e73666572436f6e747261637412310a1541608f8da72479edc7dd921e4c30bb7e7cddbe722e121541e9d79cc47518930bc322d9bf7cddd260a0260a8d18e8077093afd0a2a72e\"}"
          }
        }
      },
      "TronTx": {
        "type": "object",
        "required": ["txID", "signature", "blockNumber", "ret", "rawData"],
        "properties": {
          "ret": {
            "type": "array",
            "description": "Result of the smart contract invocation.",
            "items": {
              "properties": {
                "contractRet": {
                  "type": "string",
                  "description": "Returns the value of the smart contract invocation.",
                  "example": "SUCCESS"
                }
              }
            },
            "required": ["contractRet"]
          },
          "signature": {
            "type": "array",
            "description": "List of signatures of the transaction.",
            "items": {
              "type": "string",
              "example": "91fa5d81f9578970d21fdcde4ebb849674d437b62774f34e8d9e4cb50960c0031362cbcb649553b1f5f9daf19495ae46e517d4401172b5e53bb06bfe6896e2e300"
            }
          },
          "blockNumber": {
            "type": "number",
            "description": "The block in which the transaction was included.",
            "example": 11223344
          },
          "txID": {
            "type": "string",
            "description": "Transaction ID.",
            "example": "24dd2f121a24516f22df78adf1ccc32119e3edb7760297f76a925b879f2baa98"
          },
          "netUsage": { "type": "number", "description": "Usage of the network.", "example": 0 },
          "rawData": {
            "type": "object",
            "description": "Raw data of the transaction.",
            "required": ["expiration", "timestamp", "contract"],
            "properties": {
              "contract": {
                "type": "array",
                "description": "Smart contract invocations details.",
                "items": {
                  "type": "object",
                  "properties": {
                    "parameter": {
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "object",
                          "properties": {
                            "amount": {
                              "type": "number",
                              "description": "The amount transferred within the transaction.",
                              "example": 1000000
                            },
                            "owner_address": {
                              "type": "string",
                              "example": "418632237fd33f62c549ee044dd3da779aba947dcc",
                              "description": "Address of the sender."
                            },
                            "to_address": {
                              "type": "string",
                              "description": "Address of the recipient.",
                              "example": "41a614f803b6fd780986a42c78ec9c7f77e6ded13c"
                            },
                            "ownerAddressBase58": {
                              "type": "string",
                              "example": "TNCmcTdyrYKMtmE1KU2itzeCX76jGm5Not",
                              "description": "Address of the sender in Base58 encoding."
                            },
                            "toAddressBase58": {
                              "type": "string",
                              "example": "TRwS7apsNdRGzMBfhB2hVC4RhqfubUYZ8P",
                              "description": "Address of the recipient in Base58 encoding."
                            }
                          }
                        },
                        "type_url": {
                          "type": "string",
                          "example": "type.googleapis.com/protocol.TriggerSmartContract",
                          "description": "Type of the smart contract event."
                        }
                      }
                    },
                    "type": {
                      "example": "TriggerSmartContract",
                      "type": "string",
                      "description": "Type of the Smart contract."
                    }
                  }
                }
              },
              "ref_block_bytes": {
                "type": "number",
                "description": "The height of the transaction reference block.",
                "example": 4946
              },
              "ref_block_hash": {
                "type": "number",
                "description": "The hash of the transaction reference block.",
                "example": "6d0c1a0af5a52f17"
              },
              "expiration": {
                "description": "Expiration of the transaction.",
                "type": "number",
                "example": 1610067216000
              },
              "timestamp": {
                "description": "Time of the transaction.",
                "type": "number",
                "example": 1609980816000
              }
            }
          }
        }
      },
      "TronInternalTx": {
        "type": "object",
        "required": ["internal_tx_id", "tx_id", "to_address", "from_address"],
        "properties": {
          "tx_id": {
            "type": "string",
            "description": "Transaction ID.",
            "example": "24dd2f121a24516f22df78adf1ccc32119e3edb7760297f76a925b879f2baa98"
          },
          "internal_tx_id": {
            "type": "string",
            "description": "Internal TX ID.",
            "example": "e1543ab5ac85e8fbf2397f30f19dc5b7a32abd508a57ff0c13642c9963d9f312"
          },
          "to_address": {
            "type": "string",
            "description": "Recipient address.",
            "example": "41a614f803b6fd780986a42c78ec9c7f77e6ded13c"
          },
          "from_address": {
            "type": "string",
            "description": "Sender address.",
            "example": "41a2726afbecbd8e936000ed684cef5e2f5cf43008"
          }
        }
      },
      "TronTx20": {
        "type": "object",
        "required": ["txID", "to", "tokenInfo", "type", "value", "from"],
        "properties": {
          "txID": {
            "type": "string",
            "description": "Transaction ID.",
            "example": "24dd2f121a24516f22df78adf1ccc32119e3edb7760297f76a925b879f2baa98"
          },
          "tokenInfo": {
            "type": "object",
            "required": ["symbol", "decimals", "address", "name"],
            "properties": {
              "symbol": { "type": "string", "example": "USDT" },
              "address": { "type": "string", "example": "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t" },
              "decimals": { "type": "number", "example": 6 },
              "name": { "type": "string", "example": "Tether USD" }
            }
          },
          "from": { "type": "string", "example": "TPn72oEg7WPaffgNBf62vGx8G1s4chx2fp" },
          "to": { "type": "string", "example": "TJyhbP1bQfo8tLPxEVjaka9gh2qkN7MvD3" },
          "type": { "type": "string", "example": "Transfer" },
          "value": { "type": "string", "example": "1800" }
        }
      },
      "TronAccount": {
        "type": "object",
        "required": ["address", "freeNetUsage", "balance", "bandwidth", "trc10", "trc20", "createTime"],
        "properties": {
          "address": {
            "type": "string",
            "description": "Account address",
            "example": "TGDqQAP5bduoPKVgdbk7fGyW4DwEt3RRn8"
          },
          "balance": {
            "type": "number",
            "description": "Balance of the TRX, in SUN. SUN is 1/1000000 TRX.",
            "example": 2342342
          },
          "trc10": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Balance of the TRC10 assets.",
              "properties": {
                "key": {
                  "type": "string",
                  "description": "Name of the TRC10 asset.",
                  "example": "TEST_TRC_10"
                },
                "value": { "type": "number", "description": "Balance of the TRC10 asset.", "example": 123 }
              },
              "required": ["key", "value"]
            }
          },
          "trc20": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Balance of the TRC20 assets. It is structured as key value array, where key is the address of the TRC20 and value is the balance.",
              "example": {
                "TRkuKAxmWZ4G74MvZnFpoosQZsfvtNpmwH": "30958",
                "TVKXY8DJ9aVTcg3wwVrRRs2FbTUwi4UZWR": "70000"
              }
            }
          },
          "createTime": {
            "type": "number",
            "description": "Date of creation of the account in UTC millis.",
            "example": 1602848895000
          },
          "assetIssuedId": {
            "type": "string",
            "description": "ID of the issued TRC10 token, if any.",
            "example": "1003475"
          },
          "assetIssuedName": {
            "type": "number",
            "description": "Balance of the issued TRC10 token, if any.",
            "example": 100
          },
          "freeNetUsage": { "type": "number", "description": "Free usage of the network.", "example": 1000 },
          "freeNetLimit": {
            "type": "number",
            "description": "Free usage limit of the network.",
            "example": 1500
          },
          "netUsage": { "type": "number", "description": "Extra usage of the network.", "example": 5000 },
          "netLimit": {
            "type": "number",
            "description": "Extra usage limit of the network.",
            "example": 5000
          },
          "bandwidth": {
            "type": "number",
            "description": "Remaining usage of the network, equal to freeNetLimit - freeNetUsed + netLimit - netUsed.",
            "example": 1500
          }
        }
      },
      "KlaytnBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/KlaytnTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "KlaytnTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "type": {
            "description": "Type of Klaytn Transaction",
            "type": "string",
            "example": "TxTypeLegacyTransaction"
          },
          "typeInt": { "description": "Type of Klaytn Transaction", "type": "number", "example": 0 },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in peb.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in peb.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "blockNumber": {
                  "type": "number",
                  "description": "Block number where this transaction was in.",
                  "example": 6470854
                },
                "blockHash": {
                  "description": "Hash of the block.",
                  "type": "string",
                  "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      },
      "Error403KlaytnBroadcast": {
        "properties": {
          "errorCode": {
            "description": "klaytn.broadcast.failed",
            "example": "klaytn.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnKlay20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such ERC20 currency ${name}.",
            "example": "No such ERC20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnKlay20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "ERC20 address was already set.",
            "example": "ERC20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnKlay20Unsupported": {
        "properties": {
          "errorCode": {
            "description": "klaytn.bep20.unsupported",
            "example": "klaytn.bep20.unsupported",
            "type": "string"
          },
          "message": {
            "description": "Unsupported ETH ERC20 blockchain.",
            "example": "Unsupported ETH ERC20 blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnTxHash": {
        "properties": {
          "errorCode": {
            "description": "klaytn.transaction.hash",
            "example": "klaytn.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnTxSign": {
        "properties": {
          "errorCode": {
            "description": "klaytn.transaction.sign",
            "example": "klaytn.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnErc20TxSign": {
        "properties": {
          "errorCode": {
            "description": "klaytn.bep20.sign",
            "example": "klaytn.bep20.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "klaytn.transaction.gas",
            "example": "klaytn.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnTxBody": {
        "properties": {
          "errorCode": {
            "description": "klaytn.transaction.body",
            "example": "klaytn.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnScBody": {
        "properties": {
          "errorCode": {
            "description": "klaytn.sc.invalid",
            "example": "klaytn.sc.invalid",
            "type": "string"
          },
          "message": {
            "description": "Invalid parameters for smart contract invocation.",
            "example": "Invalid parameters for smart contract invocation.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KlaytnGasPrice": {
        "properties": {
          "errorCode": { "description": "gas.price.failed", "example": "gas.price.failed", "type": "string" },
          "message": {
            "description": "Unable to obtain current GAS price.",
            "example": "Unable to obtain current GAS price.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "TransferKlay20Blockchain": {
        "type": "object",
        "properties": {
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "Blockchain address to send ERC20 token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points that ERC20 token has.",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Klaytn transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gpeb.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["to", "contractAddress", "digits", "fromPrivateKey", "amount"]
      },
      "CallKlaytnSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Klaytn transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gpeb.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallKlaytnSmartContractReadMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallKlaytnSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Klaytn transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gpeb.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferKlaytnBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for KLAY transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Klaytn transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Klaytn Blockchain Account.",
            "enum": ["KLAY"],
            "example": "KLAY",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gpeb.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "fromPrivateKey"]
      },
      "KlaytnEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in KLAY.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "TransferKlaytnBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for KLAY transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Klaytn transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Klaytn Blockchain Account.",
            "enum": ["KLAY"],
            "example": "KLAY",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gpeb.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "signatureId"]
      },
      "OneBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/OneTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "OneTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "blockNumber": {
                  "type": "number",
                  "description": "Block number where this transaction was in.",
                  "example": 6470854
                },
                "blockHash": {
                  "description": "Hash of the block.",
                  "type": "string",
                  "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      },
      "Error403OneBroadcast": {
        "properties": {
          "errorCode": {
            "description": "bsc.broadcast.failed",
            "example": "bsc.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneBep20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such HRM20 currency ${name}.",
            "example": "No such HRM20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneBep20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "HRM20 address was already set.",
            "example": "HRM20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneBep20Unsupported": {
        "properties": {
          "errorCode": {
            "description": "bsc.bep20.unsupported",
            "example": "bsc.bep20.unsupported",
            "type": "string"
          },
          "message": {
            "description": "Unsupported ETH HRM20 blockchain.",
            "example": "Unsupported ETH HRM20 blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneTxHash": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.hash",
            "example": "bsc.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneTxSign": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.sign",
            "example": "bsc.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneErc20TxSign": {
        "properties": {
          "errorCode": { "description": "bsc.bep20.sign", "example": "bsc.bep20.sign", "type": "string" },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.gas",
            "example": "bsc.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneTxBody": {
        "properties": {
          "errorCode": {
            "description": "bsc.transaction.body",
            "example": "bsc.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneScBody": {
        "properties": {
          "errorCode": { "description": "bsc.sc.invalid", "example": "bsc.sc.invalid", "type": "string" },
          "message": {
            "description": "Invalid parameters for smart contract invocation.",
            "example": "Invalid parameters for smart contract invocation.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403OneGasPrice": {
        "properties": {
          "errorCode": { "description": "gas.price.failed", "example": "gas.price.failed", "type": "string" },
          "message": {
            "description": "Unable to obtain current GAS price.",
            "example": "Unable to obtain current GAS price.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "CallOneSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to ONE transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallOneReadSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallOneSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to ONE transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferOneBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient."
          },
          "currency": {
            "type": "string",
            "description": "Currency of the transfer.",
            "example": "ONE",
            "enum": ["ONE"]
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to ONE transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in One.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "fromPrivateKey"]
      },
      "OneEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 66,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 66,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in One.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "TransferOneBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additinal data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient."
          },
          "currency": {
            "type": "string",
            "description": "Currency of the transfer.",
            "example": "ONE",
            "enum": ["ONE"]
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to ONE transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in One.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "signatureId"]
      },
      "XdcBlock": {
        "type": "object",
        "properties": {
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "receiptsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/XdcTx" }
          },
          "uncles": {
            "description": "Array of uncle hashes.",
            "type": "array",
            "items": { "type": "string" },
            "example": ["0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"]
          }
        }
      },
      "XdcTx": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "blockNumber": {
                  "type": "number",
                  "description": "Block number where this transaction was in.",
                  "example": 6470854
                },
                "blockHash": {
                  "description": "Hash of the block.",
                  "type": "string",
                  "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          },
          "logsBloom": {
            "type": "string",
            "format": "DATA, 256 Bytes",
            "description": "Bloom filter for light clients to quickly retrieve related logs.",
            "example": null
          },
          "root": {
            "type": "string",
            "description": "32 bytes of post-transaction stateroot (pre Byzantium)",
            "example": null
          }
        }
      },
      "Error403XdcBroadcast": {
        "properties": {
          "errorCode": {
            "description": "xdc.broadcast.failed",
            "example": "xdc.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XdcErc20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "ERC20 address was already set.",
            "example": "ERC20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XdcMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XdcTxHash": {
        "properties": {
          "errorCode": {
            "description": "xdc.transaction.hash",
            "example": "xdc.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XdcTxSign": {
        "properties": {
          "errorCode": {
            "description": "xdc.transaction.sign",
            "example": "xdc.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XdcErc20TxSign": {
        "properties": {
          "errorCode": { "description": "xdc.erc20.sign", "example": "xdc.erc20.sign", "type": "string" },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403XdcGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "xdc.transaction.gas",
            "example": "xdc.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "CallXdcSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallXdcReadSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallXdcSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferXdcBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for XDC transactions.",
            "example": "My note to recipient."
          },
          "currency": {
            "type": "string",
            "description": "Currency of the transfer.",
            "example": "XDC",
            "enum": ["XDC"]
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 43,
            "minLength": 42,
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "currency", "amount", "fromPrivateKey"]
      },
      "XdcEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 43,
            "example": "xdcfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 43,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in XDC.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "TransferXdcBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for XDC transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to XDC transaction. If not present, last known nonce will be used."
          },
          "currency": {
            "type": "string",
            "description": "Currency of the transfer.",
            "example": "XDC",
            "enum": ["XDC"]
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "xdc687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 43,
            "minLength": 42,
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in XDC.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "signatureId", "currency"]
      },
      "KcsBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": { "description": "The size of this block in bytes.", "type": "number", "example": 15296 },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": { "$ref": "#/components/schemas/KcsTx" }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "KcsTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": { "type": "number", "description": "Gas provided by the sender.", "example": 21000 },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": { "type": "string", "description": "The data containing non-indexed log parameter." },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "blockNumber": {
                  "type": "number",
                  "description": "Block number where this transaction was in.",
                  "example": 6470854
                },
                "blockHash": {
                  "description": "Hash of the block.",
                  "type": "string",
                  "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      },
      "Error403KcsBroadcast": {
        "properties": {
          "errorCode": {
            "description": "kcs.broadcast.failed",
            "example": "kcs.broadcast.failed",
            "type": "string"
          },
          "message": {
            "description": "Unable to broadcast transaction due to ${error}.",
            "example": "Unable to broadcast transaction due to ${error}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsBep20NotFound": {
        "properties": {
          "errorCode": {
            "description": "erc20.token.notFound",
            "example": "erc20.token.notFound",
            "type": "string"
          },
          "message": {
            "description": "No such ERC20 currency ${name}.",
            "example": "No such ERC20 currency ${name}.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsBep20Set": {
        "properties": {
          "errorCode": {
            "description": "erc20.address.set",
            "example": "erc20.address.set",
            "type": "string"
          },
          "message": {
            "description": "ERC20 address was already set.",
            "example": "ERC20 address was already set.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsMnemonicPrivateKey": {
        "properties": {
          "errorCode": {
            "description": "private.mnemonic.missing",
            "example": "private.mnemonic.missing",
            "type": "string"
          },
          "message": {
            "description": "Either mnemonic and index or private key must be present.",
            "example": "Either mnemonic and index or private key must be present.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsBep20Unsupported": {
        "properties": {
          "errorCode": {
            "description": "kcs.bep20.unsupported",
            "example": "kcs.bep20.unsupported",
            "type": "string"
          },
          "message": {
            "description": "Unsupported ETH ERC20 blockchain.",
            "example": "Unsupported ETH ERC20 blockchain.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsTxHash": {
        "properties": {
          "errorCode": {
            "description": "kcs.transaction.hash",
            "example": "kcs.transaction.hash",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate transaction hash. ${error}",
            "example": "Unable to calculate transaction hash. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsTxSign": {
        "properties": {
          "errorCode": {
            "description": "kcs.transaction.sign",
            "example": "kcs.transaction.sign",
            "type": "string"
          },
          "message": {
            "description": "Unable to sign transaction. ${error}",
            "example": "Unable to sign transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsErc20TxSign": {
        "properties": {
          "errorCode": { "description": "kcs.bep20.sign", "example": "kcs.bep20.sign", "type": "string" },
          "message": {
            "description": "Unable to sign transaction for contract creation. ${error}",
            "example": "Unable to sign transaction for contract creation. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsGasCalculation": {
        "properties": {
          "errorCode": {
            "description": "kcs.transaction.gas",
            "example": "kcs.transaction.gas",
            "type": "string"
          },
          "message": {
            "description": "Unable to calculate gas limit for transaction. ${error}",
            "example": "Unable to calculate gas limit for transaction. ${error}",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsTxBody": {
        "properties": {
          "errorCode": {
            "description": "kcs.transaction.body",
            "example": "kcs.transaction.body",
            "type": "string"
          },
          "message": {
            "description": "Either currency, or tokenAddress must be defined.",
            "example": "Either currency, or tokenAddress must be defined.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsScBody": {
        "properties": {
          "errorCode": { "description": "kcs.sc.invalid", "example": "kcs.sc.invalid", "type": "string" },
          "message": {
            "description": "Invalid parameters for smart contract invocation.",
            "example": "Invalid parameters for smart contract invocation.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "Error403KcsGasPrice": {
        "properties": {
          "errorCode": { "description": "gas.price.failed", "example": "gas.price.failed", "type": "string" },
          "message": {
            "description": "Unable to obtain current GAS price.",
            "example": "Unable to obtain current GAS price.",
            "type": "string"
          },
          "statusCode": { "description": "403", "example": 403, "type": "number" }
        },
        "required": ["errorCode", "message", "statusCode"],
        "type": "object"
      },
      "CallKcsSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "fromPrivateKey", "methodName"]
      },
      "CallKcsSmartContractReadMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string", "description": "Parameters of the method to be invoked" }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "methodName"]
      },
      "CallKcsSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": { "type": "object", "description": "ABI of the method to invoke." },
          "params": {
            "type": "array",
            "example": ["0x632"],
            "items": { "type": "string" },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "pattern": "^[+]?\\d+$",
                "example": "40000"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "pattern": "^[+]?\\d+$",
                "example": "20"
              }
            }
          }
        },
        "required": ["contractAddress", "params", "methodABI", "signatureId", "methodName"]
      },
      "TransferKcsBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for KCS transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Kcs Blockchain Account. ERC20 tokens USDC and USDT are available only for mainnet use.",
            "enum": ["KCS", "USDC_KCS", "USDT_KCS"],
            "example": "KCS",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "fromPrivateKey"]
      },
      "KcsEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in KCS.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property.",
            "example": "My note to recipient.",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": ["to", "amount", "from"]
      },
      "TransferKcsBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data, that can be passed to blockchain transaction as data property. Only for KCS transactions.",
            "example": "My note to recipient."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Kcs transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Kcs Blockchain Account. ERC20 tokens BETH, BBTC, BADA, WMATIC, BDOT, BXRP, BLTC, BBCH, KCS are available only for mainnet use.",
            "enum": ["BETH", "BBTC", "BADA", "WMATIC", "BDOT", "BXRP", "BLTC", "BBCH", "MATIC", "KCS"],
            "example": "KCS",
            "type": "string"
          },
          "fee": {
            "description": "Custom defined fee. If not present, it will be calculated automatically.",
            "type": "object",
            "required": ["gasLimit", "gasPrice"],
            "properties": {
              "gasLimit": {
                "type": "string",
                "description": "Gas limit for transaction in gas price.",
                "example": "40000",
                "pattern": "^[+]?\\d+$"
              },
              "gasPrice": {
                "type": "string",
                "description": "Gas price in Gwei.",
                "example": "20",
                "pattern": "^[+]?\\d+$"
              }
            }
          },
          "amount": {
            "description": "Amount to be sent in Ether.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": ["to", "amount", "currency", "signatureId"]
      }
    },
    "securitySchemes": {
      "X-API-Key": {
        "type": "apiKey",
        "name": "x-api-key",
        "in": "header",
        "description": "The **API key** represents your [pricing plan](https://tatum.io/pricing) and defines how many API calls \nyou can make per second and what the total number of API calls per month is available for you.\n\nOne API key must be used by only one person.\n\nChoose one of the following authentication methods:\n\n* **Provide the API key in each API call.**\n\n  To obtain the API key, [create a Tatum account](https://dashboard.tatum.io/sign-up). Once you are logged in,\n  you are automatically assigned the Free plan.\n\n  With the Free plan:\n  * You get two API keys, one tied to the testnet of a blockchain and the other to the mainnet.\n  * You can make up to five API calls per second.\n  * The number of API calls per month is not limited.\n\n  When making an API call, provide the appropriate API key (testnet or mainnet) as either an HTTP header\n  or a path parameter of the API call.\n\n  If you ever need your API keys, you can find them in [your Tatum account](https://dashboard.tatum.io/).\n\n* **Get an auto-generated API key attached to API calls.**\n\n  Make an API call without any API key provided. The API key will be generated and tied to your IP address.\n  This API key is stored within the Tatum platform and is automatically attached to all your API calls.\n\n  With the auto-generated API key:\n  * You can make up to five API calls per second.\n  * You get 10,000,000 credits to spend on API calls within a month.\n\n    The number of credits is reset on the first day of a month. The unused credits from the current month are not\n    rolled over to the next month.\n\n  These limits are applied to both the testnet and mainnet.\n\n  By default, API calls with the auto-generated API key are executed against the mainnet.\n  To make an API call to the testnet, add the `type` query parameter set to `testnet` to the endpoint URL,\n  for example:\n\n  `https://api-eu1.tatum.io/v3/ledger/account?type=testnet`\n"
      }
    }
  }
}
